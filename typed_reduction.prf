(typed_reduction
 (typeinfo_fill_TCC1 0
  (typeinfo_fill_TCC1-1 nil 3701693785 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[typeinfo_ctx])"
     typed_reduction nil))
   nil
   (typeinfo_fill termination
    "typed_reduction.typeinfo_fill(typed_reduction.tK1, typed_reduction.tA)"
    "nil")))
 (typeinfo_fill_TCC2 0
  (typeinfo_fill_TCC2-1 nil 3701693785 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[typeinfo_ctx])"
     typed_reduction nil))
   nil
   (typeinfo_fill termination
    "typed_reduction.typeinfo_fill(typed_reduction.tK1, typed_reduction.tA)"
    "nil")))
 (expr_type_TCC1 0
  (expr_type_TCC1-1 nil 3701611420 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[typeinfo])" typeinfo_adt
     nil))
   nil
   (expr_type termination
    "typed_reduction.expr_type(typed_reduction.body)" "nil")))
 (expr_type_TCC2 0
  (expr_type_TCC2-1 nil 3701611420 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[typeinfo])" typeinfo_adt
     nil))
   nil
   (expr_type termination
    "typed_reduction.expr_type(typed_reduction.pbody)" "nil")))
 (expr_type_TCC3 0
  (expr_type_TCC3-1 nil 3701611420 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[typeinfo])" typeinfo_adt
     nil))
   nil
   (expr_type termination
    "typed_reduction.expr_type(typed_reduction.rbody)" "nil")))
 (expr_type_TCC4 0
  (expr_type_TCC4-1 nil 3701611420 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[typeinfo])" typeinfo_adt
     nil))
   nil
   (expr_type termination
    "typed_reduction.expr_type(typed_reduction.tthen)" "nil")))
 (tvars_TCC1 0
  (tvars_TCC1-1 nil 3701615503 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil
   (tvars termination "typed_reduction.tvars(typed_reduction.B)"
    "nil")))
 (tvars_TCC2 0
  (tvars_TCC2-1 nil 3701615503 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil
   (tvars termination "typed_reduction.tvars(typed_reduction.C)"
    "nil")))
 (tvars_TCC3 0
  (tvars_TCC3-1 nil 3701615503 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil
   (tvars termination "typed_reduction.tvars(typed_reduction.B)"
    "nil")))
 (tvars_TCC4 0
  (tvars_TCC4-1 nil 3701615503 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil
   (tvars termination "typed_reduction.tvars(typed_reduction.C)"
    "nil")))
 (tvars_TCC5 0
  (tvars_TCC5-1 nil 3701615503 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil
   (tvars termination "typed_reduction.tvars(typed_reduction.B)"
    "nil")))
 (tvars_TCC6 0
  (tvars_TCC6-1 nil 3701615503 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (tvars subtype "(number_fields.-)(typed_reduction.i, 1)" "nat")))
 (tvars_TCC7 0
  (tvars_TCC7-1 nil 3701615503 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil
   (tvars termination "typed_reduction.tvars(typed_reduction.B)"
    "nil")))
 (popn_TCC1 0
  (popn_TCC1-1 nil 3701626353 ("" (subtype-tcc) nil nil) nil nil
   (popn subtype
    "(number_fields.-)(typed_reduction.L`length, typed_reduction.n)"
    "nat")))
 (popn_TCC2 0
  (popn_TCC2-1 nil 3701626353 ("" (subtype-tcc) nil nil) nil nil
   (popn subtype "typed_reduction.i" "below[L`length]")))
 (popn_popn_TCC1 0
  (popn_popn_TCC1-1 nil 3701697545 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (popn_popn subtype "typed_reduction.i"
    "naturalnumbers.upto(typed_reduction.L`length)")))
 (popn_popn_TCC2 0
  (popn_popn_TCC2-1 nil 3701697545 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (popn const-decl "finseq[nat]" typed_reduction nil))
   nil
   (popn_popn subtype "typed_reduction.j"
    "naturalnumbers.upto(typed_reduction.popn(typed_reduction.L, typed_reduction.i)`length)")))
 (popn_popn 0
  (popn_popn-1 nil 3701697545 ("" (grind) nil nil)
   ((popn const-decl "finseq[nat]" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (popn_zero_TCC1 0
  (popn_zero_TCC1-1 nil 3701790265 ("" (subtype-tcc) nil nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (popn_zero subtype "0"
    "naturalnumbers.upto(typed_reduction.L`length)")))
 (popn_zero 0
  (popn_zero-1 nil 3701790265 ("" (grind-with-ext) nil nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil))
   shostak))
 (add_append 0
  (add_append-1 nil 3702735873
   ("" (skeep)
    (("" (decompose-equality)
      (("1" (grind) nil nil)
       ("2" (decompose-equality)
        (("2" (expand* o add)
          (("2" (lift-if)
            (("2" (simplify)
              (("2" (lift-if) (("2" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((O const-decl "finseq" finite_sequences nil)
    (seq type-eq-decl nil more_finseq nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (< const-decl "bool" reals nil))
   shostak))
 (popn_append_TCC1 0
  (popn_append_TCC1-1 nil 3702735872 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (O const-decl "finseq" finite_sequences nil))
   nil
   (popn_append subtype "typed_reduction.i"
    "naturalnumbers.upto((finite_sequences[naturalnumbers.nat].o(typed_reduction.L, typed_reduction.M))`length)")))
 (popn_append 0
  (popn_append-1 nil 3702736020
   ("" (skeep*)
    (("" (decompose-equality)
      (("1" (grind) nil nil)
       ("2" (decompose-equality)
        (("2" (expand o)
          (("2" (expand popn) (("2" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (O const-decl "finseq" finite_sequences nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (< const-decl "bool" reals nil))
   shostak))
 (is_well_typed_TCC1 0
  (is_well_typed_TCC1-1 nil 3701611553
   ("" (skeep :preds? t) (("" (grind) nil nil)) nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (contextPure? def-decl "bool" IL nil))
   nil
   (is_well_typed subtype "typed_reduction.rhs" "(IL.contextPure?)")))
 (is_well_typed_TCC2 0
  (is_well_typed_TCC2-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (grind) nil nil)
       ("2" (skeep) (("2" (inst -4 i) (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((popDepth def-decl "nat" IL nil)
    (contextPure? def-decl "bool" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/"))
   nil
   (is_well_typed subtype "typed_reduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_reduction.rhs), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_reduction.rhs)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (is_well_typed_TCC3 0
  (is_well_typed_TCC3-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (lemma pure_contextPure)
      (("" (inst -1 body) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((pure_contextPure formula-decl nil IL nil)
    (contextPure? def-decl "bool" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (IExpression type-decl nil IExpression_adt nil))
   nil
   (is_well_typed subtype "typed_reduction.body" "(IL.contextPure?)")))
 (is_well_typed_TCC4 0
  (is_well_typed_TCC4-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (lemma pure_contextPure)
      (("" (split)
        (("1" (rewrite purePopDepth)
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
         ("2" (skeep)
          (("2" (inst -5 "i-1")
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((pure_contextPure formula-decl nil IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (contextPure? def-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil))
   nil
   (is_well_typed subtype "typed_reduction.A"
    "(IExpression_adt.letexpr?)")))
 (is_well_typed_TCC5 0
  (is_well_typed_TCC5-1 nil 3701611553
   ("" (skeep :preds? t) (("" (grind) nil nil)) nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil))
   nil
   (is_well_typed subtype
    "IL.popDepth(IExpression_adt.letrhs(typed_reduction.A))"
    "naturalnumbers.upto(typed_reduction.stypes`length)")))
 (is_well_typed_TCC6 0
  (is_well_typed_TCC6-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
       ("2" (skeep :preds? t)
        (("2" (inst -5 "i-1+popDepth(letrhs(A))")
          (("1" (grind) (("1" (rewrite cvars_pure) nil nil)) nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (i skolem-const-decl "nat" typed_reduction nil)
    (A skolem-const-decl "(contextPure?)" typed_reduction nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (cvars_pure formula-decl nil preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (is_well_typed subtype
    "more_finseq[naturalnumbers.nat].add(typeinfo_adt.lettype(typed_reduction.tA), typed_reduction.popn(typed_reduction.stypes, IL.popDepth(IExpression_adt.letrhs(typed_reduction.A))))"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_reduction.body), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_reduction.body)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (is_well_typed_TCC7 0
  (is_well_typed_TCC7-1 nil 3701611553
   ("" (skeep :preds? t) (("" (grind) nil nil)) nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil))
   nil
   (is_well_typed termination
    "typed_reduction.is_well_typed(typed_reduction.body, typeinfo_adt.lbody(typed_reduction.tA), more_finseq[naturalnumbers.nat].add(typeinfo_adt.lettype(typed_reduction.tA), typed_reduction.popn(typed_reduction.stypes, IL.popDepth(IExpression_adt.letrhs(typed_reduction.A)))), typed_reduction.dom_types, typed_reduction.def_types)"
    "nil")))
 (is_well_typed_TCC8 0
  (is_well_typed_TCC8-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (grind) nil nil)
       ("2" (skeep) (("2" (inst -4 "i+1") (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (contextPure? def-decl "bool" IL nil))
   nil
   (is_well_typed subtype "typed_reduction.body" "(IL.contextPure?)")))
 (is_well_typed_TCC9 0
  (is_well_typed_TCC9-1 nil 3701611553 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (popDepth def-decl "nat" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (is_well_typed subtype "typed_reduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_reduction.body), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_reduction.body)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (is_well_typed_TCC10 0
  (is_well_typed_TCC10-1 nil 3701611553 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (popDepth def-decl "nat" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil
   (is_well_typed termination
    "typed_reduction.is_well_typed(typed_reduction.body, typeinfo_adt.ptbody(typed_reduction.tA), typed_reduction.stypes, typed_reduction.dom_types, typed_reduction.def_types)"
    "nil")))
 (is_well_typed_TCC11 0
  (is_well_typed_TCC11-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (grind) nil nil) ("2" (skeep) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (contextPure? def-decl "bool" IL nil))
   nil
   (is_well_typed subtype "typed_reduction.body" "(IL.contextPure?)")))
 (is_well_typed_TCC12 0
  (is_well_typed_TCC12-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (grind) nil nil) ("2" (skeep) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((popDepth def-decl "nat" IL nil)
    (contextPure? def-decl "bool" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil
   (is_well_typed subtype "typed_reduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_reduction.body), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_reduction.body)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (is_well_typed_TCC13 0
  (is_well_typed_TCC13-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (grind) nil nil)
       ("2" (skeep) (("2" (inst -4 i) (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil))
   nil
   (is_well_typed termination
    "typed_reduction.is_well_typed(typed_reduction.body, typed_reduction.tA, typed_reduction.stypes, typed_reduction.dom_types, typed_reduction.def_types)"
    "nil")))
 (is_well_typed_TCC14 0
  (is_well_typed_TCC14-1 nil 3701611553 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (popDepth def-decl "nat" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (singleton const-decl "(singleton?)" sets nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (is_well_typed subtype
    "(number_fields.-)((number_fields.-)(typed_reduction.stypes`length, 1), typed_reduction.index)"
    "below[stypes`length]")))
 (is_well_typed_TCC15 0
  (is_well_typed_TCC15-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (inst -3 index) (("" (grind) nil nil)) nil)) nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (contextPure? def-decl "bool" IL nil))
   nil
   (is_well_typed subtype "typed_reduction.c" "(IL.contextPure?)")))
 (is_well_typed_TCC16 0
  (is_well_typed_TCC16-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((popDepth def-decl "nat" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (contextPure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (singleton const-decl "(singleton?)" sets nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil))
   nil
   (is_well_typed subtype "typed_reduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_reduction.c), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_reduction.c)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (is_well_typed_TCC17 0
  (is_well_typed_TCC17-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil))
   nil
   (is_well_typed termination
    "typed_reduction.is_well_typed(typed_reduction.c, typeinfo_adt.leaft(0), typed_reduction.stypes, typed_reduction.dom_types, typed_reduction.def_types)"
    "nil")))
 (is_well_typed_TCC18 0
  (is_well_typed_TCC18-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (lemma pure_contextPure (A texpr)) (("" (grind) nil nil))
      nil))
    nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (pure_contextPure formula-decl nil IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (contextPure? def-decl "bool" IL nil))
   nil
   (is_well_typed subtype "typed_reduction.texpr"
    "(IL.contextPure?)")))
 (is_well_typed_TCC19 0
  (is_well_typed_TCC19-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (rewrite cvars_pure)
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (contextPure? def-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (cvars_pure formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil
   (is_well_typed subtype "typed_reduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_reduction.texpr), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_reduction.texpr)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (is_well_typed_TCC20 0
  (is_well_typed_TCC20-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (rewrite cvars_pure)
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((purePopDepth formula-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (popDepth def-decl "nat" IL nil) (pure? def-decl "bool" IL nil))
   nil
   (is_well_typed termination
    "typed_reduction.is_well_typed(typed_reduction.texpr, typeinfo_adt.tthen(typed_reduction.tA), typed_reduction.stypes, typed_reduction.dom_types, typed_reduction.def_types)"
    "nil")))
 (is_well_typed_TCC21 0
  (is_well_typed_TCC21-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (lemma pure_contextPure (A eexpr)) (("" (grind) nil nil))
      nil))
    nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (pure_contextPure formula-decl nil IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (contextPure? def-decl "bool" IL nil))
   nil
   (is_well_typed subtype "typed_reduction.eexpr"
    "(IL.contextPure?)")))
 (is_well_typed_TCC22 0
  (is_well_typed_TCC22-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (rewrite cvars_pure)
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (contextPure? def-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (cvars_pure formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil
   (is_well_typed subtype "typed_reduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_reduction.eexpr), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_reduction.eexpr)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (is_well_typed_TCC23 0
  (is_well_typed_TCC23-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (rewrite cvars_pure)
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((purePopDepth formula-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (popDepth def-decl "nat" IL nil) (pure? def-decl "bool" IL nil))
   nil
   (is_well_typed termination
    "typed_reduction.is_well_typed(typed_reduction.eexpr, typeinfo_adt.telse(typed_reduction.tA), typed_reduction.stypes, typed_reduction.dom_types, typed_reduction.def_types)"
    "nil")))
 (is_well_typed_TCC24 0
  (is_well_typed_TCC24-1 nil 3701611553
   ("" (skeep* :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (contextPure? def-decl "bool" IL nil))
   nil
   (is_well_typed subtype "typed_reduction.arr" "(IL.contextPure?)")))
 (is_well_typed_TCC25 0
  (is_well_typed_TCC25-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((popDepth def-decl "nat" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (singleton const-decl "(singleton?)" sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil))
   nil
   (is_well_typed subtype "typed_reduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_reduction.arr), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_reduction.arr)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (is_well_typed_TCC26 0
  (is_well_typed_TCC26-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil))
   nil
   (is_well_typed termination
    "typed_reduction.is_well_typed(typed_reduction.arr, typeinfo_adt.leaft((number_fields.+)(typeinfo_adt.leaftype(typed_reduction.tA), 1)), typed_reduction.stypes, typed_reduction.dom_types, typed_reduction.def_types)"
    "nil")))
 (is_well_typed_TCC27 0
  (is_well_typed_TCC27-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((contextPure? def-decl "bool" IL nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (is_well_typed subtype "typed_reduction.pos" "(IL.contextPure?)")))
 (is_well_typed_TCC28 0
  (is_well_typed_TCC28-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((popDepth def-decl "nat" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (singleton const-decl "(singleton?)" sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil
   (is_well_typed subtype "typed_reduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_reduction.pos), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_reduction.pos)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (is_well_typed_TCC29 0
  (is_well_typed_TCC29-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (is_well_typed termination
    "typed_reduction.is_well_typed(typed_reduction.pos, typeinfo_adt.leaft(0), typed_reduction.stypes, typed_reduction.dom_types, typed_reduction.def_types)"
    "nil")))
 (is_well_typed_TCC30 0
  (is_well_typed_TCC30-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((contextPure? def-decl "bool" IL nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (is_well_typed subtype "typed_reduction.arr" "(IL.contextPure?)")))
 (is_well_typed_TCC31 0
  (is_well_typed_TCC31-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((popDepth def-decl "nat" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (singleton const-decl "(singleton?)" sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (is_well_typed subtype "typed_reduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_reduction.arr), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_reduction.arr)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (is_well_typed_TCC32 0
  (is_well_typed_TCC32-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil))
   nil
   (is_well_typed termination
    "typed_reduction.is_well_typed(typed_reduction.arr, typed_reduction.tA, typed_reduction.stypes, typed_reduction.dom_types, typed_reduction.def_types)"
    "nil")))
 (is_well_typed_TCC33 0
  (is_well_typed_TCC33-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((contextPure? def-decl "bool" IL nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (is_well_typed subtype "typed_reduction.pos" "(IL.contextPure?)")))
 (is_well_typed_TCC34 0
  (is_well_typed_TCC34-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((popDepth def-decl "nat" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (singleton const-decl "(singleton?)" sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (is_well_typed subtype "typed_reduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_reduction.pos), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_reduction.pos)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (is_well_typed_TCC35 0
  (is_well_typed_TCC35-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil))
   nil
   (is_well_typed termination
    "typed_reduction.is_well_typed(typed_reduction.pos, typeinfo_adt.leaft(0), typed_reduction.stypes, typed_reduction.dom_types, typed_reduction.def_types)"
    "nil")))
 (is_well_typed_TCC36 0
  (is_well_typed_TCC36-1 nil 3701611553 ("" (termination-tcc) nil nil)
   ((contextPure? def-decl "bool" IL nil)) nil
   (is_well_typed subtype "typed_reduction.rhs" "(IL.contextPure?)")))
 (is_well_typed_TCC37 0
  (is_well_typed_TCC37-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (is_well_typed subtype
    "(number_fields.-)(typeinfo_adt.leaftype(typed_reduction.tA), 1)"
    "nat")))
 (is_well_typed_TCC38 0
  (is_well_typed_TCC38-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((popDepth def-decl "nat" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (singleton const-decl "(singleton?)" sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (is_well_typed subtype "typed_reduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_reduction.rhs), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_reduction.rhs)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (is_well_typed_TCC39 0
  (is_well_typed_TCC39-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil))
   nil
   (is_well_typed termination
    "typed_reduction.is_well_typed(typed_reduction.rhs, typeinfo_adt.leaft((number_fields.-)(typeinfo_adt.leaftype(typed_reduction.tA), 1)), typed_reduction.stypes, typed_reduction.dom_types, typed_reduction.def_types)"
    "nil")))
 (is_well_typed_TCC40 0
  (is_well_typed_TCC40-1 nil 3701611553 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (popDepth def-decl "nat" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil))
   nil
   (is_well_typed subtype
    "list_props[(IExpression_adt.variable?)].nth(typed_reduction.args, typed_reduction.i)"
    "(IL.contextPure?)")))
 (is_well_typed_TCC41 0
  (is_well_typed_TCC41-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (skeep :preds? t)
      (("" (split)
        (("1" (grind) nil nil)
         ("2" (skeep)
          (("2" (inst -5 "index(nth(args, i))")
            (("2" (grind)
              (("2" (rewrite some_nth) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (is_well_typed subtype "typed_reduction.i"
    "below[def_types`seq(f)`args_type`length]")))
 (is_well_typed_TCC42 0
  (is_well_typed_TCC42-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (skeep)
      (("" (split)
        (("1" (grind) nil nil)
         ("2" (skeep)
          (("2" (replace -10)
            (("2" (inst -4 "i_1")
              (("2" (split -4)
                (("1" (propax) nil nil)
                 ("2" (expand cvars)
                  (("2" (expand vars)
                    (("2" (expand in_varlist)
                      (("2" (rewrite some_nth) (("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (contextPure? def-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (singleton const-decl "(singleton?)" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[T]" countability "sets_aux/")
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil))
   nil
   (is_well_typed subtype "typed_reduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(list_props[(IExpression_adt.variable?)].nth(typed_reduction.args, typed_reduction.i)), typed_reduction.stypes`length), FORALL (i_1: naturalnumbers.nat): booleans.IMPLIES(preprocess.cvars(list_props[(IExpression_adt.variable?)].nth(typed_reduction.args, typed_reduction.i))(i_1), reals.<(i_1, typed_reduction.stypes`length)))}")))
 (is_well_typed_TCC43 0
  (is_well_typed_TCC43-1 nil 3701626353
   ("" (skeep :preds? t)
    (("" (skeep)
      (("" (replace -9)
        (("" (expand <<)
          (("" (rewrite some_nth) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (contextPure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (some_nth formula-decl nil finseq_theorems nil))
   nil
   (is_well_typed termination
    "typed_reduction.is_well_typed(list_props[(IExpression_adt.variable?)].nth(typed_reduction.args, typed_reduction.i), typeinfo_adt.leaft(typed_reduction.def_types`seq(typed_reduction.f)`args_type`seq(typed_reduction.i)), typed_reduction.stypes, typed_reduction.dom_types, typed_reduction.def_types)"
    "nil")))
 (is_well_typed_dom 0
  (is_well_typed_dom-1 nil 3702667920
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil)
     ("5" (skeep* :preds? t)
      (("5" (expand is_well_typed +)
        (("5" (case "lett?(tA)")
          (("1" (assert)
            (("1" (inst? -4)
              (("1" (inst -4 "dom_types2")
                (("1" (split -4)
                  (("1" (inst? -5)
                    (("1" (inst -5 dom_types2)
                      (("1" (split -5)
                        (("1" (grind) nil nil)
                         ("2" (use pure_contextPure)
                          (("2" (grind) nil nil)) nil)
                         ("3" (skeep)
                          (("3" (use pure_refs) (("3" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (split)
                      (("1" (rewrite purePopDepth)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil)
                       ("2" (skeep)
                        (("2" (rewrite cvars_pure)
                          (("1" (expand cvars -)
                            (("1"
                              (inst -5 "i-1+popDepth(letexpr1_var)")
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil)
                     ("3" (grind) nil nil))
                    nil)
                   ("2" (grind) nil nil) ("3" (grind) nil nil))
                  nil))
                nil)
               ("2" (split)
                (("1" (grind) nil nil)
                 ("2" (skeep) (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("6" (skeep* :preds? t)
      (("6" (expand is_well_typed +)
        (("6" (case "iftt?(tA)")
          (("1" (inst? -5)
            (("1" (inst -5 dom_types2)
              (("1" (inst? -6)
                (("1" (inst -6 dom_types2)
                  (("1" (inst? -7)
                    (("1" (inst -7 dom_types2)
                      (("1" (split -5)
                        (("1" (split -6)
                          (("1" (split -7)
                            (("1" (grind) nil nil)
                             ("2" (use pure_contextPure)
                              (("2" (grind) nil nil)) nil)
                             ("3" (skeep)
                              (("3"
                                (use pure_refs)
                                (("3" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (use pure_contextPure)
                            (("2" (grind) nil nil)) nil)
                           ("3" (skeep)
                            (("3" (use pure_refs)
                              (("3" (grind) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil) ("3" (grind) nil nil))
                        nil))
                      nil)
                     ("2" (split)
                      (("1" (rewrite purePopDepth)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil)
                       ("2" (expand cvars -)
                        (("2" (expand vars -)
                          (("2" (skeep)
                            (("2" (rewrite cvars_pure)
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (split)
                  (("1" (rewrite purePopDepth)
                    (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
                   ("2" (skeep)
                    (("2" (rewrite cvars_pure)
                      (("1" (expand cvars -) (("1" (grind) nil nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand cvars -3)
              (("2" (expand vars -3)
                (("2" (expand add)
                  (("2" (expand union)
                    (("2" (expand member)
                      (("2" (split)
                        (("1" (grind) nil nil)
                         ("2" (skeep) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)
     ("10" (grind) nil nil)
     ("11" (skeep* :preds? t)
      (("11" (expand is_well_typed +)
        (("11" (case "popt?(tA)")
          (("1" (assert)
            (("1" (inst -4 "ptbody(tA)" _ _ _ _)
              (("1" (inst? -4)
                (("1" (split -4)
                  (("1" (propax) nil nil) ("2" (grind) nil nil)
                   ("3" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("12" (grind) nil nil)
     ("13" (skeep* :preds? t)
      (("13" (expand is_well_typed +)
        (("13" (inst? -5)
          (("13" (split -5)
            (("1" (propax) nil nil) ("2" (grind) nil nil)
             ("3" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (emptyset const-decl "set" sets nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (ptbody adt-accessor-decl "[(popt?) -> typeinfo]" typeinfo_adt nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (iftt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[T]" countability "sets_aux/")
    (singleton const-decl "(singleton?)" sets nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (add const-decl "(nonempty?)" sets nil)
    (telse adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (tthen adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (tA skolem-const-decl "typeinfo" typed_reduction nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaft adt-constructor-decl "[nat -> (leaft?)]" typeinfo_adt nil)
    (stypes skolem-const-decl "{stypes |
   popDepth(ift(ift1_var, ift2_var, ift3_var)) <= stypes`length AND
    FORALL i:
      cvars(ift(ift1_var, ift2_var, ift3_var))(i) IMPLIES i < stypes`length}"
     typed_reduction nil)
    (ift3_var skolem-const-decl "IExpression" typed_reduction nil)
    (ift2_var skolem-const-decl "IExpression" typed_reduction nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift1_var skolem-const-decl "(variable?)" typed_reduction nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (letexpr1_var skolem-const-decl "IExpression" typed_reduction nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr2_var skolem-const-decl "IExpression" typed_reduction nil)
    (stypes skolem-const-decl "{stypes |
   popDepth(letexpr(letexpr1_var, letexpr2_var)) <= stypes`length AND
    FORALL i:
      cvars(letexpr(letexpr1_var, letexpr2_var))(i) IMPLIES
       i < stypes`length}" typed_reduction nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (purePopDepth formula-decl nil IL nil)
    (cvars_pure formula-decl nil preprocess nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (i skolem-const-decl "nat" typed_reduction nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (pure_refs formula-decl nil IL nil)
    (pure_contextPure formula-decl nil IL nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (tA skolem-const-decl "typeinfo" typed_reduction nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (seq type-eq-decl nil more_finseq nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (refs def-decl "bool" IL nil) (contextPure? def-decl "bool" IL nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (letApply_type_TCC1 0
  (letApply_type_TCC1-1 nil 3702672884 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (letApply_type subtype "typed_reduction.args_type"
    "(list_adt[naturalnumbers.nat].cons?)")))
 (letApply_type_TCC2 0
  (letApply_type_TCC2-1 nil 3702672884 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (letApply_type subtype "(number_fields.-)(typed_reduction.arity, 1)"
    "nat")))
 (letApply_type_TCC3 0
  (letApply_type_TCC3-1 nil 3702672884
   ("" (skeep* :preds? t)
    (("" (expand length -) (("" (grind) nil nil)) nil)) nil)
   ((length def-decl "nat" list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (letApply_type subtype
    "list_adt[naturalnumbers.nat].cdr(typed_reduction.args_type)"
    "{args_type: list_adt[naturalnumbers.nat].list | list_props[naturalnumbers.nat].length(args_type) = (number_fields.-)(typed_reduction.arity, 1)}")))
 (letApply_type_TCC4 0
  (letApply_type_TCC4-1 nil 3702672884 ("" (termination-tcc) nil nil)
   nil nil
   (letApply_type termination
    "typed_reduction.letApply_type((number_fields.-)(typed_reduction.arity, 1), list_adt[naturalnumbers.nat].cdr(typed_reduction.args_type), typed_reduction.tA)"
    "nil")))
 (is_well_typed_extend_stack_TCC1 0
  (is_well_typed_extend_stack_TCC1-1 nil 3702733169
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (grind) nil nil)
       ("2" (skeep) (("2" (inst?) (("2" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (O const-decl "finseq" finite_sequences nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (is_well_typed_extend_stack subtype
    "finite_sequences[naturalnumbers.nat].o(typed_reduction.stypes2, typed_reduction.stypes)"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_reduction.A), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_reduction.A)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (is_well_typed_extend_stack 0
  (is_well_typed_extend_stack-2 nil 3705866718
   ("" (induct A)
    (("1" (skeep* :preds? t)
      (("1" (expand is_well_typed)
        (("1" (expand o)
          (("1" (case "variable1_var < stypes`length")
            (("1" (assert) nil nil) ("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (skeep* :preds? t)
      (("4" (expand is_well_typed +)
        (("4" (assert)
          (("4"
            (case "application1_var < def_types`length AND
   tA = leaft(def_types`seq(application1_var)`return_type) AND
   length(application2_var) =
   def_types`seq(application1_var)`args_type`length")
            (("1" (flatten)
              (("1" (assert)
                (("1"
                  (case "forall (i: below(length(application2_var))): is_well_typed(nth(application2_var, i),
     leaft(def_types`seq(application1_var)`args_type`seq
     (i)),
     stypes2 o stypes, dom_types, def_types) =
     is_well_typed(nth(application2_var, i),
     leaft(def_types`seq(application1_var)`args_type`seq                               (i)),
     stypes, dom_types, def_types)")
                  (("1" (iff)
                    (("1" (split)
                      (("1" (flatten)
                        (("1" (skeep)
                          (("1" (inst?)
                            (("1" (inst?) (("1" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (skeep)
                          (("2" (inst?)
                            (("2" (inst?) (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (delete 2)
                    (("2" (skeep)
                      (("2" (rewrite every_nth)
                        (("2" (rewrite every_nth)
                          (("1" (inst -8 i)
                            (("1" (inst? -8) (("1" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (delete 2)
                            (("2" (skeep* :preds? t)
                              (("2"
                                (expand o)
                                (("2"
                                  (split)
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (skeep)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (delete 2)
                    (("3" (skeep :preds? t)
                      (("3" (split)
                        (("1" (grind) nil nil)
                         ("2" (skeep)
                          (("2"
                            (case "variable?(nth(application2_var, i))")
                            (("1" (assert)
                              (("1"
                                (expand cvars)
                                (("1"
                                  (expand vars)
                                  (("1"
                                    (expand singleton)
                                    (("1"
                                      (grind)
                                      (("1"
                                        (rewrite some_nth)
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("4" (delete 2)
                    (("4" (skeep)
                      (("4" (split)
                        (("1" (grind) nil nil)
                         ("2" (skeep)
                          (("2" (expand o)
                            (("2"
                              (case "variable?(nth(application2_var, i))")
                              (("1"
                                (assert)
                                (("1"
                                  (expand cvars)
                                  (("1"
                                    (expand vars)
                                    (("1"
                                      (expand singleton)
                                      (("1"
                                        (typepred "stypes")
                                        (("1"
                                          (inst -2 i_1)
                                          (("1"
                                            (expand cvars)
                                            (("1"
                                              (expand vars)
                                              (("1"
                                                (expand in_varlist)
                                                (("1"
                                                  (rewrite some_nth)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("5" (skeep)
                    (("5" (case "variable?(nth(application2_var, i))")
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep* :preds? t)
      (("5" (expand is_well_typed +)
        (("5" (case "lett?(tA)")
          (("1" (assert)
            (("1" (inst? -4)
              (("1"
                (inst -5 "lbody(tA)"
                 "add(lettype(tA),                            popn(stypes, popDepth(letexpr1_var)))"
                 stypes2 dom_types def_types)
                (("1" (rewrite add_append)
                  (("1" (rewrite popn_append)
                    (("1" (split -5)
                      (("1" (split -5)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil)
                       ("2" (use pure_contextPure)
                        (("2" (grind) nil nil)) nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (delete 2)
                  (("2" (split)
                    (("1" (rewrite purePopDepth)
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil)
                     ("2" (skeep)
                      (("2" (rewrite cvars_pure)
                        (("1" (inst -4 "i-1+popDepth(letexpr1_var)")
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (grind) nil nil))
                nil)
               ("2" (delete 2)
                (("2" (split)
                  (("1" (grind) nil nil)
                   ("2" (skeep) (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("6" (skeep* :preds? t)
      (("6" (expand is_well_typed +)
        (("6" (case "iftt?(tA)")
          (("1" (assert)
            (("1" (inst? -5)
              (("1" (inst? -6)
                (("1" (inst? -7)
                  (("1" (split -7)
                    (("1" (split -7)
                      (("1" (split -7)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil)
                       ("2" (use pure_contextPure)
                        (("2" (grind) nil nil)) nil))
                      nil)
                     ("2" (use pure_contextPure)
                      (("2" (grind) nil nil)) nil))
                    nil)
                   ("2" (delete 2)
                    (("2" (split)
                      (("1" (rewrite purePopDepth)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil)
                       ("2" (skeep)
                        (("2" (inst?)
                          (("2" (rewrite cvars_pure)
                            (("1" (grind) nil nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete 2)
                  (("2" (split)
                    (("1" (rewrite purePopDepth)
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil)
                     ("2" (skeep)
                      (("2" (rewrite cvars_pure)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (delete 2)
                (("2" (split)
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand is_well_typed +)
        (("7" (case "leaft?(tA) AND leaftype(tA) > 0")
          (("1" (assert)
            (("1" (flatten)
              (("1" (assert)
                (("1" (inst? -8)
                  (("1" (inst? -9)
                    (("1" (inst? -10)
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil)
                     ("2" (delete 2) (("2" (grind) nil nil)) nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("8" (skeep* :preds? t)
      (("8" (expand is_well_typed +)
        (("8" (case "leaft?(tA)")
          (("1" (assert)
            (("1" (inst? -6)
              (("1" (inst? -7)
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
               ("2" (grind) nil nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (skeep* :preds? t)
      (("11" (expand is_well_typed +)
        (("11" (case "popt?(tA)")
          (("1" (assert) (("1" (inst? -4) (("1" (grind) nil nil)) nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("12" (grind) nil nil)
     ("13" (skeep* :preds? t)
      (("13" (expand is_well_typed +)
        (("13" (inst? -5) (("13" (grind) nil nil)) nil)) nil))
      nil)
     ("14" (delete 2)
      (("14" (skeep* :preds? t)
        (("14" (expand o)
          (("14" (split)
            (("1" (grind) nil nil)
             ("2" (skeep) (("2" (inst?) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ptbody adt-accessor-decl "[(popt?) -> typeinfo]" typeinfo_adt nil)
    (lookup1_var skolem-const-decl "(variable?)" typed_reduction nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (lookup2_var skolem-const-decl "(variable?)" typed_reduction nil)
    (stypes skolem-const-decl "{stypes |
   popDepth(lookup(lookup1_var, lookup2_var)) <= stypes`length AND
    FORALL i:
      cvars(lookup(lookup1_var, lookup2_var))(i) IMPLIES i < stypes`length}"
     typed_reduction nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (> const-decl "bool" reals nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (update1_var skolem-const-decl "(variable?)" typed_reduction nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (update adt-constructor-decl
     "[[(variable?), (variable?), (variable?)] -> (update?)]"
     IExpression_adt nil)
    (update2_var skolem-const-decl "(variable?)" typed_reduction nil)
    (update3_var skolem-const-decl "(variable?)" typed_reduction nil)
    (stypes skolem-const-decl "{stypes |
   popDepth(update(update1_var, update2_var, update3_var)) <= stypes`length
    AND
    FORALL i:
      cvars(update(update1_var, update2_var, update3_var))(i) IMPLIES
       i < stypes`length}" typed_reduction nil)
    (emptyset const-decl "set" sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (iftt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (ift1_var skolem-const-decl "(variable?)" typed_reduction nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift2_var skolem-const-decl "IExpression" typed_reduction nil)
    (ift3_var skolem-const-decl "IExpression" typed_reduction nil)
    (stypes skolem-const-decl "{stypes |
   popDepth(ift(ift1_var, ift2_var, ift3_var)) <= stypes`length AND
    FORALL i:
      cvars(ift(ift1_var, ift2_var, ift3_var))(i) IMPLIES i < stypes`length}"
     typed_reduction nil)
    (telse adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (tthen adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (letexpr1_var skolem-const-decl "IExpression" typed_reduction nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr2_var skolem-const-decl "IExpression" typed_reduction nil)
    (stypes skolem-const-decl "{stypes |
   popDepth(letexpr(letexpr1_var, letexpr2_var)) <= stypes`length AND
    FORALL i:
      cvars(letexpr(letexpr1_var, letexpr2_var))(i) IMPLIES
       i < stypes`length}" typed_reduction nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (i skolem-const-decl "nat" typed_reduction nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (cvars_pure formula-decl nil preprocess nil)
    (purePopDepth formula-decl nil IL nil)
    (add_append formula-decl nil typed_reduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pure_contextPure formula-decl nil IL nil)
    (popn_append formula-decl nil typed_reduction nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (tA skolem-const-decl "typeinfo" typed_reduction nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (seq type-eq-decl nil more_finseq nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (every_nth formula-decl nil list_props nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (leaft adt-constructor-decl "[nat -> (leaft?)]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (singleton const-decl "(singleton?)" sets nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (O const-decl "finseq" finite_sequences nil))
   nil)
  (is_well_typed_extend_stack-1 nil 3702733170
   ("" (induct A)
    (("1" (skeep* :preds? t)
      (("1" (expand is_well_typed)
        (("1" (expand o)
          (("1" (case "variable1_var < stypes`length")
            (("1" (assert) nil nil) ("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (skeep* :preds? t)
      (("4" (expand is_well_typed +)
        (("4" (assert)
          (("4"
            (case "application1_var < def_types`length ANDn        tA = leaft(def_types`seq(application1_var)`return_type) ANDn         length(application2_var) =n          def_types`seq(application1_var)`args_type`length")
            (("1" (flatten)
              (("1" (assert)
                (("1"
                  (case "forall (i: below(length(application2_var))): is_well_typed(nth(application2_var, i),n                       leaft(def_types`seq(application1_var)`args_type`seqn                                 (i)),n                       stypes2 o stypes, dom_types, def_types) =n         is_well_typed(nth(application2_var, i),n                       leaft(def_types`seq(application1_var)`args_type`seqn                                 (i)),n                       stypes, dom_types, def_types)")
                  (("1" (iff)
                    (("1" (split)
                      (("1" (flatten)
                        (("1" (skeep)
                          (("1" (inst?)
                            (("1" (inst?) (("1" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (skeep)
                          (("2" (inst?)
                            (("2" (inst?) (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (delete 2)
                    (("2" (skeep)
                      (("2" (rewrite every_nth)
                        (("2" (rewrite every_nth)
                          (("1" (inst -8 i)
                            (("1" (inst? -8) (("1" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (delete 2)
                            (("2" (skeep* :preds? t)
                              (("2"
                                (expand o)
                                (("2"
                                  (split)
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (skeep)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (delete 2)
                    (("3" (skeep :preds? t)
                      (("3" (split)
                        (("1" (grind) nil nil)
                         ("2" (skeep)
                          (("2"
                            (case "variable?(nth(application2_var, i))")
                            (("1" (assert)
                              (("1"
                                (expand cvars)
                                (("1"
                                  (expand vars)
                                  (("1"
                                    (expand singleton)
                                    (("1"
                                      (grind)
                                      (("1"
                                        (rewrite some_nth)
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("4" (delete 2)
                    (("4" (skeep)
                      (("4" (split)
                        (("1" (grind) nil nil)
                         ("2" (skeep)
                          (("2" (expand o)
                            (("2"
                              (case "variable?(nth(application2_var, i))")
                              (("1"
                                (assert)
                                (("1"
                                  (expand cvars)
                                  (("1"
                                    (expand vars)
                                    (("1"
                                      (expand singleton)
                                      (("1"
                                        (typepred "stypes")
                                        (("1"
                                          (inst -2 i_1)
                                          (("1"
                                            (expand cvars)
                                            (("1"
                                              (expand vars)
                                              (("1"
                                                (expand in_varlist)
                                                (("1"
                                                  (rewrite some_nth)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("5" (skeep)
                    (("5" (case "variable?(nth(application2_var, i))")
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep* :preds? t)
      (("5" (expand is_well_typed +)
        (("5" (case "lett?(tA)")
          (("1" (assert)
            (("1" (inst? -4)
              (("1"
                (inst -5 "lbody(tA)"
                 "add(lettype(tA),n                            popn(stypes, popDepth(letexpr1_var)))"
                 stypes2 dom_types def_types)
                (("1" (rewrite add_append)
                  (("1" (rewrite popn_append)
                    (("1" (split -5)
                      (("1" (split -5)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil)
                       ("2" (use pure_contextPure)
                        (("2" (grind) nil nil)) nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (delete 2)
                  (("2" (split)
                    (("1" (rewrite purePopDepth)
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil)
                     ("2" (skeep)
                      (("2" (rewrite cvars_pure)
                        (("1" (inst -4 "i-1+popDepth(letexpr1_var)")
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (grind) nil nil))
                nil)
               ("2" (delete 2)
                (("2" (split)
                  (("1" (grind) nil nil)
                   ("2" (skeep) (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("6" (skeep* :preds? t)
      (("6" (expand is_well_typed +)
        (("6" (case "iftt?(tA)")
          (("1" (assert)
            (("1" (inst? -5)
              (("1" (inst? -6)
                (("1" (inst? -7)
                  (("1" (split -7)
                    (("1" (split -7)
                      (("1" (split -7)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil)
                       ("2" (use pure_contextPure)
                        (("2" (grind) nil nil)) nil))
                      nil)
                     ("2" (use pure_contextPure)
                      (("2" (grind) nil nil)) nil))
                    nil)
                   ("2" (delete 2)
                    (("2" (split)
                      (("1" (rewrite purePopDepth)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil)
                       ("2" (skeep)
                        (("2" (inst?)
                          (("2" (rewrite cvars_pure)
                            (("1" (grind) nil nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete 2)
                  (("2" (split)
                    (("1" (rewrite purePopDepth)
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil)
                     ("2" (skeep)
                      (("2" (rewrite cvars_pure)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (delete 2)
                (("2" (split)
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand is_well_typed +)
        (("7" (case "leaft?(tA) AND leaftype(tA) > 0")
          (("1" (assert)
            (("1" (flatten)
              (("1" (assert)
                (("1" (inst? -8)
                  (("1" (inst? -9)
                    (("1" (inst? -10)
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil)
                     ("2" (delete 2) (("2" (grind) nil nil)) nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("8" (skeep* :preds? t)
      (("8" (expand is_well_typed +)
        (("8" (case "leaft?(tA)")
          (("1" (assert)
            (("1" (inst? -6)
              (("1" (inst? -7)
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
               ("2" (grind) nil nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (skeep* :preds? t)
      (("11" (expand is_well_typed +)
        (("11" (case "popt?(tA)")
          (("1" (assert) (("1" (inst? -4) (("1" (grind) nil nil)) nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("12" (grind) nil nil)
     ("13" (skeep* :preds? t)
      (("13" (expand is_well_typed +)
        (("13" (inst? -5) (("13" (grind) nil nil)) nil)) nil))
      nil)
     ("14" (delete 2)
      (("14" (skeep* :preds? t)
        (("14" (expand o)
          (("14" (split)
            (("1" (grind) nil nil)
             ("2" (skeep) (("2" (inst?) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ptbody adt-accessor-decl "[(popt?) -> typeinfo]" typeinfo_adt nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (> const-decl "bool" reals nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (update adt-constructor-decl
     "[[(variable?), (variable?), (variable?)] -> (update?)]"
     IExpression_adt nil)
    (emptyset const-decl "set" sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (iftt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (telse adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (tthen adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (cvars_pure formula-decl nil preprocess nil)
    (purePopDepth formula-decl nil IL nil)
    (add_append formula-decl nil typed_reduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pure_contextPure formula-decl nil IL nil)
    (popn_append formula-decl nil typed_reduction nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (seq type-eq-decl nil more_finseq nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (every_nth formula-decl nil list_props nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (leaft adt-constructor-decl "[nat -> (leaft?)]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (singleton const-decl "(singleton?)" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (O const-decl "finseq" finite_sequences nil))
   shostak))
 (is_well_typed_letApply_TCC1 0
  (is_well_typed_letApply_TCC1-1 nil 3702730461
   ("" (subtype-tcc) nil nil)
   ((in_varlist const-decl "finite_set[nat]" IL nil)) nil
   (is_well_typed_letApply subtype "typed_reduction.i"
    "below[length[(variable?)](args)]")))
 (is_well_typed_letApply_TCC2 0
  (is_well_typed_letApply_TCC2-1 nil 3702730461
   ("" (skeep* :preds? t) (("" (grind) nil nil)) nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (contextPure? def-decl "bool" IL nil))
   nil
   (is_well_typed_letApply subtype
    "list_props[(IExpression_adt.variable?)].nth(typed_reduction.args, typed_reduction.i)"
    "(IL.contextPure?)")))
 (is_well_typed_letApply_TCC3 0
  (is_well_typed_letApply_TCC3-1 nil 3702730461
   ("" (subtype-tcc) nil nil)
   ((in_varlist const-decl "finite_set[nat]" IL nil)) nil
   (is_well_typed_letApply subtype "typed_reduction.i"
    "below[length[nat](args_type)]")))
 (is_well_typed_letApply_TCC4 0
  (is_well_typed_letApply_TCC4-1 nil 3702730461
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (rewrite cvars_pure)
          (("1" (inst -8 i_1)
            (("1" (split -8)
              (("1" (propax) nil nil)
               ("2" (expand in_varlist)
                (("2" (rewrite some_nth) (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((pure? def-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (cvars_pure formula-decl nil preprocess nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (singleton const-decl "(singleton?)" sets nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[T]" countability "sets_aux/")
    (in_varlist const-decl "finite_set[nat]" IL nil))
   nil
   (is_well_typed_letApply subtype "typed_reduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(list_props[(IExpression_adt.variable?)].nth(typed_reduction.args, typed_reduction.i)), typed_reduction.stypes`length), FORALL (i_1: naturalnumbers.nat): booleans.IMPLIES(preprocess.cvars(list_props[(IExpression_adt.variable?)].nth(typed_reduction.args, typed_reduction.i))(i_1), reals.<(i_1, typed_reduction.stypes`length)))}")))
 (is_well_typed_letApply_TCC5 0
  (is_well_typed_letApply_TCC5-1 nil 3702730461
   ("" (skeep* :preds? t)
    (("" (use pure_contextPure) (("" (grind) nil nil)) nil)) nil)
   ((pure_contextPure formula-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil))
   nil
   (is_well_typed_letApply subtype "typed_reduction.A"
    "(IL.contextPure?)")))
 (is_well_typed_letApply_TCC6 0
  (is_well_typed_letApply_TCC6-1 nil 3702730461
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth) (("1" (grind) nil nil)) nil)
       ("2" (skeep) (("2" (inst -9 i) (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((list2finseq const-decl "finseq[T]" list2finseq nil)
    (O const-decl "finseq" finite_sequences nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (is_well_typed_letApply subtype
    "finite_sequences[naturalnumbers.nat].o(typed_reduction.stypes, list2finseq[naturalnumbers.nat].list2finseq(typed_reduction.args_type))"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_reduction.A), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_reduction.A)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (is_well_typed_letApply_TCC7 0
  (is_well_typed_letApply_TCC7-1 nil 3702730461
   ("" (skeep* :preds? t)
    (("" (use pure_contextPure)
      (("" (use pure_letApply) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((pure_contextPure formula-decl nil IL nil)
    (letApply def-decl "IExpression" reduction nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (A skolem-const-decl "IExpression" typed_reduction nil)
    (pure_letApply recursive-judgement-axiom nil reduction nil))
   nil
   (is_well_typed_letApply subtype
    "reduction.letApply(typed_reduction.arity, typed_reduction.args, typed_reduction.A)"
    "(IL.contextPure?)")))
 (is_well_typed_letApply_TCC8 0
  (is_well_typed_letApply_TCC8-1 nil 3702730461
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth)
        (("1" (grind) nil nil) ("2" (use pure_letApply) nil nil)) nil)
       ("2" (skeep)
        (("2" (rewrite cvars_pure)
          (("1" (rewrite vars_letApply)
            (("1" (inst -8 "i + arity")
              (("1" (inst -9 i)
                (("1" (rewrite cvars_pure) (("1" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (use pure_letApply) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((pure? def-decl "bool" IL nil)
    (pure_letApply recursive-judgement-axiom nil reduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (letApply def-decl "IExpression" reduction nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (cvars_pure formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (vars_letApply formula-decl nil reduction nil))
   nil
   (is_well_typed_letApply subtype "typed_reduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(reduction.letApply(typed_reduction.arity, typed_reduction.args, typed_reduction.A)), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(reduction.letApply(typed_reduction.arity, typed_reduction.args, typed_reduction.A))(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (is_well_typed_letApply 0
  (is_well_typed_letApply-1 nil 3702730461
   ("" (induct arity)
    (("1" (skeep* :preds? t)
      (("1" (expand letApply)
        (("1" (expand letApply_type)
          (("1"
            (case-replace
             "stypes o list2finseq[nat](args_type) = stypes")
            (("1" (lemma is_well_typed_dom)
              (("1" (inst?)
                (("1" (inst -1 dom_types)
                  (("1" (split -1)
                    (("1" (grind) nil nil)
                     ("2" (use pure_contextPure)
                      (("2" (grind) nil nil)) nil)
                     ("3" (skeep)
                      (("3" (use pure_refs) (("3" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (delete 2)
              (("2" (decompose-equality)
                (("1" (grind) nil nil)
                 ("2" (decompose-equality) (("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skeep* :preds? t)
      (("2" (expand letApply +)
        (("2" (expand letApply_type +)
          (("2" (expand is_well_typed +)
            (("2" (split)
              (("1" (inst -10 0) (("1" (grind) nil nil)) nil)
               ("2" (expand expr_type) (("2" (propax) nil nil)) nil)
               ("3" (inst? -6)
                (("3" (split -6)
                  (("1" (propax) nil nil) ("2" (propax) nil nil)
                   ("3" (delete 2)
                    (("3" (expand add +)
                      (("3" (expand popn +)
                        (("3" (case-replace "popDepth(car(args)) = 0")
                          (("1" (assert) nil nil) ("2" (grind) nil nil)
                           ("3" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("4" (delete 2)
                    (("4" (skeep*)
                      (("4" (case "in_varlist(args)(i-1)")
                        (("1" (expand add)
                          (("1" (expand popn)
                            (("1"
                              (case-replace "popDepth(car(args)) = 0")
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand in_varlist)
                          (("2" (rewrite some_map)
                            (("2" (expand o)
                              (("2"
                                (case-replace
                                 "(lambda (v: (variable?)): index(v) = i - 1) = (LAMBDA (x_1: (variable?)): 1 + index(x_1) = i)")
                                (("1"
                                  (expand some +)
                                  (("1"
                                    (lift-if)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (apply-extensionality)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("3" (grind) nil nil))
                        nil))
                      nil))
                    nil)
                   ("5" (delete 2)
                    (("5" (skeep :preds? t)
                      (("5" (rewrite map_nth_rw)
                        (("1"
                          (case-replace
                           "nth(cdr(args), i) = nth(args, i + 1)")
                          (("1"
                            (case-replace
                             "nth(cdr(args_type), i) = nth(args_type, i+1)")
                            (("1"
                              (case-replace "popDepth(car(args)) = 0")
                              (("1"
                                (assert)
                                (("1"
                                  (expand is_well_typed +)
                                  (("1"
                                    (inst -13 "1+i")
                                    (("1"
                                      (expand is_well_typed -13)
                                      (("1"
                                        (expand add +)
                                        (("1" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil)
                             ("2" (expand nth 1 2)
                              (("2" (propax) nil nil)) nil))
                            nil)
                           ("2" (expand nth 1 2)
                            (("2" (propax) nil nil)) nil))
                          nil)
                         ("2" (expand length -3)
                          (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("6" (case-replace "popDepth(car(args)) = 0")
                    (("1" (assert)
                      (("1"
                        (case-replace
                         "stypes o list2finseq[nat](args_type) = add(car(args_type), stypes) o                     list2finseq[nat](cdr(args_type))")
                        (("1" (decompose-equality)
                          (("1" (case "cons?(args_type)")
                            (("1" (grind) nil nil)
                             ("2" (grind) nil nil))
                            nil)
                           ("2" (decompose-equality)
                            (("2" (expand add 1)
                              (("2"
                                (expand o 1)
                                (("2"
                                  (expand list2finseq 1)
                                  (("2"
                                    (expand nth 1 1)
                                    (("2"
                                      (lift-if 1)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (delete 2)
      (("3" (skeep :preds? t)
        (("3" (split)
          (("1" (rewrite popdepth_letApply)
            (("1" (rewrite purePopDepth)
              (("1" (rewrite purePopDepth)
                (("1" (grind) nil nil) ("2" (grind) nil nil)
                 ("3" (grind) nil nil))
                nil))
              nil))
            nil)
           ("2" (skeep)
            (("2" (rewrite cvars_pure)
              (("1" (rewrite vars_letApply)
                (("1" (inst -8 "arity + i")
                  (("1" (inst -9 i)
                    (("1" (rewrite cvars_pure) (("1" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (use pure_letApply) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (delete 2)
      (("4" (skeep* :preds? t)
        (("4" (use pure_contextPure)
          (("4" (use pure_letApply) (("4" (grind) nil nil)) nil)) nil))
        nil))
      nil)
     ("5" (delete 2)
      (("5" (skeep* :preds? t)
        (("5" (split)
          (("1" (rewrite purePopDepth) (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("6" (delete 2)
      (("6" (skeep* :preds? t)
        (("6" (use pure_contextPure) (("6" (grind) nil nil)) nil))
        nil))
      nil)
     ("7" (delete 2)
      (("7" (skeep* :preds? t)
        (("7" (split)
          (("1" (rewrite purePopDepth)
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
           ("2" (skeep)
            (("2" (rewrite cvars_pure)
              (("1" (inst -8 i_1)
                (("1" (split -8)
                  (("1" (propax) nil nil)
                   ("2" (expand in_varlist)
                    (("2" (rewrite some_nth)
                      (("2" (inst 1 i1) (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (delete 2)
      (("8" (skeep* :preds? t) (("8" (grind) nil nil)) nil)) nil))
    nil)
   ((some_nth formula-decl nil finseq_theorems nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (singleton const-decl "(singleton?)" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[T]" countability "sets_aux/")
    (A skolem-const-decl "IExpression" typed_reduction nil)
    (purePopDepth formula-decl nil IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (popdepth_letApply formula-decl nil reduction nil)
    (cvars_pure formula-decl nil preprocess nil)
    (vars_letApply formula-decl nil reduction nil)
    (pure_letApply recursive-judgement-axiom nil reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (O const-decl "T3" function_props nil)
    (some adt-def-decl "boolean" list_adt nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (some_map formula-decl nil finseq_theorems nil)
    (TRUE const-decl "bool" booleans nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (map_nth_rw formula-decl nil more_map_props nil)
    (seq type-eq-decl nil more_finseq nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (is_well_typed_dom formula-decl nil typed_reduction nil)
    (pure_refs formula-decl nil IL nil)
    (pure_contextPure formula-decl nil IL nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (letApply_type def-decl "typeinfo" typed_reduction nil)
    (pred type-eq-decl nil defined_types nil)
    (letApply def-decl "IExpression" reduction nil)
    (O const-decl "finseq" finite_sequences nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaft adt-constructor-decl "[nat -> (leaft?)]" typeinfo_adt nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (pure? def-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (contextPure? def-decl "bool" IL nil)
    (nth def-decl "T" list_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (letApply_expr_type 0
  (letApply_expr_type-1 nil 3702738102
   ("" (induct arity) (("1" (grind) nil nil) ("2" (grind) nil nil))
    nil)
   ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (letApply_type def-decl "typeinfo" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (is_well_typed_ctx_TCC1 0
  (is_well_typed_ctx_TCC1-1 nil 3701633858
   ("" (skeep :preds? t) (("" (grind) nil nil)) nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (cpure? def-decl "bool" IL nil))
   nil (is_well_typed_ctx subtype "typed_reduction.K1" "(IL.cpure?)")))
 (is_well_typed_ctx_TCC2 0
  (is_well_typed_ctx_TCC2-1 nil 3701633858
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (grind) nil nil) ("2" (skeep) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   nil
   (is_well_typed_ctx subtype "typed_reduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_reduction.K1), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_reduction.K1)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (is_well_typed_ctx_TCC3 0
  (is_well_typed_ctx_TCC3-1 nil 3701633858
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (popDepth def-decl "nat" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IContext])" IL nil))
   nil
   (is_well_typed_ctx termination
    "typed_reduction.is_well_typed_ctx(typed_reduction.K1, typed_reduction.lcrhs(typed_reduction.tK), typed_reduction.stypes, typed_reduction.dom_types, typed_reduction.def_types, typed_reduction.hole_type)"
    "nil")))
 (is_well_typed_ctx_TCC4 0
  (is_well_typed_ctx_TCC4-1 nil 3701633858
   ("" (skeep :preds? t)
    (("" (use pure_contextPure) (("" (grind) nil nil)) nil)) nil)
   ((pure_contextPure formula-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil) (cpure? def-decl "bool" IL nil))
   nil
   (is_well_typed_ctx subtype "typed_reduction.B"
    "(IL.contextPure?)")))
 (is_well_typed_ctx_TCC5 0
  (is_well_typed_ctx_TCC5-1 nil 3701633858 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (popDepth def-decl "nat" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil (is_well_typed_ctx subtype "typed_reduction.K" "(IL.letc?)")))
 (is_well_typed_ctx_TCC6 0
  (is_well_typed_ctx_TCC6-1 nil 3701633858 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (popDepth def-decl "nat" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (is_well_typed_ctx subtype
    "IL.popDepth(IL.letcrhs(typed_reduction.K))"
    "naturalnumbers.upto(typed_reduction.stypes`length)")))
 (is_well_typed_ctx_TCC7 0
  (is_well_typed_ctx_TCC7-1 nil 3701633858
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (inst -4 "i - 1 + popDepth(letcrhs(K))")
          (("1" (grind) (("1" (rewrite cvars_pure) nil nil)) nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (popDepth def-decl "nat" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (i skolem-const-decl "nat" typed_reduction nil)
    (K skolem-const-decl "(cpure?)" typed_reduction nil)
    (letcrhs adt-accessor-decl "[(letc?) -> IContext]" IL nil)
    (letc? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (IContext type-decl nil IL nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (cvars_pure formula-decl nil preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (is_well_typed_ctx subtype
    "more_finseq[naturalnumbers.nat].add(typed_reduction.letctype(typed_reduction.tK), typed_reduction.popn(typed_reduction.stypes, IL.popDepth(IL.letcrhs(typed_reduction.K))))"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_reduction.B), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_reduction.B)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (is_well_typed_ctx_TCC8 0
  (is_well_typed_ctx_TCC8-1 nil 3701633858 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (popDepth def-decl "nat" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil (is_well_typed_ctx subtype "typed_reduction.K1" "(IL.cpure?)")))
 (is_well_typed_ctx_TCC9 0
  (is_well_typed_ctx_TCC9-1 nil 3701633858
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (is_well_typed_ctx subtype "typed_reduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_reduction.K1), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_reduction.K1)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (is_well_typed_ctx_TCC10 0
  (is_well_typed_ctx_TCC10-1 nil 3701633858
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (popDepth def-decl "nat" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (<< adt-def-decl "(strict_well_founded?[IContext])" IL nil))
   nil
   (is_well_typed_ctx termination
    "typed_reduction.is_well_typed_ctx(typed_reduction.K1, typed_reduction.pctbody(typed_reduction.tK), typed_reduction.stypes, typed_reduction.dom_types, typed_reduction.def_types, typed_reduction.hole_type)"
    "nil")))
 (is_well_typed_ctx_dom 0
  (is_well_typed_ctx_dom-2 nil 3705866798
   ("" (induct K)
    (("1" (grind) nil nil)
     ("2" (skeep* :preds? t)
      (("2" (expand is_well_typed_ctx +)
        (("2" (case "letct?(tK)")
          (("1" (inst? -5)
            (("1" (inst -5 dom_types2)
              (("1" (split -5)
                (("1" (lemma is_well_typed_dom)
                  (("1"
                    (inst -1 letc2_var "lcbody(tK)"
                     "add(letctype(tK),                            popn(stypes, popDepth(letc1_var)))"
                     dom_types dom_types2 def_types)
                    (("1" (split -1)
                      (("1" (grind) nil nil)
                       ("2" (use pure_contextPure)
                        (("2" (grind) nil nil)) nil)
                       ("3" (skeep)
                        (("3" (use pure_refs) (("3" (grind) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (split)
                      (("1" (rewrite purePopDepth)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil)
                       ("2" (skeep)
                        (("2" (rewrite cvars_pure)
                          (("1" (expand cvars -)
                            (("1" (inst -5 "i-1+popDepth(letc1_var)")
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil)
                     ("3" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil)
             ("2" (split)
              (("1" (grind) nil nil)
               ("2" (skeep) (("2" (grind) nil nil)) nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("3" (skeep* :preds? t)
      (("3" (expand is_well_typed_ctx +)
        (("3" (inst? -4)
          (("1" (inst -4 dom_types2) (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil) ("3" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((popct? adt-recognizer-decl "[typeinfo_ctx -> boolean]"
     typed_reduction nil)
    (tK skolem-const-decl "typeinfo_ctx" typed_reduction nil)
    (popc1_var skolem-const-decl "IContext" typed_reduction nil)
    (popc? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (popc adt-constructor-decl "[IContext -> (popc?)]" IL nil)
    (stypes skolem-const-decl "{stypes |
   popDepth(popc(popc1_var)) <= stypes`length AND
    FORALL i: cvars(popc(popc1_var))(i) IMPLIES i < stypes`length}"
     typed_reduction nil)
    (pctbody adt-accessor-decl "[(popct?) -> typeinfo_ctx]"
     typed_reduction nil)
    (letct? adt-recognizer-decl "[typeinfo_ctx -> boolean]"
     typed_reduction nil)
    (is_well_typed_dom formula-decl nil typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (purePopDepth formula-decl nil IL nil)
    (cvars_pure formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (i skolem-const-decl "nat" typed_reduction nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pure_contextPure formula-decl nil IL nil)
    (pure_refs formula-decl nil IL nil)
    (lcbody adt-accessor-decl "[(letct?) -> typeinfo]" typed_reduction
     nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (letctype adt-accessor-decl "[(letct?) -> nat]" typed_reduction
     nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (seq type-eq-decl nil more_finseq nil)
    (popDepth def-decl "nat" IL nil)
    (lcrhs adt-accessor-decl "[(letct?) -> typeinfo_ctx]"
     typed_reduction nil)
    (stypes skolem-const-decl "{stypes |
   popDepth(letc(letc1_var, letc2_var)) <= stypes`length AND
    FORALL i:
      cvars(letc(letc1_var, letc2_var))(i) IMPLIES i < stypes`length}"
     typed_reduction nil)
    (letc2_var skolem-const-decl "IExpression" typed_reduction nil)
    (letc adt-constructor-decl "[[IContext, IExpression] -> (letc?)]"
     IL nil)
    (letc? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (letc1_var skolem-const-decl "IContext" typed_reduction nil)
    (tK skolem-const-decl "typeinfo_ctx" typed_reduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IContext_induction formula-decl nil IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   nil)
  (is_well_typed_ctx_dom-1 nil 3702669372
   ("" (induct K)
    (("1" (grind) nil nil)
     ("2" (skeep* :preds? t)
      (("2" (expand is_well_typed_ctx +)
        (("2" (case "letct?(tK)")
          (("1" (inst? -5)
            (("1" (inst -5 dom_types2)
              (("1" (split -5)
                (("1" (lemma is_well_typed_dom)
                  (("1"
                    (inst -1 letc2_var "lcbody(tK)"
                     "add(letctype(tK),n                            popn(stypes, popDepth(letc1_var)))"
                     dom_types dom_types2 def_types)
                    (("1" (split -1)
                      (("1" (grind) nil nil)
                       ("2" (use pure_contextPure)
                        (("2" (grind) nil nil)) nil)
                       ("3" (skeep)
                        (("3" (use pure_refs) (("3" (grind) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (split)
                      (("1" (rewrite purePopDepth)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil)
                       ("2" (skeep)
                        (("2" (rewrite cvars_pure)
                          (("1" (expand cvars -)
                            (("1" (inst -5 "i-1+popDepth(letc1_var)")
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil)
                     ("3" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil)
             ("2" (split)
              (("1" (grind) nil nil)
               ("2" (skeep) (("2" (grind) nil nil)) nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("3" (skeep* :preds? t)
      (("3" (expand is_well_typed_ctx +)
        (("3" (inst? -4)
          (("1" (inst -4 dom_types2) (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil) ("3" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((popct? adt-recognizer-decl "[typeinfo_ctx -> boolean]"
     typed_reduction nil)
    (popc? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (popc adt-constructor-decl "[IContext -> (popc?)]" IL nil)
    (pctbody adt-accessor-decl "[(popct?) -> typeinfo_ctx]"
     typed_reduction nil)
    (letct? adt-recognizer-decl "[typeinfo_ctx -> boolean]"
     typed_reduction nil)
    (is_well_typed_dom formula-decl nil typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (purePopDepth formula-decl nil IL nil)
    (cvars_pure formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pure_contextPure formula-decl nil IL nil)
    (pure_refs formula-decl nil IL nil)
    (lcbody adt-accessor-decl "[(letct?) -> typeinfo]" typed_reduction
     nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (letctype adt-accessor-decl "[(letct?) -> nat]" typed_reduction
     nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (seq type-eq-decl nil more_finseq nil)
    (lcrhs adt-accessor-decl "[(letct?) -> typeinfo_ctx]"
     typed_reduction nil)
    (letc adt-constructor-decl "[[IContext, IExpression] -> (letc?)]"
     IL nil)
    (letc? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IContext_induction formula-decl nil IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   shostak))
 (value_of_type_TCC1 0
  (value_of_type_TCC1-1 nil 3701781238 ("" (cases-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil))
   nil
   (value_of_type cases "typed_reduction.u" "IExpression: DATATYPE
 BEGIN
  variable(index: nat, marked: bool): variable?
  constant(value: int): constant?
  nil: nil?
  application(fun: nat, args: list[(variable?)]): application?
  letexpr(letrhs: IExpression, body: IExpression): letexpr?
  ift(condition: (variable?), thenexpr, elseexpr: IExpression): ift?
  update(target, lhs, rhs: (variable?)): update?
  lookup(arrayvalue, position: (variable?)): lookup?
  newint(size: nat): newint?
  newref(size: nat): newref?
  pop(pbody: IExpression): pop?
  ref(refindex: nat): ref?
  release(rvar: (variable?), rexpr: IExpression): release?
 END IExpression")))
 (value_well_typed_TCC1 0
  (value_well_typed_TCC1-1 nil 3701795278 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (contextPure? def-decl "bool" IL nil))
   nil
   (value_well_typed subtype "typed_reduction.u" "(IL.contextPure?)")))
 (value_well_typed_TCC2 0
  (value_well_typed_TCC2-1 nil 3701795278 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (emptyset const-decl "set" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (popDepth def-decl "nat" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (value_well_typed subtype "typed_reduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_reduction.u), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_reduction.u)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (value_well_typed 0
  (value_well_typed-1 nil 3701795278
   ("" (skeep* :preds? t) (("" (grind-with-ext) nil nil)) nil)
   ((is_well_typed def-decl "bool" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (leaft adt-constructor-decl "[nat -> (leaft?)]" typeinfo_adt nil)
    (typeinfo_leaft_extensionality formula-decl nil typeinfo_adt nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil))
   shostak))
 (typed_state_TCC1 0
  (typed_state_TCC1-1 nil 3701630090
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (typepred "state`redex") (("1" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (typepred "state`redex")
          (("2" (inst -2 "i - popDepth(state`redex)")
            (("1" (split -2)
              (("1" (grind) nil nil)
               ("2" (rewrite cvars_vars) nil nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (typed_state subtype "typed_reduction.i"
    "below[state`stack`length]")))
 (typed_state_TCC2 0
  (typed_state_TCC2-1 nil 3701631485
   ("" (with-labels (skeep* :preds? t) ((dmt sttl sttv obj)))
    (("" (split obj)
      (("1" (typepred "state`redex") (("1" (grind) nil nil)) nil)
       ("2"
        (with-labels (typepred "state`redex")
         ((href hvar hcvar hsl hcp)))
        (("2" (skeep)
          (("2" (inst hvar "i-popDepth(state`redex)")
            (("1" (rewrite cvars_vars) (("1" (grind) nil nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (cpure? def-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (cvars_vars formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (state skolem-const-decl "estate" typed_reduction nil)
    (i skolem-const-decl "nat" typed_reduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_state subtype "typed_reduction.stack_types"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_reduction.state`redex), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_reduction.state`redex)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (typed_state_TCC3 0
  (typed_state_TCC3-1 nil 3701631485
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (typepred "state`redex") (("1" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (typepred "state`redex")
          (("2" (inst -3 "i - popDepth(state`context)")
            (("1" (split -3)
              (("1" (grind) nil nil)
               ("2" (rewrite cvars_vars_ctx) (("2" (grind) nil nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_state subtype "IL.popDepth(typed_reduction.state`redex)"
    "naturalnumbers.upto(typed_reduction.stack_types`length)")))
 (typed_state_TCC4 0
  (typed_state_TCC4-1 nil 3701781238
   ("" (with-labels (skeep* :preds? t) ((dmt sttl sttv obj)))
    (("" (split obj)
      (("1" (typepred "state`redex") (("1" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2"
          (with-labels (typepred "state`redex")
           ((href hvar hcvar hsl hcp)))
          (("2" (inst hcvar "i-popDepth(state`context)")
            (("1" (rewrite cvars_vars_ctx)
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((popn const-decl "finseq[nat]" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (cpure? def-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (cvars_vars_ctx formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (state skolem-const-decl "estate" typed_reduction nil)
    (i skolem-const-decl "nat" typed_reduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_state subtype
    "typed_reduction.popn(typed_reduction.stack_types, IL.popDepth(typed_reduction.state`redex))"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_reduction.state`context), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_reduction.state`context)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (fill_type 0
  (fill_type-1 nil 3701697451
   ("" (induct tK)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil))
    nil)
   ((typeinfo_ctx_induction formula-decl nil typed_reduction nil)
    (ctx_type def-decl "nat" typed_reduction nil)
    (typeinfo_fill def-decl "typeinfo" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (typeinfo_ctx type-decl nil typed_reduction nil))
   shostak))
 (fill_well_typed_TCC1 0
  (fill_well_typed_TCC1-1 nil 3701694762 ("" (subtype-tcc) nil nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (fill_well_typed subtype "typed_reduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_reduction.A), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_reduction.A)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (fill_well_typed_TCC2 0
  (fill_well_typed_TCC2-1 nil 3701694762 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (fill_well_typed subtype "IL.popDepth(typed_reduction.A)"
    "naturalnumbers.upto(typed_reduction.stypes`length)")))
 (fill_well_typed_TCC3 0
  (fill_well_typed_TCC3-1 nil 3701694762
   ("" (skeep)
    (("" (split)
      (("1" (grind) nil nil)
       ("2" (skeep) (("2" (inst -3 i) (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (fill_well_typed subtype
    "typed_reduction.popn(typed_reduction.stypes, IL.popDepth(typed_reduction.A))"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_reduction.K), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_reduction.K)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (fill_well_typed_TCC4 0
  (fill_well_typed_TCC4-1 nil 3701694762
   ("" (skeep)
    (("" (rewrite contextPurefill) (("" (grind) nil nil)) nil)) nil)
   ((contextPurefill formula-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IContext type-decl nil IL nil))
   nil
   (fill_well_typed subtype
    "IL.fill(typed_reduction.K, typed_reduction.A)"
    "(IL.contextPure?)")))
 (fill_well_typed_TCC5 0
  (fill_well_typed_TCC5-1 nil 3701694762
   ("" (skeep)
    (("" (split)
      (("1" (rewrite popdepth_fill) nil nil)
       ("2" (skeep)
        (("2" (rewrite cvars_fill)
          (("2" (split)
            (("1" (inst -6 "i-popDepth(A)")
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
             ("2" (inst -5 i) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((IContext type-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (popdepth_fill formula-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (cvars_fill formula-decl nil preprocess nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (A skolem-const-decl "IExpression" typed_reduction nil)
    (popDepth def-decl "nat" IL nil)
    (i skolem-const-decl "nat" typed_reduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (fill_well_typed subtype "typed_reduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(IL.fill(typed_reduction.K, typed_reduction.A)), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(IL.fill(typed_reduction.K, typed_reduction.A))(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (fill_well_typed 0
  (fill_well_typed-1 nil 3701695580
   ("" (induct K)
    (("1" (skeep*)
      (("1" (case-replace "tK = holet")
        (("1" (grind) nil nil)
         ("2" (expand is_well_typed_ctx) (("2" (grind) nil nil)) nil))
        nil))
      nil)
     ("2"
      (with-labels (skeep*)
       ((hrec acp kcp sl hvar hcvar hwt hwtc obj)))
      (("2" (expand is_well_typed_ctx hwtc)
        (("2" (with-labels (flatten) ((tklc hwtc ctxt hwt2)))
          (("2" (apply-eta "tK" "(letct?)")
            (("2" (replace -1 :dir RL)
              (("2" (simplify)
                (("2" (expand fill obj)
                  (("2" (expand typeinfo_fill obj)
                    (("2" (expand is_well_typed obj)
                      (("2" (split)
                        (("1" (inst?)
                          (("1" (split hrec)
                            (("1" (propax) nil nil)
                             ("2" (propax) nil nil)
                             ("3" (grind) nil nil)
                             ("4" (grind) nil nil)
                             ("5" (propax) nil nil)
                             ("6" (grind) nil nil)
                             ("7" (propax) nil nil)
                             ("8" (propax) nil nil))
                            nil))
                          nil)
                         ("2" (rewrite fill_type) nil nil)
                         ("3" (rewrite popn_popn)
                          (("1" (rewrite popdepth_fill) nil nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3"
      (with-labels (skeep*)
       ((hrec acp kcp sl hvar hcvar hwl hwlc obj)))
      (("3" (expand is_well_typed_ctx hwlc)
        (("3" (with-labels (flatten) ((kpc hwlc)))
          (("3" (apply-eta "tK" "(popct?)")
            (("3" (replace -1 :dir RL)
              (("3" (simplify)
                (("3" (expand fill obj)
                  (("3" (expand typeinfo_fill obj)
                    (("3" (expand is_well_typed obj)
                      (("3" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (delete 2)
      (("4" (lemma fill_well_typed_TCC5)
        (("4" (skeep) (("4" (inst?) (("4" (prop) nil nil)) nil)) nil))
        nil))
      nil)
     ("5" (lemma fill_well_typed_TCC4)
      (("5" (skeep*) (("5" (inst?) (("5" (prop) nil nil)) nil)) nil))
      nil)
     ("6" (lemma fill_well_typed_TCC3)
      (("6" (skeep*)
        (("6" (inst?) (("6" (inst?) (("6" (prop) nil nil)) nil)) nil))
        nil))
      nil)
     ("7" (lemma fill_well_typed_TCC2)
      (("7" (skeep*)
        (("7" (inst?) (("7" (inst?) (("7" (prop) nil nil)) nil)) nil))
        nil))
      nil)
     ("8" (lemma fill_well_typed_TCC1)
      (("8" (skeep*) (("8" (inst?) (("8" (prop) nil nil)) nil)) nil))
      nil))
    nil)
   ((fill_well_typed_TCC1 subtype-tcc nil typed_reduction nil)
    (fill_well_typed_TCC2 subtype-tcc nil typed_reduction nil)
    (fill_well_typed_TCC3 subtype-tcc nil typed_reduction nil)
    (fill_well_typed_TCC4 subtype-tcc nil typed_reduction nil)
    (fill_well_typed_TCC5 subtype-tcc nil typed_reduction nil)
    (pctbody adt-accessor-decl "[(popct?) -> typeinfo_ctx]"
     typed_reduction nil)
    (popct? adt-recognizer-decl "[typeinfo_ctx -> boolean]"
     typed_reduction nil)
    (typeinfo_ctx_popct_eta formula-decl nil typed_reduction nil)
    (popn_popn formula-decl nil typed_reduction nil)
    (popdepth_fill formula-decl nil IL nil)
    (fill_type formula-decl nil typed_reduction nil)
    (lcrhs adt-accessor-decl "[(letct?) -> typeinfo_ctx]"
     typed_reduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (letct? adt-recognizer-decl "[typeinfo_ctx -> boolean]"
     typed_reduction nil)
    (typeinfo_ctx_letct_eta formula-decl nil typed_reduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (holet? adt-recognizer-decl "[typeinfo_ctx -> boolean]"
     typed_reduction nil)
    (holet adt-constructor-decl "(holet?)" typed_reduction nil)
    (IContext_induction formula-decl nil IL nil)
    (typeinfo_fill def-decl "typeinfo" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (fill def-decl "IExpression" IL nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (IContext type-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (cpure? def-decl "bool" IL nil)
    (contextPure? def-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (typed_to_topstate_TCC1 0
  (typed_to_topstate_TCC1-1 nil 3701694762
   ("" (skeep* :preds? t)
    (("" (typepred "tS`dom_types") (("" (grind) nil nil)) nil)) nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (topstate type-eq-decl nil reduction nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (Store type-eq-decl nil reduction nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (typed_to_topstate subtype "typed_reduction.tS`dom_types"
    "{dom_types | FORALL (r: (reduction.to_topstate(typed_reduction.tS`state)`domain)): FORALL (j: naturalnumbers.below(reduction.to_topstate(typed_reduction.tS`state)`store(r)`length)): typed_reduction.value_of_type(reduction.to_topstate(typed_reduction.tS`state)`store(r)`seq(j), typed_reduction.dom_types(r), typed_reduction.dom_types)}")))
 (typed_to_topstate_TCC2 0
  (typed_to_topstate_TCC2-2 "" 3720741952
   ("" (skeep)
    (("" (typepred "tS`stack_types")
      (("" (expand to_topstate)
        (("" (split) (("1" (propax) nil nil) ("2" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak
   (typed_to_topstate subtype "typed_reduction.tS`stack_types"
    "{stypes | booleans.AND(typed_reduction.stypes`length = reduction.to_topstate(typed_reduction.tS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_reduction.stypes`length)): typed_reduction.value_of_type(reduction.to_topstate(typed_reduction.tS`state)`stack`seq(i), typed_reduction.stypes`seq(i), typed_reduction.tS`dom_types))}"))
  (typed_to_topstate_TCC2-1 nil 3701694762
   ("" (skeep)
    (("" (typepred "tS`stack_types")
      (("" (expand to_topstate)
        (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (to_topstate const-decl "topstate" reduction nil))
   nil
   (typed_to_topstate subtype "typed_reduction.tS`stack_types"
    "{stypes | booleans.AND(typed_reduction.stypes`length = reduction.to_topstate(typed_reduction.tS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_reduction.stypes`length)): typed_reduction.value_of_type(reduction.to_topstate(typed_reduction.tS`state)`stack`seq(i), typed_reduction.stypes`seq(i), typed_reduction.tS`dom_types))}")))
 (typed_to_topstate_TCC3 0
  (typed_to_topstate_TCC3-1 nil 3701694762
   ("" (with-labels (skeep) ((obj)))
    (("" (expand to_topstate)
      ((""
        (with-labels (typepred "tS`state`redex")
         ((href hvar hcvar hsl hcp)))
        (("" (use fill_well_typed)
          (("" (split -1)
            (("1" (propax) nil nil) ("2" (propax) nil nil)
             ("3" (typepred "tS`state`context")
              (("3" (propax) nil nil)) nil)
             ("4" (typepred "tS`stack_types") (("4" (grind) nil nil))
              nil)
             ("5" (typepred "tS`stack_types")
              (("5" (skeep)
                (("5" (inst hvar "i-popDepth(tS`state`redex)")
                  (("1" (rewrite cvars_vars) (("1" (grind) nil nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil)
             ("6" (typepred "tS`stack_types")
              (("6" (skeep)
                (("6" (inst hcvar "i-popDepth(tS`state`context)")
                  (("1" (rewrite cvars_vars_ctx)
                    (("1" (grind) nil nil)) nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil)
             ("7" (typepred "tS`redex_type") (("7" (propax) nil nil))
              nil)
             ("8" (typepred "tS`context_type") (("8" (propax) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((to_topstate const-decl "topstate" reduction nil)
    (fill_well_typed formula-decl nil typed_reduction nil)
    (i skolem-const-decl "nat" typed_reduction nil)
    (cvars_vars_ctx formula-decl nil preprocess nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (i skolem-const-decl "nat" typed_reduction nil)
    (tS skolem-const-decl "typed_state" typed_reduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cvars_vars formula-decl nil preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_to_topstate subtype
    "typed_reduction.typeinfo_fill(typed_reduction.tS`context_type, typed_reduction.tS`redex_type)"
    "{tA | typed_reduction.is_well_typed(reduction.to_topstate(typed_reduction.tS`state)`redex, typed_reduction.tA, typed_reduction.tS`stack_types, typed_reduction.tS`dom_types, typed_reduction.tS`def_types)}")))
 (typed_to_topstate_TCC4 0
  (typed_to_topstate_TCC4-1 nil 3701694762
   ("" (skeep :preds? t)
    (("" (expand to_topstate) (("" (grind) nil nil)) nil)) nil)
   ((to_topstate const-decl "topstate" reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_to_topstate subtype "typed_reduction.holet"
    "{tK | typed_reduction.is_well_typed_ctx(reduction.to_topstate(typed_reduction.tS`state)`context, typed_reduction.tK, typed_reduction.popn(typed_reduction.tS`stack_types, IL.popDepth(reduction.to_topstate(typed_reduction.tS`state)`redex)), typed_reduction.tS`dom_types, typed_reduction.tS`def_types, typed_reduction.expr_type(typed_reduction.typeinfo_fill(typed_reduction.tS`context_type, typed_reduction.tS`redex_type)))}")))
 (buildRedexType_TCC1 0
  (buildRedexType_TCC1-1 nil 3701699428 ("" (grind) nil nil)
   ((value? const-decl "bool" IL nil)
    (typeinfo_fill def-decl "typeinfo" typed_reduction nil))
   nil
   (buildRedexType subtype
    "(typed_reduction.holet, typed_reduction.tA)"
    "{(tK, tB) | typed_reduction.typeinfo_fill(typed_reduction.tK, typed_reduction.tB) = typed_reduction.tA}")))
 (buildRedexType_TCC2 0
  (buildRedexType_TCC2-1 nil 3701699428
   ("" (skeep :preds? t)
    (("" (skeep)
      (("" (typepred "v(B, lrhs(tA))")
        (("" (grind) (("" (grind-with-ext) nil nil)) nil)) nil))
      nil))
    nil)
   ((value? const-decl "bool" IL nil)
    (typeinfo_lett_extensionality formula-decl nil typeinfo_adt nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (lett adt-constructor-decl "[[nat, typeinfo, typeinfo] -> (lett?)]"
     typeinfo_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (typeinfo_fill def-decl "typeinfo" typed_reduction nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil))
   nil
   (buildRedexType subtype
    "(typed_reduction.letct(typeinfo_adt.lettype(typed_reduction.tA), typed_reduction.tK, typeinfo_adt.lbody(typed_reduction.tA)), typed_reduction.tB)"
    "{(tK, tB) | typed_reduction.typeinfo_fill(typed_reduction.tK, typed_reduction.tB) = typed_reduction.tA}")))
 (buildRedexType_TCC3 0
  (buildRedexType_TCC3-1 nil 3701699428 ("" (grind) nil nil)
   ((value? const-decl "bool" IL nil)
    (typeinfo_fill def-decl "typeinfo" typed_reduction nil))
   nil
   (buildRedexType subtype
    "(typed_reduction.holet, typed_reduction.tA)"
    "{(tK, tB) | typed_reduction.typeinfo_fill(typed_reduction.tK, typed_reduction.tB) = typed_reduction.tA}")))
 (buildRedexType_TCC4 0
  (buildRedexType_TCC4-1 nil 3701699428
   ("" (skeep :preds? t)
    (("" (skeep)
      (("" (typepred "v(B, ptbody(tA))")
        (("" (grind) (("" (grind-with-ext) nil nil)) nil)) nil))
      nil))
    nil)
   ((value? const-decl "bool" IL nil)
    (typeinfo_popt_extensionality formula-decl nil typeinfo_adt nil)
    (popt adt-constructor-decl "[typeinfo -> (popt?)]" typeinfo_adt
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (typeinfo_fill def-decl "typeinfo" typed_reduction nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (ptbody adt-accessor-decl "[(popt?) -> typeinfo]" typeinfo_adt
     nil))
   nil
   (buildRedexType subtype
    "(typed_reduction.popct(typed_reduction.tK), typed_reduction.tB)"
    "{(tK, tB) | typed_reduction.typeinfo_fill(typed_reduction.tK, typed_reduction.tB) = typed_reduction.tA}")))
 (buildRedexType_TCC5 0
  (buildRedexType_TCC5-1 nil 3701699428 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (value? const-decl "bool" IL nil))
   nil
   (buildRedexType termination
    "typed_reduction.buildRedexType(typed_reduction.B, typeinfo_adt.ptbody(typed_reduction.tA))"
    "nil")))
 (buildRedexType_TCC6 0
  (buildRedexType_TCC6-1 nil 3701699428 ("" (grind) nil nil)
   ((typeinfo_fill def-decl "typeinfo" typed_reduction nil)) nil
   (buildRedexType subtype
    "(typed_reduction.holet, typed_reduction.tA)"
    "{(tK, tB) | typed_reduction.typeinfo_fill(typed_reduction.tK, typed_reduction.tB) = typed_reduction.tA}")))
 (buildRedexType_args_correct_TCC1 0
  (buildRedexType_args_correct_TCC1-1 nil 3701702657
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (buildRedexType_args_correct subtype
    "IL.popDepth(typed_reduction.B)"
    "naturalnumbers.upto(typed_reduction.stypes`length)")))
 (buildRedexType_args_correct 0
  (buildRedexType_args_correct-1 nil 3701701286
   ("" (simplify :let-reduce? t)
    (("" (skeep)
      (("" (typepred "buildRedex(A)")
        (("" (replace -1 - :dir RL)
          (("" (rewrite contextPurefill)
            (("" (rewrite popdepth_fill)
              (("" (assert)
                (("" (flatten)
                  (("" (assert)
                    (("" (split)
                      (("1" (skeep)
                        (("1" (inst - i)
                          (("1" (rewrite cvars_fill)
                            (("1" (grind) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (skeep)
                        (("2" (inst - "i+popDepth(buildRedex(A)`2)")
                          (("2" (rewrite cvars_fill)
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((popdepth_fill formula-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (cvars_fill formula-decl nil preprocess nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (contextPurefill formula-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (fill def-decl "IExpression" IL nil)
    (buildRedex def-decl "{(K, B) | fill(K, B) = A}" IL nil))
   shostak))
 (buildRedexType_correct_TCC1 0
  (buildRedexType_correct_TCC1-1 nil 3701699904
   ("" (subtype-tcc) nil nil) nil nil
   (buildRedexType_correct subtype "typed_reduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_reduction.A), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_reduction.A)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (buildRedexType_correct_TCC2 0
  (buildRedexType_correct_TCC2-1 nil 3701699904
   ("" (skeep*)
    (("" (use buildRedexType_args_correct) (("" (grind) nil nil)) nil))
    nil)
   ((buildRedexType_args_correct formula-decl nil typed_reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (buildRedexType_correct subtype "typed_reduction.B"
    "(IL.contextPure?)")))
 (buildRedexType_correct_TCC3 0
  (buildRedexType_correct_TCC3-1 nil 3701699904
   ("" (skeep*)
    (("" (use buildRedexType_args_correct) (("" (grind) nil nil)) nil))
    nil)
   ((buildRedexType_args_correct formula-decl nil typed_reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (popn const-decl "finseq[nat]" typed_reduction nil))
   nil
   (buildRedexType_correct subtype "typed_reduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_reduction.B), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_reduction.B)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (buildRedexType_correct_TCC4 0
  (buildRedexType_correct_TCC4-1 nil 3701699904
   ("" (skeep*)
    (("" (use buildRedexType_args_correct) (("" (grind) nil nil)) nil))
    nil)
   ((buildRedexType_args_correct formula-decl nil typed_reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (buildRedexType_correct subtype "typed_reduction.K" "(IL.cpure?)")))
 (buildRedexType_correct_TCC5 0
  (buildRedexType_correct_TCC5-1 nil 3701701059
   ("" (skeep*)
    (("" (use buildRedexType_args_correct) (("" (grind) nil nil)) nil))
    nil)
   ((buildRedexType_args_correct formula-decl nil typed_reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (buildRedexType_correct subtype "IL.popDepth(typed_reduction.B)"
    "naturalnumbers.upto(typed_reduction.stypes`length)")))
 (buildRedexType_correct_TCC6 0
  (buildRedexType_correct_TCC6-1 nil 3701701059
   ("" (skeep*)
    (("" (use buildRedexType_args_correct)
      (("" (split)
        (("1" (grind) nil nil)
         ("2" (skeep)
          (("2" (simplify :let-reduce? t)
            (("2" (split)
              (("1" (flatten)
                (("1" (inst -5 i) (("1" (grind) nil nil)) nil)) nil)
               ("2" (propax) nil nil) ("3" (propax) nil nil)
               ("4" (propax) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((buildRedexType_args_correct formula-decl nil typed_reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (popn const-decl "finseq[nat]" typed_reduction nil))
   nil
   (buildRedexType_correct subtype
    "typed_reduction.popn(typed_reduction.stypes, IL.popDepth(typed_reduction.B))"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_reduction.K), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_reduction.K)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (buildRedexType_correct 0
  (buildRedexType_correct-2 nil 3705855093
   ("" (simplify :let-reduce? t)
    (("" (induct A)
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (grind) nil nil) ("4" (grind) nil nil)
       ("5" (with-labels (skeep*) ((hrec1 hrec2 cp sl hvar iwt obj)))
        (("5" (expand is_well_typed iwt)
          (("5" (with-labels (flatten) ((letta iwt1 et iwt2)))
            (("5" (case "value?(letexpr1_var)")
              (("1" (expand buildRedex obj)
                (("1" (expand buildRedexType obj)
                  (("1" (assert) (("1" (grind) nil nil)) nil)) nil))
                nil)
               ("2" (expand buildRedex obj)
                (("2" (expand buildRedexType obj)
                  (("2" (assert)
                    (("2" (split obj)
                      (("1" (grind) nil nil)
                       ("2" (expand is_well_typed_ctx obj)
                        (("2" (split obj)
                          (("1" (grind) nil nil)
                           ("2"
                            (typepred
                             "buildRedexType(letexpr1_var, lrhs(tA))")
                            (("2" (replace -1 et :dir RL)
                              (("2" (rewrite fill_type) nil nil)) nil))
                            nil)
                           ("3" (typepred "buildRedex(letexpr1_var)")
                            (("3" (replace -1 iwt2 :dir RL)
                              (("3"
                                (rewrite popdepth_fill)
                                (("3"
                                  (rewrite popn_popn)
                                  (("3" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("6" (grind) nil nil) ("7" (grind) nil nil)
       ("8" (grind) nil nil) ("9" (grind) nil nil)
       ("10" (grind) nil nil)
       ("11" (with-labels (skeep*) ((hrec cp sl hvar iwt obj)))
        (("11" (expand is_well_typed iwt)
          (("11" (with-labels (flatten) ((popta iwt)))
            (("11" (case "value?(pop1_var)")
              (("1" (expand buildRedex obj)
                (("1" (expand buildRedexType obj)
                  (("1" (assert) (("1" (grind) nil nil)) nil)) nil))
                nil)
               ("2" (expand buildRedex obj)
                (("2" (expand buildRedexType obj)
                  (("2" (assert)
                    (("2" (split obj)
                      (("1" (grind) nil nil)
                       ("2" (expand is_well_typed_ctx obj)
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("12" (grind) nil nil) ("13" (grind) nil nil)
       ("14" (delete 2)
        (("14" (skeep)
          (("14" (use buildRedexType_args_correct)
            (("14" (grind) nil nil)) nil))
          nil))
        nil)
       ("15" (delete 2)
        (("15" (skeep)
          (("15" (use buildRedexType_args_correct)
            (("15" (grind) nil nil)) nil))
          nil))
        nil)
       ("16" (delete 2)
        (("16" (skeep)
          (("16" (use buildRedexType_args_correct)
            (("16" (grind) nil nil)) nil))
          nil))
        nil)
       ("17" (delete 2)
        (("17" (skeep)
          (("17" (use buildRedexType_args_correct)
            (("17" (grind) nil nil)) nil))
          nil))
        nil)
       ("18" (delete 2)
        (("18" (skeep)
          (("18" (use buildRedexType_args_correct)
            (("18" (grind) nil nil)) nil))
          nil))
        nil)
       ("19" (delete 2)
        (("19" (skeep)
          (("19" (use buildRedexType_args_correct)
            (("19" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((contextPure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (buildRedex def-decl "{(K, B) | fill(K, B) = A}" IL nil)
    (fill def-decl "IExpression" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (cpure? def-decl "bool" IL nil)
    (buildRedexType def-decl "{(tK, tB) | typeinfo_fill(tK, tB) = tA}"
     typed_reduction nil)
    (typeinfo_fill def-decl "typeinfo" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popDepth def-decl "nat" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (singleton const-decl "(singleton?)" sets nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (emptyset const-decl "set" sets nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (value? const-decl "bool" IL nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (fill_type formula-decl nil typed_reduction nil)
    (popn_popn formula-decl nil typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (popdepth_fill formula-decl nil IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (ptbody adt-accessor-decl "[(popt?) -> typeinfo]" typeinfo_adt nil)
    (buildRedexType_args_correct formula-decl nil typed_reduction nil))
   nil)
  (buildRedexType_correct-1 nil 3701700006
   ("" (simplify :let-reduce? t)
    (("" (induct A)
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (grind) nil nil) ("4" (grind) nil nil)
       ("5" (with-labels (skeep*) ((hrec1 hrec2 cp sl hvar iwt obj)))
        (("5" (expand is_well_typed iwt)
          (("5" (with-labels (flatten) ((letta iwt1 et iwt2)))
            (("5" (case "atom?(letexpr1_var)")
              (("1" (expand buildRedex obj)
                (("1" (expand buildRedexType obj)
                  (("1" (assert) (("1" (grind) nil nil)) nil)) nil))
                nil)
               ("2" (expand buildRedex obj)
                (("2" (expand buildRedexType obj)
                  (("2" (assert)
                    (("2" (split obj)
                      (("1" (grind) nil nil)
                       ("2" (expand is_well_typed_ctx obj)
                        (("2" (split obj)
                          (("1" (grind) nil nil)
                           ("2"
                            (typepred
                             "buildRedexType(letexpr1_var, lrhs(tA))")
                            (("2" (replace -1 et :dir RL)
                              (("2" (rewrite fill_type) nil nil)) nil))
                            nil)
                           ("3" (typepred "buildRedex(letexpr1_var)")
                            (("3" (replace -1 iwt2 :dir RL)
                              (("3"
                                (rewrite popdepth_fill)
                                (("3"
                                  (rewrite popn_popn)
                                  (("3" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("6" (grind) nil nil) ("7" (grind) nil nil)
       ("8" (grind) nil nil) ("9" (grind) nil nil)
       ("10" (grind) nil nil)
       ("11" (with-labels (skeep*) ((hrec cp sl hvar iwt obj)))
        (("11" (expand is_well_typed iwt)
          (("11" (with-labels (flatten) ((popta iwt)))
            (("11" (case "atom?(pop1_var)")
              (("1" (expand buildRedex obj)
                (("1" (expand buildRedexType obj)
                  (("1" (assert) (("1" (grind) nil nil)) nil)) nil))
                nil)
               ("2" (expand buildRedex obj)
                (("2" (expand buildRedexType obj)
                  (("2" (assert)
                    (("2" (split obj)
                      (("1" (grind) nil nil)
                       ("2" (expand is_well_typed_ctx obj)
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("12" (grind) nil nil) ("13" (grind) nil nil)
       ("14" (delete 2)
        (("14" (skeep)
          (("14" (use buildRedexType_args_correct)
            (("14" (grind) nil nil)) nil))
          nil))
        nil)
       ("15" (delete 2)
        (("15" (skeep)
          (("15" (use buildRedexType_args_correct)
            (("15" (grind) nil nil)) nil))
          nil))
        nil)
       ("16" (delete 2)
        (("16" (skeep)
          (("16" (use buildRedexType_args_correct)
            (("16" (grind) nil nil)) nil))
          nil))
        nil)
       ("17" (delete 2)
        (("17" (skeep)
          (("17" (use buildRedexType_args_correct)
            (("17" (grind) nil nil)) nil))
          nil))
        nil)
       ("18" (delete 2)
        (("18" (skeep)
          (("18" (use buildRedexType_args_correct)
            (("18" (grind) nil nil)) nil))
          nil))
        nil)
       ("19" (delete 2)
        (("19" (skeep)
          (("19" (use buildRedexType_args_correct)
            (("19" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (buildRedex def-decl "{(K, B) | fill(K, B) = A}" IL nil)
    (fill def-decl "IExpression" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (cpure? def-decl "bool" IL nil)
    (buildRedexType def-decl "{(tK, tB) | typeinfo_fill(tK, tB) = tA}"
     typed_reduction nil)
    (typeinfo_fill def-decl "typeinfo" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (singleton const-decl "(singleton?)" sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (emptyset const-decl "set" sets nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (atom? const-decl "bool" IL nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (value? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (fill_type formula-decl nil typed_reduction nil)
    (popn_popn formula-decl nil typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (popdepth_fill formula-decl nil IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (ptbody adt-accessor-decl "[(popt?) -> typeinfo]" typeinfo_adt nil)
    (buildRedexType_args_correct formula-decl nil typed_reduction nil))
   shostak))
 (make_redex_typed_TCC1 0
  (make_redex_typed_TCC1-1 nil 3701707876 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (make_redex_typed subtype "typed_reduction.tS`state"
    "{t: reduction.topstate | }")))
 (make_redex_typed_TCC2 0
  (make_redex_typed_TCC2-1 nil 3701707876
   ("" (skeep)
    (("" (typepred "tS`dom_types")
      (("" (skeep*)
        (("" (inst?)
          (("1" (inst -1 j)
            (("1" (grind) nil nil)
             ("2" (typepred j) (("2" (grind) nil nil)) nil))
            nil)
           ("2" (typepred r) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (r skolem-const-decl "(make_redex_e(tS`state)`domain)"
     typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureRedex? const-decl "bool" IL nil)
    (topstate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil)
    (tS skolem-const-decl
     "{tS | tS`state`context = hole AND NOT value?(tS`state`redex)}"
     typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (j skolem-const-decl
     "below(make_redex_e(tS`state)`store(r)`length)" typed_reduction
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (make_redex_typed subtype "typed_reduction.tS`dom_types"
    "{dom_types | FORALL (r: (reduction.make_redex_e(typed_reduction.tS`state)`domain)): FORALL (j: naturalnumbers.below(reduction.make_redex_e(typed_reduction.tS`state)`store(r)`length)): typed_reduction.value_of_type(reduction.make_redex_e(typed_reduction.tS`state)`store(r)`seq(j), typed_reduction.dom_types(r), typed_reduction.dom_types)}")))
 (make_redex_typed_TCC3 0
  (make_redex_typed_TCC3-1 nil 3701707876
   ("" (skeep* :preds? t)
    (("" (expand make_redex_e)
      (("" (typepred "tS`stack_types") (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (make_redex_typed subtype "typed_reduction.tS`stack_types"
    "{stypes | booleans.AND(typed_reduction.stypes`length = reduction.make_redex_e(typed_reduction.tS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_reduction.stypes`length)): typed_reduction.value_of_type(reduction.make_redex_e(typed_reduction.tS`state)`stack`seq(i), typed_reduction.stypes`seq(i), typed_reduction.tS`dom_types))}")))
 (make_redex_typed_TCC4 0
  (make_redex_typed_TCC4-1 nil 3701707876
   ("" (skeep* :preds? t)
    (("" (expand make_redex_e)
      (("" (lemma buildRedexType_correct)
        (("" (simplify :let-reduce? t)
          ((""
            (inst -1 "tS`state`redex" "tS`def_types" "tS`dom_types"
             "tS`stack_types" "tS`redex_type")
            (("" (split -1)
              (("1" (assert) nil nil)
               ("2" (typepred "tS`state`redex")
                (("2" (propax) nil nil)) nil)
               ("3" (typepred "tS`state`redex")
                (("3" (typepred "tS`stack_types")
                  (("3" (grind) nil nil)) nil))
                nil)
               ("4" (typepred "tS`stack_types")
                (("4"
                  (with-labels (typepred "tS`state`redex")
                   ((href hvar hcvar hsl hcp)))
                  (("4" (skeep)
                    (("4" (inst hvar "i-popDepth(tS`state`redex)")
                      (("1" (rewrite cvars_vars)
                        (("1" (grind) nil nil)) nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("5" (typepred "tS`redex_type") (("5" (propax) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (i skolem-const-decl "nat" typed_reduction nil)
    (tS skolem-const-decl
     "{tS | tS`state`context = hole AND NOT value?(tS`state`redex)}"
     typed_reduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cvars_vars formula-decl nil preprocess nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (buildRedexType_correct formula-decl nil typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (make_redex_typed subtype "typed_reduction.tA"
    "{tA | typed_reduction.is_well_typed(reduction.make_redex_e(typed_reduction.tS`state)`redex, typed_reduction.tA, typed_reduction.tS`stack_types, typed_reduction.tS`dom_types, typed_reduction.tS`def_types)}")))
 (make_redex_typed_TCC5 0
  (make_redex_typed_TCC5-1 nil 3701707876
   ("" (skeep* :preds? t)
    (("" (expand make_redex_e)
      (("" (lemma buildRedexType_correct)
        (("" (simplify :let-reduce? t)
          ((""
            (inst -1 "tS`state`redex" "tS`def_types" "tS`dom_types"
             "tS`stack_types" "tS`redex_type")
            (("" (split -1)
              (("1" (assert) nil nil)
               ("2" (typepred "tS`state`redex")
                (("2" (propax) nil nil)) nil)
               ("3" (typepred "tS`state`redex")
                (("3" (typepred "tS`stack_types")
                  (("3" (grind) nil nil)) nil))
                nil)
               ("4" (typepred "tS`stack_types")
                (("4"
                  (with-labels (typepred "tS`state`redex")
                   ((href hvar hcvar hsl hcp)))
                  (("4" (skeep)
                    (("4" (inst hvar "i-popDepth(tS`state`redex)")
                      (("1" (rewrite cvars_vars)
                        (("1" (grind) nil nil)) nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("5" (typepred "tS`redex_type") (("5" (propax) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (i skolem-const-decl "nat" typed_reduction nil)
    (tS skolem-const-decl
     "{tS | tS`state`context = hole AND NOT value?(tS`state`redex)}"
     typed_reduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cvars_vars formula-decl nil preprocess nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (buildRedexType_correct formula-decl nil typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (make_redex_typed subtype "typed_reduction.tK"
    "{tK | typed_reduction.is_well_typed_ctx(reduction.make_redex_e(typed_reduction.tS`state)`context, typed_reduction.tK, typed_reduction.popn(typed_reduction.tS`stack_types, IL.popDepth(reduction.make_redex_e(typed_reduction.tS`state)`redex)), typed_reduction.tS`dom_types, typed_reduction.tS`def_types, typed_reduction.expr_type(typed_reduction.tA))}")))
 (defs_well_typed_TCC1 0
  (defs_well_typed_TCC1-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (defs_well_typed subtype "typed_reduction.i"
    "below[def_types`length]")))
 (defs_well_typed_TCC2 0
  (defs_well_typed_TCC2-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (typepred "D`seq(i)`body")
      (("" (use pure_contextPure) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pure_contextPure formula-decl nil IL nil))
   nil
   (defs_well_typed subtype
    "typed_reduction.D`seq(typed_reduction.i)`body"
    "(IL.contextPure?)")))
 (defs_well_typed_TCC3 0
  (defs_well_typed_TCC3-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth) (("1" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (typepred "D`seq(i)`body")
          (("2" (rewrite cvars_pure)
            (("2" (assert) (("2" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cvars_pure formula-decl nil preprocess nil))
   nil
   (defs_well_typed subtype
    "typed_reduction.def_types`seq(typed_reduction.i)`args_type"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_reduction.D`seq(typed_reduction.i)`body), typed_reduction.stypes`length), FORALL (i_1: naturalnumbers.nat): booleans.IMPLIES(preprocess.cvars(typed_reduction.D`seq(typed_reduction.i)`body)(i_1), reals.<(i_1, typed_reduction.stypes`length)))}")))
 (set_new_type_TCC1 0
  (set_new_type_TCC1-1 nil 3702647357
   ("" (skeep* :preds? t)
    (("" (lift-if)
      (("" (split)
        (("1" (flatten) (("1" (grind) nil nil)) nil)
         ("2" (flatten)
          (("2" (typepred "tS`dom_types")
            (("2" (inst -1 r j)
              (("2" (expand value_of_type)
                (("2" (lift-if)
                  (("2" (ground)
                    (("2" (typepred "tS`state`store(r)`seq(j)")
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((domainValue? const-decl "bool" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil))
   nil
   (set_new_type subtype
    "typed_reduction.tS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.tS`state`domain)) := typed_reduction.i]"
    "{dom_types | FORALL (r: (typed_reduction.tS`state`domain)): FORALL (j: naturalnumbers.below(typed_reduction.tS`state`store(r)`length)): typed_reduction.value_of_type(typed_reduction.tS`state`store(r)`seq(j), typed_reduction.dom_types(r), typed_reduction.dom_types)}")))
 (set_new_type_TCC2 0
  (set_new_type_TCC2-1 nil 3702647357
   ("" (skeep* :preds? t)
    (("" (typepred "tS`stack_types")
      (("" (split)
        (("1" (propax) nil nil)
         ("2" (skeep :preds? t)
          (("2" (inst?)
            (("2" (expand value_of_type)
              (("2" (ground)
                (("2" (lift-if)
                  (("2" (ground)
                    (("2" (typepred "tS`state`stack")
                      (("2" (grind)
                        (("2" (typepred "tS`state`stack`seq(i_1)")
                          (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (set_new_type subtype "typed_reduction.tS`stack_types"
    "{stypes | booleans.AND(typed_reduction.stypes`length = typed_reduction.tS`state`stack`length, FORALL (i_1: naturalnumbers.below(typed_reduction.stypes`length)): typed_reduction.value_of_type(typed_reduction.tS`state`stack`seq(i_1), typed_reduction.stypes`seq(i_1), typed_reduction.tS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.tS`state`domain)) := typed_reduction.i]))}")))
 (set_new_type_TCC3 0
  (set_new_type_TCC3-1 nil 3702647357
   ("" (lemma is_well_typed_dom)
    (("" (skeep)
      (("" (inst?)
        (("" (inst -1 "tS`dom_types")
          (("" (split -1)
            (("1" (typepred "tS`redex_type") (("1" (assert) nil nil))
              nil)
             ("2" (typepred "tS`state`redex") (("2" (propax) nil nil))
              nil)
             ("3" (typepred "tS`state`redex")
              (("3" (skeep)
                (("3" (inst -1 i_1) (("3" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (is_well_typed_dom formula-decl nil typed_reduction nil))
   nil
   (set_new_type subtype "typed_reduction.tS`redex_type"
    "{tA | typed_reduction.is_well_typed(typed_reduction.tS`state`redex, typed_reduction.tA, typed_reduction.tS`stack_types, typed_reduction.tS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.tS`state`domain)) := typed_reduction.i], typed_reduction.tS`def_types)}")))
 (set_new_type_TCC4 0
  (set_new_type_TCC4-1 nil 3702647357
   ("" (skeep)
    (("" (lemma is_well_typed_ctx_dom)
      (("" (inst?)
        (("" (inst -1 "tS`dom_types")
          (("" (split -1)
            (("1" (typepred "tS`context_type") (("1" (assert) nil nil))
              nil)
             ("2" (typepred "tS`state`context")
              (("2" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((is_well_typed_ctx_dom formula-decl nil typed_reduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IContext type-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (set_new_type subtype "typed_reduction.tS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(typed_reduction.tS`state`context, typed_reduction.tK, typed_reduction.popn(typed_reduction.tS`stack_types, IL.popDepth(typed_reduction.tS`state`redex)), typed_reduction.tS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.tS`state`domain)) := typed_reduction.i], typed_reduction.tS`def_types, typed_reduction.expr_type(typed_reduction.tS`redex_type))}")))
 (typed_reduce_TCC1 0
  (typed_reduce_TCC1-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.t"
    "{tS | booleans.AND(typed_reduction.tS`state`context = IL.hole, )}")))
 (typed_reduce_TCC2 0
  (typed_reduce_TCC2-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`state"
    "{gS | IExpression_adt.variable?(reduction.gS`redex)}")))
 (typed_reduce_TCC3 0
  (typed_reduce_TCC3-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (typepred "nS`dom_types")
      (("" (expand letReduce) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (goodstate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil)
    (Defs type-eq-decl nil reduction nil)
    (Definition type-eq-decl nil reduction nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (pure? def-decl "bool" IL nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (variableReduce const-decl "estate" reduction nil)
    (get const-decl "(value?)" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`dom_types"
    "{dom_types | FORALL (r: (reduction.variableReduce(typed_reduction.D)(typed_reduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(reduction.variableReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(reduction.variableReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`seq(j), typed_reduction.dom_types(r), typed_reduction.dom_types)}")))
 (typed_reduce_TCC4 0
  (typed_reduce_TCC4-2 "" 3720741975
   ("" (skeep* :preds? t)
    (("" (expand variableReduce)
      (("" (typepred "nS`stack_types")
        (("" (split) (("1" (propax) nil nil) ("2" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak
   (typed_reduce subtype "typed_reduction.nS`stack_types"
    "{stypes | booleans.AND(typed_reduction.stypes`length = reduction.variableReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_reduction.stypes`length)): typed_reduction.value_of_type(reduction.variableReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`seq(i), typed_reduction.stypes`seq(i), typed_reduction.nS`dom_types))}"))
  (typed_reduce_TCC4-1 nil 3705853738
   ("" (skeep* :preds? t)
    (("" (expand variableReduce)
      (("" (typepred "nS`stack_types")
        (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((variableReduce const-decl "estate" reduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`stack_types"
    "{stypes | booleans.AND(typed_reduction.stypes`length = reduction.variableReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_reduction.stypes`length)): typed_reduction.value_of_type(reduction.variableReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`seq(i), typed_reduction.stypes`seq(i), typed_reduction.nS`dom_types))}")))
 (typed_reduce_TCC5 0
  (typed_reduce_TCC5-1 nil 3705853738
   ("" (skeep* :preds? t)
    (("" (expand variableReduce)
      (("" (typepred "nS`redex_type")
        (("" (typepred "nS`stack_types")
          ((""
            (inst -2
             "nS`state`stack`length -1 - index(nS`state`redex)")
            (("1" (typepred "get(nS`state`stack)(nS`state`redex)")
              (("1" (rewrite value_well_typed +)
                (("1" (split)
                  (("1" (assert)
                    (("1" (expand is_well_typed)
                      (("1" (propax) nil nil)) nil))
                    nil)
                   ("2" (assert)
                    (("2" (expand is_well_typed)
                      (("2" (flatten) (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2"
              (case "index(nS`state`redex) < nS`state`stack`length")
              (("1" (grind) nil nil)
               ("2" (typepred "nS`state`redex")
                (("2" (inst -2 "index(nS`state`redex)")
                  (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((variableReduce const-decl "estate" reduction nil)
    (singleton const-decl "(singleton?)" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[T]" countability "sets_aux/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (get const-decl "(value?)" IL nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (value_well_typed formula-decl nil typed_reduction nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (nS skolem-const-decl "typed_state" typed_reduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`redex_type"
    "{tA | typed_reduction.is_well_typed(reduction.variableReduce(typed_reduction.D)(typed_reduction.nS`state)`redex, typed_reduction.tA, typed_reduction.nS`stack_types, typed_reduction.nS`dom_types, typed_reduction.nS`def_types)}")))
 (typed_reduce_TCC6 0
  (typed_reduce_TCC6-1 nil 3705853738
   ("" (skeep* :preds? t)
    (("" (expand variableReduce)
      ((""
        (case-replace "popDepth(get
                                      (nS`state`stack)(nS`state`redex)) = 0")
        (("1" (assert)
          (("1" (typepred "nS`context_type")
            (("1" (case-replace "popDepth(nS`state`redex) = 0")
              (("1" (assert) nil nil) ("2" (grind) nil nil)) nil))
            nil))
          nil)
         ("2" (typepred "get(nS`state`stack)(nS`state`redex)")
          (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((variableReduce const-decl "estate" reduction nil)
    (tS skolem-const-decl
     "{tS | NOT tS`state`error AND defs_well_typed(D, tS`def_types)}"
     typed_reduction nil)
    (D skolem-const-decl "Defs" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (pure? def-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (get const-decl "(value?)" IL nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (< const-decl "bool" reals nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (popDepth def-decl "nat" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(reduction.variableReduce(typed_reduction.D)(typed_reduction.nS`state)`context, typed_reduction.tK, typed_reduction.popn(typed_reduction.nS`stack_types, IL.popDepth(reduction.variableReduce(typed_reduction.D)(typed_reduction.nS`state)`redex)), typed_reduction.nS`dom_types, typed_reduction.nS`def_types, typed_reduction.expr_type(typed_reduction.nS`redex_type))}")))
 (typed_reduce_TCC7 0
  (typed_reduce_TCC7-1 nil 3705853738 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`state"
    "{gS | IL.pureLetRedex?(reduction.gS`redex)}")))
 (typed_reduce_TCC8 0
  (typed_reduce_TCC8-2 "" 3720741999
   ("" (skeep* :preds? t)
    (("" (expand letReduce)
      (("" (typepred "nS`dom_types")
        (("" (inst?) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   nil shostak
   (typed_reduce subtype "typed_reduction.nS`dom_types"
    "{dom_types | FORALL (r: (reduction.letReduce(typed_reduction.D)(typed_reduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(reduction.letReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(reduction.letReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`seq(j), typed_reduction.dom_types(r), typed_reduction.dom_types)}"))
  (typed_reduce_TCC8-1 nil 3705853738
   ("" (skeep* :preds? t)
    (("" (expand letReduce)
      (("" (typepred "nS`dom_types") (("" (inst?) nil nil)) nil)) nil))
    nil)
   ((letReduce const-decl "estate" reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Store type-eq-decl nil reduction nil)
    (goodstate type-eq-decl nil reduction nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (j skolem-const-decl
     "below(letReduce(D)(nS`state)`store(r)`length)" typed_reduction
     nil)
    (r skolem-const-decl "(letReduce(D)(nS`state)`domain)"
     typed_reduction nil)
    (nS skolem-const-decl "typed_state" typed_reduction nil)
    (D skolem-const-decl "Defs" typed_reduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`dom_types"
    "{dom_types | FORALL (r: (reduction.letReduce(typed_reduction.D)(typed_reduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(reduction.letReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(reduction.letReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`seq(j), typed_reduction.dom_types(r), typed_reduction.dom_types)}")))
 (typed_reduce_TCC9 0
  (typed_reduce_TCC9-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type")
      (("" (apply-eta "nS`state`redex" "(letexpr?)")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nS skolem-const-decl "typed_state" typed_reduction nil)
    (IExpression_letexpr_eta formula-decl nil IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`redex_type"
    "(typeinfo_adt.lett?)")))
 (typed_reduce_TCC10 0
  (typed_reduce_TCC10-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (typepred "nS`stack_types")
        (("1" (expand letReduce) (("1" (grind) nil nil)) nil)) nil)
       ("2" (skeep :preds? t)
        (("2" (with-labels (typepred "nS`stack_types") ((sll slv)))
          (("2" (case-replace "i = nS`stack_types`length")
            (("1" (expand add)
              (("1" (expand letReduce)
                (("1" (replace sll +)
                  (("1" (expand push)
                    (("1" (expand add)
                      (("1" (typepred "nS`redex_type")
                        (("1" (apply-eta "nS`state`redex" "(letexpr?)")
                          (("1" (replace -1 :dir RL)
                            (("1" (simplify)
                              (("1"
                                (expand is_well_typed)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (rewrite value_well_typed)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand add)
              (("2" (lift-if)
                (("2" (assert)
                  (("2" (expand letReduce)
                    (("2" (expand push)
                      (("2" (expand add) (("2" (inst slv i) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((letReduce const-decl "estate" reduction nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (push const-decl "Stack" IL nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (IExpression_letexpr_eta formula-decl nil IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value_well_typed formula-decl nil typed_reduction nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (seq type-eq-decl nil more_finseq nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "more_finseq[naturalnumbers.nat].add(typeinfo_adt.lettype(typed_reduction.nS`redex_type), typed_reduction.nS`stack_types)"
    "{stypes | booleans.AND(typed_reduction.stypes`length = reduction.letReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_reduction.stypes`length)): typed_reduction.value_of_type(reduction.letReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`seq(i), typed_reduction.stypes`seq(i), typed_reduction.nS`dom_types))}")))
 (typed_reduce_TCC11 0
  (typed_reduce_TCC11-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand letReduce)
      (("" (expand is_well_typed)
        (("" (typepred "nS`redex_type")
          (("" (apply-eta "nS`state`redex" "(letexpr?)")
            (("" (replace -1 :dir RL)
              (("" (assert)
                (("" (expand is_well_typed -)
                  ((""
                    (case-replace
                     "popn(nS`stack_types, popDepth(letrhs(nS`state`redex))) = nS`stack_types")
                    (("1" (assert) nil nil)
                     ("2"
                      (case-replace
                       "popDepth(letrhs(nS`state`redex)) = 0")
                      (("1" (use popn_zero) nil nil)
                       ("2" (expand pureLetRedex?)
                        (("2" (expand letRedex?)
                          (("2" (flatten) (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((letReduce const-decl "estate" reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (letRedex? const-decl "bool" IL nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (fill def-decl "IExpression" IL nil)
    (buildRedex def-decl "{(K, B) | fill(K, B) = A}" IL nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (D skolem-const-decl "Defs" typed_reduction nil)
    (tS skolem-const-decl
     "{tS | NOT tS`state`error AND defs_well_typed(D, tS`def_types)}"
     typed_reduction nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression_letexpr_eta formula-decl nil IExpression_adt nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "typeinfo_adt.popt(typeinfo_adt.lbody(typed_reduction.nS`redex_type))"
    "{tA | typed_reduction.is_well_typed(reduction.letReduce(typed_reduction.D)(typed_reduction.nS`state)`redex, typed_reduction.tA, more_finseq[naturalnumbers.nat].add(typeinfo_adt.lettype(typed_reduction.nS`redex_type), typed_reduction.nS`stack_types), typed_reduction.nS`dom_types, typed_reduction.nS`def_types)}")))
 (typed_reduce_TCC12 0
  (typed_reduce_TCC12-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand letReduce)
      (("" (expand popDepth)
        (("" (rewrite purePopDepth)
          (("1" (assert)
            (("1"
              (case-replace
               "popn(add(lettype(nS`redex_type), nS`stack_types), 1) = nS`stack_types")
              (("1" (typepred "nS`context_type")
                (("1" (case-replace "popDepth(nS`state`redex) = 0")
                  (("1" (expand expr_type +)
                    (("1" (case "lett?(nS`redex_type)")
                      (("1" (grind) nil nil)
                       ("2" (typepred "nS`redex_type")
                        (("2" (apply-eta "nS`state`redex" "(letexpr?)")
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (apply-eta "nS`state`redex" "(letexpr?)")
                    (("1" (case "atom?(letrhs(nS`state`redex))")
                      (("1" (replace -2 :dir RL)
                        (("1" (expand popDepth)
                          (("1" (simplify) (("1" (grind) nil nil))
                            nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (expand add)
                (("2" (expand popn)
                  (("2" (decompose-equality)
                    (("2" (decompose-equality) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((letReduce const-decl "estate" reduction nil)
    (purePopDepth formula-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (body adt-accessor-decl "[(letexpr?) -> IExpression]"
          IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (seq type-eq-decl nil more_finseq nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (IExpression_letexpr_eta formula-decl nil IExpression_adt nil)
    (nS skolem-const-decl "typed_state" typed_reduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (atom? const-decl "bool" IL nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (fill def-decl "IExpression" IL nil)
    (buildRedex def-decl "{(K, B) | fill(K, B) = A}" IL nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (D skolem-const-decl "Defs" typed_reduction nil)
    (tS skolem-const-decl
     "{tS | NOT tS`state`error AND defs_well_typed(D, tS`def_types)}"
     typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (popDepth def-decl "nat" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(reduction.letReduce(typed_reduction.D)(typed_reduction.nS`state)`context, typed_reduction.tK, typed_reduction.popn(more_finseq[naturalnumbers.nat].add(typeinfo_adt.lettype(typed_reduction.nS`redex_type), typed_reduction.nS`stack_types), IL.popDepth(reduction.letReduce(typed_reduction.D)(typed_reduction.nS`state)`redex)), typed_reduction.nS`dom_types, typed_reduction.nS`def_types, typed_reduction.expr_type(typeinfo_adt.popt(typeinfo_adt.lbody(typed_reduction.nS`redex_type))))}")))
 (typed_reduce_TCC13 0
  (typed_reduce_TCC13-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`state"
    "{gS | IL.applyRedex?(reduction.gS`redex)}")))
 (typed_reduce_TCC14 0
  (typed_reduce_TCC14-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand applyReduce)
      (("" (assert)
        (("" (typepred "nS`dom_types") (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((applyReduce const-decl "estate" reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Store type-eq-decl nil reduction nil)
    (goodstate type-eq-decl nil reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`dom_types"
    "{dom_types | FORALL (r: (reduction.applyReduce(typed_reduction.D)(typed_reduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(reduction.applyReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(reduction.applyReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`seq(j), typed_reduction.dom_types(r), typed_reduction.dom_types)}")))
 (typed_reduce_TCC15 0
  (typed_reduce_TCC15-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand applyReduce)
      (("" (assert)
        (("" (typepred "nS`stack_types") (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((applyReduce const-decl "estate" reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`stack_types"
    "{stypes | booleans.AND(typed_reduction.stypes`length = reduction.applyReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_reduction.stypes`length)): typed_reduction.value_of_type(reduction.applyReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`seq(i), typed_reduction.stypes`seq(i), typed_reduction.nS`dom_types))}")))
 (typed_reduce_TCC16 0
  (typed_reduce_TCC16-2 "" 3720742182 ("" (grind) nil nil) nil shostak
   (typed_reduce subtype "typed_reduction.nS`state`redex"
    "(IExpression_adt.application?)"))
  (typed_reduce_TCC16-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand applyReduce)
      (("" (case "fun(nS`state`redex) < D`length")
        (("1" (assert)
          (("1"
            (case "length(args(nS`state`redex)) = D`seq(fun(nS`state`redex))`arity")
            (("1" (assert) (("1" (postpone) nil nil)) nil)
             ("2" (assert) nil nil))
            nil))
          nil)
         ("2" (assert) nil nil) ("3" (grind) nil nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`state`redex"
    "(IExpression_adt.application?)")))
 (typed_reduce_TCC17 0
  (typed_reduce_TCC17-1 nil 3705867947
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil)) nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "IExpression_adt.fun(typed_reduction.nS`state`redex)"
    "below[tS`def_types`length]")))
 (typed_reduce_TCC18 0
  (typed_reduce_TCC18-1 nil 3705867947
   ("" (skeep* :preds? t) (("" (rewrite finseq2list_length) nil nil))
    nil)
   ((finseq2list_length formula-decl nil list2finseq nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "list2finseq[naturalnumbers.nat].finseq2list(typed_reduction.tS`def_types`seq(IExpression_adt.fun(typed_reduction.nS`state`redex))`args_type)"
    "{args_type_1: list_adt[naturalnumbers.nat].list | list_props[naturalnumbers.nat].length(args_type_1) = length(typed_reduction.tS`def_types`seq(IExpression_adt.fun(typed_reduction.nS`state`redex))`args_type)}")))
 (typed_reduce_TCC19 0
  (typed_reduce_TCC19-2 "" 3720742639
   ("" (skeep* :preds? t)
    (("" (expand applyReduce)
      (("" (case "fun(nS`state`redex) < D`length")
        (("1" (assert)
          (("1"
            (case "length(args(nS`state`redex)) = D`seq(fun(nS`state`redex))`arity")
            (("1" (assert)
              (("1" (lemma is_well_typed_letApply)
                (("1" (inst?)
                  (("1" (inst?)
                    (("1" (inst?)
                      (("1" (inst -1 "nS`stack_types" _ _)
                        (("1" (inst?)
                          (("1" (inst?)
                            (("1" (split)
                              (("1"
                                (case-replace
                                 "length
                                              (tS`def_types`seq
                                               (fun(nS`state`redex))`args_type) = D`seq(fun(nS`state`redex))`arity")
                                (("1"
                                  (case-replace
                                   "nS`def_types = tS`def_types")
                                  (("1" (grind) nil nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil)
                               ("2" (grind) nil nil)
                               ("3"
                                (skeep)
                                (("3"
                                  (rewrite cvars_pure -1)
                                  (("3"
                                    (typepred
                                     "D`seq(fun(nS`state`redex))`body")
                                    (("3"
                                      (inst -2 i)
                                      (("3"
                                        (split)
                                        (("1" (assert) nil nil)
                                         ("2" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("4"
                                (skeep)
                                (("4"
                                  (typepred "nS`stack_types")
                                  (("4"
                                    (rewrite -1)
                                    (("4"
                                      (typepred "nS`state`redex")
                                      (("4"
                                        (inst -2 i)
                                        (("4" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("5"
                                (skeep)
                                (("5"
                                  (typepred "nS`redex_type")
                                  (("5"
                                    (expand applyRedex?)
                                    (("5"
                                      (assert)
                                      (("5"
                                        (expand is_well_typed -)
                                        (("5"
                                          (flatten)
                                          (("5"
                                            (inst?)
                                            (("5"
                                              (rewrite finseq2list_nth)
                                              (("1"
                                                (case-replace
                                                 "tS`def_types = nS`def_types")
                                                (("1" (grind) nil nil)
                                                 ("2"
                                                  (typepred i)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (typepred i)
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("6"
                                (rewrite list2finseq_finseq2list)
                                (("6"
                                  (expand defs_well_typed)
                                  (("6"
                                    (flatten)
                                    (("6"
                                      (inst?)
                                      (("6"
                                        (flatten)
                                        (("6"
                                          (use
                                           is_well_typed_extend_stack)
                                          (("6"
                                            (split)
                                            (("1" (assert) nil nil)
                                             ("2"
                                              (use pure_contextPure)
                                              (("2"
                                                (typepred
                                                 "D`seq(fun(nS`state`redex))`body")
                                                (("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (rewrite finseq2list_length)
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (assert)
              (("2" (typepred "nS`redex_type") (("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (assert)
          (("2" (typepred "nS`redex_type") (("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak
   (typed_reduce subtype
    "typed_reduction.letApply_type(length(typed_reduction.tS`def_types`seq(IExpression_adt.fun(typed_reduction.nS`state`redex))`args_type), list2finseq[naturalnumbers.nat].finseq2list(typed_reduction.tS`def_types`seq(IExpression_adt.fun(typed_reduction.nS`state`redex))`args_type), typed_reduction.tS`def_types`seq(IExpression_adt.fun(typed_reduction.nS`state`redex))`body_type)"
    "{tA | typed_reduction.is_well_typed(reduction.applyReduce(typed_reduction.D)(typed_reduction.nS`state)`redex, typed_reduction.tA, typed_reduction.nS`stack_types, typed_reduction.nS`dom_types, typed_reduction.nS`def_types)}"))
  (typed_reduce_TCC19-1 nil 3705867947
   ("" (skeep* :preds? t)
    (("" (expand applyReduce)
      (("" (case "fun(nS`state`redex) < D`length")
        (("1" (assert)
          (("1"
            (case "length(args(nS`state`redex)) = D`seq(fun(nS`state`redex))`arity")
            (("1" (assert)
              (("1" (lemma is_well_typed_letApply)
                (("1" (inst?)
                  (("1" (inst?)
                    (("1" (inst?)
                      (("1" (inst -1 "nS`stack_types" _ _)
                        (("1" (inst?)
                          (("1" (inst?)
                            (("1" (split)
                              (("1"
                                (case-replace
                                 "length
                                    (tS`def_types`seq
                                     (fun(nS`state`redex))`args_type) = D`seq(fun(nS`state`redex))`arity")
                                (("1"
                                  (case-replace
                                   "nS`def_types = tS`def_types")
                                  (("1" (grind) nil nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil)
                               ("2" (grind) nil nil)
                               ("3"
                                (skeep)
                                (("3"
                                  (rewrite cvars_pure -1)
                                  (("3"
                                    (typepred
                                     "D`seq(fun(nS`state`redex))`body")
                                    (("3"
                                      (inst -2 i)
                                      (("3"
                                        (split)
                                        (("1" (assert) nil nil)
                                         ("2" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("4"
                                (skeep)
                                (("4"
                                  (typepred "nS`stack_types")
                                  (("4"
                                    (rewrite -1)
                                    (("4"
                                      (typepred "nS`state`redex")
                                      (("4"
                                        (inst -2 i)
                                        (("4" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("5"
                                (skeep)
                                (("5"
                                  (typepred "nS`redex_type")
                                  (("5"
                                    (expand applyRedex?)
                                    (("5"
                                      (assert)
                                      (("5"
                                        (expand is_well_typed -)
                                        (("5"
                                          (flatten)
                                          (("5"
                                            (inst?)
                                            (("5"
                                              (rewrite finseq2list_nth)
                                              (("1"
                                                (case-replace
                                                 "tS`def_types = nS`def_types")
                                                (("1" (grind) nil nil))
                                                nil)
                                               ("2"
                                                (typepred i)
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("6"
                                (rewrite list2finseq_finseq2list)
                                (("6"
                                  (expand defs_well_typed)
                                  (("6"
                                    (flatten)
                                    (("6"
                                      (inst?)
                                      (("6"
                                        (flatten)
                                        (("6"
                                          (use
                                           is_well_typed_extend_stack)
                                          (("6"
                                            (split)
                                            (("1" (assert) nil nil)
                                             ("2"
                                              (use pure_contextPure)
                                              (("2"
                                                (typepred
                                                 "D`seq(fun(nS`state`redex))`body")
                                                (("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (rewrite finseq2list_length)
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (assert)
              (("2" (typepred "nS`redex_type") (("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (assert)
          (("2" (typepred "nS`redex_type") (("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((applyReduce const-decl "estate" reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pure_letApply rec-application-judgement "(pure?)" reduction nil)
    (finseq2list_length formula-decl nil list2finseq nil)
    (buildRedex def-decl "{(K, B) | fill(K, B) = A}" IL nil)
    (fill def-decl "IExpression" IL nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (cvars_pure formula-decl nil preprocess nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (finseq2list_nth formula-decl nil list2finseq nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (is_well_typed_extend_stack formula-decl nil typed_reduction nil)
    (pure_contextPure formula-decl nil IL nil)
    (list2finseq_finseq2list formula-decl nil list2finseq nil)
    (nS skolem-const-decl "typed_state" typed_reduction nil)
    (tS skolem-const-decl
     "{tS | NOT tS`state`error AND defs_well_typed(D, tS`def_types)}"
     typed_reduction nil)
    (D skolem-const-decl "Defs" typed_reduction nil)
    (finseq2list const-decl "list[T]" list2finseq nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (is_well_typed_letApply formula-decl nil typed_reduction nil)
    (list type-decl nil list_adt nil)
    (length def-decl "nat" list_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (args adt-accessor-decl "[(application?) -> list[(variable?)]]"
          IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (< const-decl "bool" reals nil)
    (IExpression type-decl nil IExpression_adt nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "typed_reduction.letApply_type(length(typed_reduction.tS`def_types`seq(IExpression_adt.fun(typed_reduction.nS`state`redex))`args_type), list2finseq[naturalnumbers.nat].finseq2list(typed_reduction.tS`def_types`seq(IExpression_adt.fun(typed_reduction.nS`state`redex))`args_type), typed_reduction.tS`def_types`seq(IExpression_adt.fun(typed_reduction.nS`state`redex))`body_type)"
    "{tA | typed_reduction.is_well_typed(reduction.applyReduce(typed_reduction.D)(typed_reduction.nS`state)`redex, typed_reduction.tA, typed_reduction.nS`stack_types, typed_reduction.nS`dom_types, typed_reduction.nS`def_types)}")))
 (typed_reduce_TCC20 0
  (typed_reduce_TCC20-1 nil 3705867947
   ("" (skeep* :preds? t)
    (("" (rewrite letApply_expr_type)
      (("" (expand applyReduce)
        (("" (lift-if)
          (("" (case "fun(nS`state`redex) < D`length")
            (("1"
              (case "length(args(nS`state`redex)) =
                 D`seq(fun(nS`state`redex))`arity")
              (("1" (assert)
                (("1"
                  (case-replace "popDepth(letApply
                                      (D`seq(fun(nS`state`redex))`arity,
                                       args(nS`state`redex),
                                       D`seq(fun(nS`state`redex))`body)) = 0")
                  (("1" (assert)
                    (("1" (typepred "nS`context_type")
                      (("1"
                        (case-replace "expr_type(tS`def_types`seq
                                      (fun(nS`state`redex))`body_type) = expr_type(nS`redex_type)")
                        (("1"
                          (case-replace "popDepth(nS`state`redex) = 0")
                          (("1" (assert) nil nil)
                           ("2" (grind) nil nil))
                          nil)
                         ("2" (typepred "nS`redex_type")
                          (("2" (expand applyRedex?)
                            (("2" (assert)
                              (("2"
                                (expand is_well_typed -1)
                                (("2"
                                  (flatten)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (rewrite popdepth_letApply)
                    (("2" (lift-if 1)
                      (("2" (split)
                        (("1" (flatten)
                          (("1" (rewrite purePopDepth) nil nil)) nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (assert)
                (("2" (typepred "nS`redex_type")
                  (("2" (expand applyRedex?)
                    (("2" (assert) (("2" (grind) nil nil)) nil)) nil))
                  nil))
                nil)
               ("3" (propax) nil nil))
              nil)
             ("2" (assert)
              (("2" (expand applyRedex?)
                (("2" (assert)
                  (("2" (typepred "nS`redex_type")
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("3" (expand applyRedex?) (("3" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((letApply_expr_type formula-decl nil typed_reduction nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (length def-decl "nat" list_props nil)
    (finseq2list const-decl "list[T]" list2finseq nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (args adt-accessor-decl "[(application?) -> list[(variable?)]]"
          IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (letApply def-decl "IExpression" reduction nil)
    (fill def-decl "IExpression" IL nil)
    (buildRedex def-decl "{(K, B) | fill(K, B) = A}" IL nil)
    (D skolem-const-decl "Defs" typed_reduction nil)
    (tS skolem-const-decl
     "{tS | NOT tS`state`error AND defs_well_typed(D, tS`def_types)}"
     typed_reduction nil)
    (nS skolem-const-decl "typed_state" typed_reduction nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (purePopDepth formula-decl nil IL nil)
    (popdepth_letApply formula-decl nil reduction nil)
    (pure_letApply rec-application-judgement "(pure?)" reduction nil)
    (applyReduce const-decl "estate" reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(reduction.applyReduce(typed_reduction.D)(typed_reduction.nS`state)`context, typed_reduction.tK, typed_reduction.popn(typed_reduction.nS`stack_types, IL.popDepth(reduction.applyReduce(typed_reduction.D)(typed_reduction.nS`state)`redex)), typed_reduction.nS`dom_types, typed_reduction.nS`def_types, typed_reduction.expr_type(typed_reduction.letApply_type(length(typed_reduction.tS`def_types`seq(IExpression_adt.fun(typed_reduction.nS`state`redex))`args_type), list2finseq[naturalnumbers.nat].finseq2list(typed_reduction.tS`def_types`seq(IExpression_adt.fun(typed_reduction.nS`state`redex))`args_type), typed_reduction.tS`def_types`seq(IExpression_adt.fun(typed_reduction.nS`state`redex))`body_type)))}")))
 (typed_reduce_TCC21 0
  (typed_reduce_TCC18-1 nil 3701716715 ("" (grind) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`state"
    "{gS | IL.pureIftRedex?(reduction.gS`redex)}")))
 (typed_reduce_TCC22 0
  (typed_reduce_TCC19-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (case-replace "reduce(D)(tS`state) = ifReduce(D)(nS`state)")
      (("1" (typepred "nS`dom_types") (("1" (grind) nil nil)) nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (reduce const-decl "estate" reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (ifReduce const-decl "estate" reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (to_topstate const-decl "topstate" reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (get const-decl "(value?)" IL nil)
    (variableReduce const-decl "estate" reduction nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (push const-decl "Stack" IL nil)
    (letReduce const-decl "estate" reduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (applyReduce const-decl "estate" reduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (updateReduce const-decl "estate" reduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (lookupReduce const-decl "estate" reduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (newintReduce const-decl "estate" reduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newrefReduce const-decl "estate" reduction nil)
    (popRedex? const-decl "bool" IL nil)
    (pop const-decl "Stack" IL nil)
    (popReduce const-decl "estate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (D skolem-const-decl "Defs" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`dom_types"
    "{dom_types | FORALL (r: (reduction.ifReduce(typed_reduction.D)(typed_reduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(reduction.ifReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(reduction.ifReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`seq(j), typed_reduction.dom_types(r), typed_reduction.dom_types)}")))
 (typed_reduce_TCC23 0
  (typed_reduce_TCC20-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand ifReduce)
      (("" (typepred "nS`stack_types") (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((ifReduce const-decl "estate" reduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`stack_types"
    "{stypes | booleans.AND(typed_reduction.stypes`length = reduction.ifReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_reduction.stypes`length)): typed_reduction.value_of_type(reduction.ifReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`seq(i), typed_reduction.stypes`seq(i), typed_reduction.nS`dom_types))}")))
 (typed_reduce_TCC24 0
  (typed_reduce_TCC21-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`state`redex"
    "(IExpression_adt.ift?)")))
 (typed_reduce_TCC25 0
  (typed_reduce_TCC22-1 nil 3701716715
   ("" (skeep* :preds? t)
    ((""
      (with-labels (typepred "nS`state`redex")
       ((href hvar hcvar hsl hcp)))
      (("" (inst hvar "index(condition(nS`state`redex))")
        (("" (split hvar)
          (("1" (grind) nil nil)
           ("2" (apply-eta "nS`state`redex" "(ift?)")
            (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (popDepth def-decl "nat" IL nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (add const-decl "(nonempty?)" sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (IExpression_ift_eta formula-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "IExpression_adt.condition(typed_reduction.nS`state`redex)"
    "{x | reals.<(IExpression_adt.index(IL.x), typed_reduction.nS`state`stack`length)}")))
 (typed_reduce_TCC26 0
  (typed_reduce_TCC23-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (apply-eta "nS`state`redex" "(ift?)")
      (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((IExpression_ift_eta formula-decl nil IExpression_adt nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (get const-decl "(value?)" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`redex_type"
    "(typeinfo_adt.iftt?)")))
 (typed_reduce_TCC27 0
  (typed_reduce_TCC24-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (apply-eta "nS`state`redex" "(ift?)")
      (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((IExpression_ift_eta formula-decl nil IExpression_adt nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (get const-decl "(value?)" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`redex_type"
    "(typeinfo_adt.iftt?)")))
 (typed_reduce_TCC28 0
  (typed_reduce_TCC25-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand ifReduce)
      (("" (lift-if)
        (("" (typepred "nS`redex_type")
          (("" (apply-eta "nS`state`redex" "(ift?)")
            (("1" (replace -1 :dir RL)
              (("1" (simplify)
                (("1" (expand is_well_typed -) (("1" (grind) nil nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ifReduce const-decl "estate" reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nS skolem-const-decl "typed_state" typed_reduction nil)
    (IExpression_ift_eta formula-decl nil IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "IF IL.get(typed_reduction.nS`state`stack)(IExpression_adt.condition(typed_reduction.nS`state`redex)) = IExpression_adt.constant(0) THEN typeinfo_adt.telse(typed_reduction.nS`redex_type) ELSE typeinfo_adt.tthen(typed_reduction.nS`redex_type) ENDIF"
    "{tA | typed_reduction.is_well_typed(reduction.ifReduce(typed_reduction.D)(typed_reduction.nS`state)`redex, typed_reduction.tA, typed_reduction.nS`stack_types, typed_reduction.nS`dom_types, typed_reduction.nS`def_types)}")))
 (typed_reduce_TCC29 0
  (typed_reduce_TCC26-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand ifReduce)
      (("" (assert)
        (("" (typepred "nS`redex_type")
          (("" (typepred "nS`context_type")
            (("" (apply-eta "nS`state`redex" "(ift?)")
              (("1" (replace -1 :dir RL)
                (("1" (simplify)
                  (("1" (expand is_well_typed -)
                    (("1"
                      (case-replace
                       "expr_type(nS`redex_type) = expr_type(tthen(nS`redex_type))")
                      (("1" (expand popDepth -)
                        (("1"
                          (case-replace
                           "popDepth(elseexpr(nS`state`redex)) = 0")
                          (("1"
                            (case-replace
                             "popDepth(thenexpr(nS`state`redex)) = 0")
                            (("1" (assert) (("1" (grind) nil nil)) nil)
                             ("2" (use purePopDepth)
                              (("2" (grind) nil nil)) nil))
                            nil)
                           ("2" (use purePopDepth)
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ifReduce const-decl "estate" reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression_ift_eta formula-decl nil IExpression_adt nil)
    (nS skolem-const-decl "typed_state" typed_reduction nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (tthen adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (iftt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (get const-decl "(value?)" IL nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(reduction.ifReduce(typed_reduction.D)(typed_reduction.nS`state)`context, typed_reduction.tK, typed_reduction.popn(typed_reduction.nS`stack_types, IL.popDepth(reduction.ifReduce(typed_reduction.D)(typed_reduction.nS`state)`redex)), typed_reduction.nS`dom_types, typed_reduction.nS`def_types, IF IL.get(typed_reduction.nS`state`stack)(IExpression_adt.condition(typed_reduction.nS`state`redex)) = IExpression_adt.constant(0) THEN typed_reduction.expr_type(typeinfo_adt.telse(typed_reduction.nS`redex_type)) ELSE typed_reduction.expr_type(typeinfo_adt.tthen(typed_reduction.nS`redex_type)) ENDIF)}")))
 (typed_reduce_TCC30 0
  (typed_reduce_TCC27-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`state"
    "{gS | IL.updateRedex?(reduction.gS`redex)}")))
 (typed_reduce_TCC31 0
  (typed_reduce_TCC28-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type")
      (("" (expand updateRedex?) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (updateRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`redex_type"
    "(typeinfo_adt.leaft?)")))
 (typed_reduce_TCC32 0
  (typed_reduce_TCC29-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil)) nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "(number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)"
    "nat")))
 (typed_reduce_TCC33 0
  (typed_reduce_TCC33-1 "" 3720742972
   (""
    (with-labels (skeep* :preds? t)
     ((tsr defswt natom ttop upr ifr apr letr vvar nst obj)))
    (("" (split obj)
      (("1" (typepred "nS`redex_type") (("1" (grind) nil nil)) nil)
       ("2" (with-labels (skeep* obj :preds? t) ((jl rdom obj)))
        (("2"
          (name-replace "nS2"
           "set_new_type(nS, leaftype(nS`redex_type) - 1)")
          (("1"
            (case-replace
             "nS`dom_types                      WITH [(least_out(nS`state`domain))                              |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
            (("1" (case-replace "nS`state = nS2`state")
              (("1" (expand updateReduce)
                (("1" (split rdom)
                  (("1" (flatten rdom)
                    (("1" (assert)
                      (("1" (lift-if)
                        (("1" (split obj)
                          (("1" (flatten)
                            (("1" (replace -1)
                              (("1"
                                (case-replace
                                 "nS2`dom_types(least_out(nS2`state`domain)) = leaftype(nS`redex_type) - 1")
                                (("1"
                                  (case-replace
                                   "nS`redex_type = nS2`redex_type")
                                  (("1"
                                    (typepred "nS2`dom_types")
                                    (("1"
                                      (inst
                                       -1
                                       "refindex(get(nS2`state`stack)(target(nS2`state`redex)))"
                                       j)
                                      (("1"
                                        (simplify)
                                        (("1"
                                          (lift-if)
                                          (("1"
                                            (split obj)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (replace -1)
                                                (("1"
                                                  (typepred
                                                   "nS2`redex_type")
                                                  (("1"
                                                    (case
                                                     "update?(nS2`state`redex)")
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (expand
                                                         is_well_typed
                                                         -2)
                                                        (("1"
                                                          (flatten)
                                                          (("1"
                                                            (expand
                                                             is_well_typed
                                                             -5)
                                                            (("1"
                                                              (typepred
                                                               "nS2`stack_types")
                                                              (("1"
                                                                (expand
                                                                 get)
                                                                (("1"
                                                                  (inst
                                                                   -2
                                                                   "nS2`state`stack`length - 1 - index(rhs(nS2`state`redex))")
                                                                  (("1"
                                                                    (grind)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (typepred
                                                                     "nS2`state`redex")
                                                                    (("2"
                                                                      (inst
                                                                       -2
                                                                       "index(rhs(nS2`state`redex))")
                                                                      (("2"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (typepred
                                                 "nS2`redex_type")
                                                (("2"
                                                  (case
                                                   "update?(nS2`state`redex)")
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (expand
                                                       is_well_typed
                                                       -2)
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (expand
                                                           is_well_typed
                                                           -3)
                                                          (("1"
                                                            (case
                                                             "value_of_type(get(nS2`state`stack)(target(nS2`state`redex)), leaftype(nS2`redex_type), nS2`dom_types)")
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil)
                                                             ("2"
                                                              (typepred
                                                               "nS2`stack_types")
                                                              (("2"
                                                                (expand
                                                                 get)
                                                                (("2"
                                                                  (inst?)
                                                                  (("1"
                                                                    (grind)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (typepred
                                                                     "nS2`state`redex")
                                                                    (("2"
                                                                      (inst
                                                                       -2
                                                                       "index(target(nS2`state`redex))")
                                                                      (("2"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil)
                                 ("2"
                                  (expand nS2)
                                  (("2"
                                    (expand set_new_type)
                                    (("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (typepred "nS2`dom_types")
                            (("2" (flatten)
                              (("2" (inst -1 r j) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten rdom)
                    (("2" (assert)
                      (("2" (typepred "nS2`dom_types")
                        (("2" (inst -1 r j)
                          (("2" (assert) (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand nS2)
                (("2" (expand set_new_type) (("2" (propax) nil nil))
                  nil))
                nil))
              nil)
             ("2" (expand nS2)
              (("2" (expand set_new_type) (("2" (propax) nil nil))
                nil))
              nil))
            nil)
           ("2" (typepred "nS`redex_type") (("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak
   (typed_reduce subtype
    "typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)]"
    "{dom_types | FORALL (r: (reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`seq(j), typed_reduction.dom_types(r), typed_reduction.dom_types)}"))
  (typed_reduce_TCC30-3 nil 3705866912
   (""
    (with-labels (skeep* :preds? t)
     ((tsr defswt natom ttop upr ifr apr letr vvar nst obj)))
    (("" (split obj)
      (("1" (typepred "nS`redex_type") (("1" (grind) nil nil)) nil)
       ("2" (with-labels (skeep* obj :preds? t) ((jl rdom obj)))
        (("2"
          (name-replace "nS2"
           "set_new_type(nS, leaftype(nS`redex_type) - 1)")
          (("1"
            (case-replace
             "nS`dom_types                      WITH [(least_out(nS`state`domain))                              |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
            (("1" (case-replace "nS`state = nS2`state")
              (("1" (expand updateReduce)
                (("1" (split rdom)
                  (("1" (flatten rdom)
                    (("1" (assert)
                      (("1" (lift-if)
                        (("1" (split obj)
                          (("1" (flatten)
                            (("1" (replace -1)
                              (("1"
                                (case-replace
                                 "nS2`dom_types(least_out(nS2`state`domain)) = leaftype(nS`redex_type) - 1")
                                (("1"
                                  (case-replace
                                   "nS`redex_type = nS2`redex_type")
                                  (("1"
                                    (typepred "nS2`dom_types")
                                    (("1"
                                      (inst
                                       -1
                                       "refindex(get(nS2`state`stack)(target(nS2`state`redex)))"
                                       j)
                                      (("1"
                                        (simplify)
                                        (("1"
                                          (lift-if)
                                          (("1"
                                            (split obj)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (replace -1)
                                                (("1"
                                                  (typepred
                                                   "nS2`redex_type")
                                                  (("1"
                                                    (case
                                                     "update?(nS2`state`redex)")
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (expand
                                                         is_well_typed
                                                         -2)
                                                        (("1"
                                                          (flatten)
                                                          (("1"
                                                            (expand
                                                             is_well_typed
                                                             -5)
                                                            (("1"
                                                              (typepred
                                                               "nS2`stack_types")
                                                              (("1"
                                                                (expand
                                                                 get)
                                                                (("1"
                                                                  (inst
                                                                   -2
                                                                   "nS2`state`stack`length - 1 - index(rhs(nS2`state`redex))")
                                                                  (("1"
                                                                    (grind)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (typepred
                                                                     "nS2`state`redex")
                                                                    (("2"
                                                                      (inst
                                                                       -2
                                                                       "index(rhs(nS2`state`redex))")
                                                                      (("2"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (typepred
                                                 "nS2`redex_type")
                                                (("2"
                                                  (case
                                                   "update?(nS2`state`redex)")
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (expand
                                                       is_well_typed
                                                       -2)
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (expand
                                                           is_well_typed
                                                           -3)
                                                          (("1"
                                                            (case
                                                             "value_of_type(get(nS2`state`stack)(target(nS2`state`redex)), leaftype(nS2`redex_type), nS2`dom_types)")
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil)
                                                             ("2"
                                                              (typepred
                                                               "nS2`stack_types")
                                                              (("2"
                                                                (expand
                                                                 get)
                                                                (("2"
                                                                  (inst?)
                                                                  (("1"
                                                                    (grind)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (typepred
                                                                     "nS2`state`redex")
                                                                    (("2"
                                                                      (inst
                                                                       -2
                                                                       "index(target(nS2`state`redex))")
                                                                      (("2"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil)
                                 ("2"
                                  (expand nS2)
                                  (("2"
                                    (expand set_new_type)
                                    (("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (typepred "nS2`dom_types")
                            (("2" (flatten)
                              (("2" (inst -1 r j) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten rdom)
                    (("2" (assert)
                      (("2" (typepred "nS2`dom_types")
                        (("2" (inst -1 r j) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand nS2)
                (("2" (expand set_new_type) (("2" (propax) nil nil))
                  nil))
                nil))
              nil)
             ("2" (expand nS2)
              (("2" (expand set_new_type) (("2" (propax) nil nil))
                nil))
              nil))
            nil)
           ("2" (typepred "nS`redex_type") (("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (typeinfo_fill def-decl "typeinfo" typed_reduction nil)
    (buildRedexType def-decl "{(tK, tB) | typeinfo_fill(tK, tB) = tA}"
     typed_reduction nil)
    (fill def-decl "IExpression" IL nil) (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (D skolem-const-decl "Defs" typed_reduction nil)
    (tS skolem-const-decl
     "{tS | NOT tS`state`error AND defs_well_typed(D, tS`def_types)}"
     typed_reduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (goodstate type-eq-decl nil reduction nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (get const-decl "(value?)" IL nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (nS2 skolem-const-decl "typed_state" typed_reduction nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (add const-decl "(nonempty?)" sets nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (member const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (updateReduce const-decl "estate" reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)]"
    "{dom_types | FORALL (r: (reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`seq(j), typed_reduction.dom_types(r), typed_reduction.dom_types)}"))
  (typed_reduce_TCC30-2 nil 3705866867
   (""
    (with-labels (skeep* :preds? t)
     ((tsr defswt natom ttop upr ifr apr letr nst obj)))
    (("" (split obj)
      (("1" (typepred "nS`redex_type") (("1" (grind) nil)))
       ("2" (with-labels (skeep* obj :preds? t) ((jl rdom obj)))
        (("2"
          (name-replace "nS2"
           "set_new_type(nS, leaftype(nS`redex_type) - 1)")
          (("1"
            (case-replace
             "nS`dom_types                      WITH [(least_out(nS`state`domain))                              |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
            (("1" (case-replace "nS`state = nS2`state")
              (("1" (expand updateReduce)
                (("1" (split rdom)
                  (("1" (flatten rdom)
                    (("1" (assert)
                      (("1" (lift-if)
                        (("1" (split obj)
                          (("1" (flatten)
                            (("1" (replace -1)
                              (("1"
                                (case-replace
                                 "nS2`dom_types(least_out(nS2`state`domain)) = leaftype(nS`redex_type) - 1")
                                (("1"
                                  (case-replace
                                   "nS`redex_type = nS2`redex_type")
                                  (("1"
                                    (typepred "nS2`dom_types")
                                    (("1"
                                      (inst
                                       -1
                                       "refindex(get(nS2`state`stack)(target(nS2`state`redex)))"
                                       j)
                                      (("1"
                                        (simplify)
                                        (("1"
                                          (lift-if)
                                          (("1"
                                            (split obj)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (replace -1)
                                                (("1"
                                                  (typepred
                                                   "nS2`redex_type")
                                                  (("1"
                                                    (case
                                                     "update?(nS2`state`redex)")
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (expand
                                                         is_well_typed
                                                         -2)
                                                        (("1"
                                                          (flatten)
                                                          (("1"
                                                            (expand
                                                             is_well_typed
                                                             -5)
                                                            (("1"
                                                              (typepred
                                                               "nS2`stack_types")
                                                              (("1"
                                                                (expand
                                                                 get)
                                                                (("1"
                                                                  (inst
                                                                   -2
                                                                   "nS2`state`stack`length - 1 - index(rhs(nS2`state`redex))")
                                                                  (("1"
                                                                    (grind)
                                                                    nil)
                                                                   ("2"
                                                                    (typepred
                                                                     "nS2`state`redex")
                                                                    (("2"
                                                                      (inst
                                                                       -2
                                                                       "index(rhs(nS2`state`redex))")
                                                                      (("2"
                                                                        (grind)
                                                                        nil)))))))))))))))))))
                                                     ("2"
                                                      (grind)
                                                      nil)))))))))
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (typepred
                                                 "nS2`redex_type")
                                                (("2"
                                                  (case
                                                   "update?(nS2`state`redex)")
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (expand
                                                       is_well_typed
                                                       -2)
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (expand
                                                           is_well_typed
                                                           -3)
                                                          (("1"
                                                            (case
                                                             "value_of_type(get(nS2`state`stack)(target(nS2`state`redex)), leaftype(nS2`redex_type), nS2`dom_types)")
                                                            (("1"
                                                              (grind)
                                                              nil)
                                                             ("2"
                                                              (typepred
                                                               "nS2`stack_types")
                                                              (("2"
                                                                (expand
                                                                 get)
                                                                (("2"
                                                                  (inst?)
                                                                  (("1"
                                                                    (grind)
                                                                    nil)
                                                                   ("2"
                                                                    (typepred
                                                                     "nS2`state`redex")
                                                                    (("2"
                                                                      (inst
                                                                       -2
                                                                       "index(target(nS2`state`redex))")
                                                                      (("2"
                                                                        (grind)
                                                                        nil)))))))))))))))))))))
                                                   ("2"
                                                    (grind)
                                                    nil)))))))))))))))))
                                   ("2" (grind) nil)))
                                 ("2"
                                  (expand nS2)
                                  (("2"
                                    (expand set_new_type)
                                    (("2" (propax) nil)))))))))))
                           ("2" (typepred "nS2`dom_types")
                            (("2" (flatten)
                              (("2" (inst -1 r j) nil)))))))))))))
                   ("2" (flatten rdom)
                    (("2" (assert)
                      (("2" (typepred "nS2`dom_types")
                        (("2" (inst -1 r j) nil)))))))))))
               ("2" (expand nS2)
                (("2" (expand set_new_type) (("2" (propax) nil)))))))
             ("2" (expand nS2)
              (("2" (expand set_new_type) (("2" (propax) nil)))))))
           ("2" (typepred "nS`redex_type") (("2" (grind) nil))))))))))
    nil)
   nil nil
   (typed_reduce subtype
    "typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)]"
    "{dom_types | FORALL (r: (reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`seq(j), typed_reduction.dom_types(r), typed_reduction.dom_types)}"))
  (typed_reduce_TCC30-1 nil 3701716715
   (""
    (with-labels (skeep* :preds? t)
     ((tsr defswt natom ttop upr ifr apr letr nst obj)))
    (("" (split obj)
      (("1" (typepred "nS`redex_type") (("1" (grind) nil nil)) nil)
       ("2" (with-labels (skeep* obj :preds? t) ((jl rdom obj)))
        (("2"
          (name-replace "nS2"
           "set_new_type(nS, leaftype(nS`redex_type) - 1)")
          (("1"
            (case-replace
             "nS`dom_typesn                      WITH [(least_out(nS`state`domain))n                              |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
            (("1" (case-replace "nS`state = nS2`state")
              (("1" (expand updateReduce)
                (("1" (split rdom)
                  (("1" (flatten rdom)
                    (("1" (assert)
                      (("1" (lift-if)
                        (("1" (split obj)
                          (("1" (flatten)
                            (("1" (replace -1)
                              (("1"
                                (case-replace
                                 "nS2`dom_types(least_out(nS2`state`domain)) = leaftype(nS`redex_type) - 1")
                                (("1"
                                  (case-replace
                                   "nS`redex_type = nS2`redex_type")
                                  (("1"
                                    (typepred "nS2`dom_types")
                                    (("1"
                                      (inst
                                       -1
                                       "refindex(get(nS2`state`stack)(target(nS2`state`redex)))"
                                       j)
                                      (("1"
                                        (simplify)
                                        (("1"
                                          (lift-if)
                                          (("1"
                                            (split obj)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (replace -1)
                                                (("1"
                                                  (typepred
                                                   "nS2`redex_type")
                                                  (("1"
                                                    (case
                                                     "update?(nS2`state`redex)")
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (expand
                                                         is_well_typed
                                                         -2)
                                                        (("1"
                                                          (flatten)
                                                          (("1"
                                                            (expand
                                                             is_well_typed
                                                             -5)
                                                            (("1"
                                                              (typepred
                                                               "nS2`stack_types")
                                                              (("1"
                                                                (expand
                                                                 get)
                                                                (("1"
                                                                  (inst
                                                                   -2
                                                                   "nS2`state`stack`length - 1 - index(rhs(nS2`state`redex))")
                                                                  (("1"
                                                                    (grind)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (typepred
                                                                     "nS2`state`redex")
                                                                    (("2"
                                                                      (inst
                                                                       -2
                                                                       "index(rhs(nS2`state`redex))")
                                                                      (("2"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (typepred
                                                 "nS2`redex_type")
                                                (("2"
                                                  (case
                                                   "update?(nS2`state`redex)")
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (expand
                                                       is_well_typed
                                                       -2)
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (expand
                                                           is_well_typed
                                                           -3)
                                                          (("1"
                                                            (case
                                                             "value_of_type(get(nS2`state`stack)(target(nS2`state`redex)), leaftype(nS2`redex_type), nS2`dom_types)")
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil)
                                                             ("2"
                                                              (typepred
                                                               "nS2`stack_types")
                                                              (("2"
                                                                (expand
                                                                 get)
                                                                (("2"
                                                                  (inst?)
                                                                  (("1"
                                                                    (grind)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (typepred
                                                                     "nS2`state`redex")
                                                                    (("2"
                                                                      (inst
                                                                       -2
                                                                       "index(target(nS2`state`redex))")
                                                                      (("2"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil)
                                 ("2"
                                  (expand nS2)
                                  (("2"
                                    (expand set_new_type)
                                    (("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (typepred "nS2`dom_types")
                            (("2" (flatten)
                              (("2" (inst -1 r j) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten rdom)
                    (("2" (assert)
                      (("2" (typepred "nS2`dom_types")
                        (("2" (inst -1 r j) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand nS2)
                (("2" (expand set_new_type) (("2" (propax) nil nil))
                  nil))
                nil))
              nil)
             ("2" (expand nS2)
              (("2" (expand set_new_type) (("2" (propax) nil nil))
                nil))
              nil))
            nil)
           ("2" (typepred "nS`redex_type") (("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ifReduce const-decl "estate" reduction nil)
    (get const-decl "(value?)" IL nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)]"
    "{dom_types | FORALL (r: (reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`seq(j), typed_reduction.dom_types(r), typed_reduction.dom_types)}")))
 (typed_reduce_TCC34 0
  (typed_reduce_TCC31-3 nil 3705867002
   ("" (skeep* :preds? t)
    ((""
      (name-replace nS2
       "set_new_type(nS, leaftype(nS`redex_type) - 1)")
      (("1"
        (case-replace
         "nS`dom_types                         WITH [(least_out(nS`state`domain))                                |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
        (("1" (expand updateReduce)
          (("1" (assert)
            (("1" (typepred "nS2`stack_types")
              (("1" (expand nS2)
                (("1" (skeep)
                  (("1" (inst -2 i)
                    (("1" (grind) nil nil)
                     ("2" (expand nS2) (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand nS2)
          (("2" (expand set_new_type) (("2" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil)
       ("3" (typepred "nS`redex_type") (("3" (grind) nil nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (updateReduce const-decl "estate" reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (i skolem-const-decl "below(nS`stack_types`length)" typed_reduction
       nil)
    (nS skolem-const-decl "typed_state" typed_reduction nil)
    (nS2 skolem-const-decl "typed_state" typed_reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (get const-decl "(value?)" IL nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`stack_types"
    "{stypes | booleans.AND(typed_reduction.stypes`length = reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_reduction.stypes`length)): typed_reduction.value_of_type(reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`seq(i), typed_reduction.stypes`seq(i), typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)]))}"))
  (typed_reduce_TCC31-2 nil 3705866980
   ("" (skeep* :preds? t)
    ((""
      (name-replace nS2
       "set_new_type(nS, leaftype(nS`redex_type) - 1)")
      (("1"
        (case-replace
         "nS`dom_types                         WITH [(least_out(nS`state`domain))n                                 |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
        (("1" (expand updateReduce)
          (("1" (assert)
            (("1" (typepred "nS2`stack_types")
              (("1" (expand nS2)
                (("1" (skeep)
                  (("1" (inst -2 i)
                    (("1" (grind) nil)
                     ("2" (expand nS2) (("2" (grind) nil)))))))))))))))
         ("2" (expand nS2)
          (("2" (expand set_new_type) (("2" (propax) nil)))))))
       ("2" (typepred "nS`redex_type") (("2" (grind) nil)))
       ("3" (typepred "nS`redex_type") (("3" (grind) nil))))))
    nil)
   nil nil
   (typed_reduce subtype "typed_reduction.nS`stack_types"
    "{stypes | booleans.AND(typed_reduction.stypes`length = reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_reduction.stypes`length)): typed_reduction.value_of_type(reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`seq(i), typed_reduction.stypes`seq(i), typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)]))}"))
  (typed_reduce_TCC31-1 nil 3701716715
   ("" (skeep* :preds? t)
    ((""
      (name-replace nS2
       "set_new_type(nS, leaftype(nS`redex_type) - 1)")
      (("1"
        (case-replace
         "nS`dom_typesn                         WITH [(least_out(nS`state`domain))n                                 |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
        (("1" (expand updateReduce)
          (("1" (assert)
            (("1" (typepred "nS2`stack_types")
              (("1" (expand nS2)
                (("1" (skeep)
                  (("1" (inst -2 i)
                    (("1" (grind) nil nil)
                     ("2" (expand nS2) (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand nS2)
          (("2" (expand set_new_type) (("2" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil)
       ("3" (typepred "nS`redex_type") (("3" (grind) nil nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (updateReduce const-decl "estate" reduction nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (get const-decl "(value?)" IL nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`stack_types"
    "{stypes | booleans.AND(typed_reduction.stypes`length = reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_reduction.stypes`length)): typed_reduction.value_of_type(reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`seq(i), typed_reduction.stypes`seq(i), typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)]))}")))
 (typed_reduce_TCC35 0
  (typed_reduce_TCC35-1 "" 3720743049
   ("" (skeep* :preds? t)
    ((""
      (name-replace nS2 "set_new_type(nS, leaftype(nS`redex_type) -1)")
      (("1"
        (case-replace
         "nS`dom_types                      WITH [(least_out(nS`state`domain))                             |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
        (("1" (expand updateReduce)
          (("1" (lift-if)
            (("1" (split)
              (("1" (flatten)
                (("1" (expand is_well_typed)
                  (("1" (expand nS2)
                    (("1" (expand set_new_type)
                      (("1" (typepred "nS`redex_type")
                        (("1" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (typepred "nS2`redex_type")
                  (("2" (expand nS2)
                    (("2" (expand set_new_type)
                      (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand nS2)
          (("2" (expand set_new_type) (("2" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil))
      nil))
    nil)
   nil shostak
   (typed_reduce subtype "typed_reduction.nS`redex_type"
    "{tA | typed_reduction.is_well_typed(reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`redex, typed_reduction.tA, typed_reduction.nS`stack_types, typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)], typed_reduction.nS`def_types)}"))
  (typed_reduce_TCC32-3 nil 3705867078
   ("" (skeep* :preds? t)
    ((""
      (name-replace nS2 "set_new_type(nS, leaftype(nS`redex_type) -1)")
      (("1"
        (case-replace
         "nS`dom_types                      WITH [(least_out(nS`state`domain))                             |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
        (("1" (expand updateReduce)
          (("1" (lift-if)
            (("1" (split)
              (("1" (flatten)
                (("1" (expand is_well_typed)
                  (("1" (expand nS2)
                    (("1" (expand set_new_type)
                      (("1" (typepred "nS`redex_type")
                        (("1" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (typepred "nS2`redex_type")
                  (("2" (expand nS2)
                    (("2" (expand set_new_type)
                      (("2" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand nS2)
          (("2" (expand set_new_type) (("2" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (updateReduce const-decl "estate" reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (get const-decl "(value?)" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nS2 skolem-const-decl "typed_state" typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`redex_type"
    "{tA | typed_reduction.is_well_typed(reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`redex, typed_reduction.tA, typed_reduction.nS`stack_types, typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)], typed_reduction.nS`def_types)}"))
  (typed_reduce_TCC32-2 nil 3705867063
   ("" (skeep* :preds? t)
    ((""
      (name-replace nS2 "set_new_type(nS, leaftype(nS`redex_type) -1)")
      (("1"
        (case-replace
         "nS`dom_types                      WITH [(least_out(nS`state`domain))n                             |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
        (("1" (expand updateReduce)
          (("1" (lift-if)
            (("1" (split)
              (("1" (flatten)
                (("1" (expand is_well_typed)
                  (("1" (expand nS2)
                    (("1" (expand set_new_type)
                      (("1" (typepred "nS`redex_type")
                        (("1" (grind) nil)))))))))))
               ("2" (flatten)
                (("2" (typepred "nS2`redex_type")
                  (("2" (expand nS2)
                    (("2" (expand set_new_type)
                      (("2" (propax) nil)))))))))))))))
         ("2" (expand nS2)
          (("2" (expand set_new_type) (("2" (propax) nil)))))))
       ("2" (typepred "nS`redex_type") (("2" (grind) nil))))))
    nil)
   nil nil
   (typed_reduce subtype "typed_reduction.nS`redex_type"
    "{tA | typed_reduction.is_well_typed(reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`redex, typed_reduction.tA, typed_reduction.nS`stack_types, typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)], typed_reduction.nS`def_types)}"))
  (typed_reduce_TCC32-1 nil 3701716715
   ("" (skeep* :preds? t)
    ((""
      (name-replace nS2 "set_new_type(nS, leaftype(nS`redex_type) -1)")
      (("1"
        (case-replace
         "nS`dom_typesn                      WITH [(least_out(nS`state`domain))n                              |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
        (("1" (expand updateReduce)
          (("1" (lift-if)
            (("1" (split)
              (("1" (flatten)
                (("1" (expand is_well_typed)
                  (("1" (expand nS2)
                    (("1" (expand set_new_type)
                      (("1" (typepred "nS`redex_type")
                        (("1" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (typepred "nS2`redex_type")
                  (("2" (expand nS2)
                    (("2" (expand set_new_type)
                      (("2" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand nS2)
          (("2" (expand set_new_type) (("2" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (updateReduce const-decl "estate" reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (get const-decl "(value?)" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`redex_type"
    "{tA | typed_reduction.is_well_typed(reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`redex, typed_reduction.tA, typed_reduction.nS`stack_types, typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)], typed_reduction.nS`def_types)}")))
 (typed_reduce_TCC36 0
  (typed_reduce_TCC36-1 "" 3720743181
   ("" (skeep* :preds? t)
    ((""
      (name-replace nS2 "set_new_type(nS, leaftype(nS`redex_type) -1)")
      (("1"
        (case-replace
         "nS`dom_types                         WITH [(least_out(nS`state`domain))                                 |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
        (("1"
          (case-replace
           "popDepth(updateReduce(D)(nS`state)`redex) = popDepth(nS`state`redex)")
          (("1" (expand updateReduce +)
            (("1" (assert)
              (("1" (typepred "nS2`context_type")
                (("1" (expand nS2)
                  (("1" (expand set_new_type) (("1" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand updateReduce)
            (("2" (lift-if)
              (("2" (split 1)
                (("1" (flatten)
                  (("1" (expand popDepth) (("1" (grind) nil nil)) nil))
                  nil)
                 ("2" (propax) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand nS2)
          (("2" (expand set_new_type) (("2" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil))
      nil))
    nil)
   nil shostak
   (typed_reduce subtype "typed_reduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`context, typed_reduction.tK, typed_reduction.popn(typed_reduction.nS`stack_types, IL.popDepth(reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`redex)), typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)], typed_reduction.nS`def_types, typed_reduction.expr_type(typed_reduction.nS`redex_type))}"))
  (typed_reduce_TCC33-2 nil 3705867111
   ("" (skeep* :preds? t)
    ((""
      (name-replace nS2 "set_new_type(nS, leaftype(nS`redex_type) -1)")
      (("1"
        (case-replace
         "nS`dom_types                         WITH [(least_out(nS`state`domain))                                 |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
        (("1"
          (case-replace
           "popDepth(updateReduce(D)(nS`state)`redex) = popDepth(nS`state`redex)")
          (("1" (expand updateReduce +)
            (("1" (assert)
              (("1" (typepred "nS2`context_type")
                (("1" (expand nS2)
                  (("1" (expand set_new_type) (("1" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand updateReduce)
            (("2" (lift-if)
              (("2" (split 1)
                (("1" (flatten)
                  (("1" (expand popDepth) (("1" (grind) nil nil)) nil))
                  nil)
                 ("2" (propax) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand nS2)
          (("2" (expand set_new_type) (("2" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Store type-eq-decl nil reduction nil)
    (goodstate type-eq-decl nil reduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (updateReduce const-decl "estate" reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nS2 skolem-const-decl "typed_state" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (get const-decl "(value?)" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`context, typed_reduction.tK, typed_reduction.popn(typed_reduction.nS`stack_types, IL.popDepth(reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`redex)), typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)], typed_reduction.nS`def_types, typed_reduction.expr_type(typed_reduction.nS`redex_type))}"))
  (typed_reduce_TCC33-1 nil 3701716715
   ("" (skeep* :preds? t)
    ((""
      (name-replace nS2 "set_new_type(nS, leaftype(nS`redex_type) -1)")
      (("1"
        (case-replace
         "nS`dom_typesn                         WITH [(least_out(nS`state`domain))n                                 |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
        (("1"
          (case-replace
           "popDepth(updateReduce(D)(nS`state)`redex) = popDepth(nS`state`redex)")
          (("1" (expand updateReduce +)
            (("1" (assert)
              (("1" (typepred "nS2`context_type")
                (("1" (expand nS2)
                  (("1" (expand set_new_type) (("1" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand updateReduce)
            (("2" (lift-if)
              (("2" (split 1)
                (("1" (flatten)
                  (("1" (expand popDepth) (("1" (grind) nil nil)) nil))
                  nil)
                 ("2" (propax) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand nS2)
          (("2" (expand set_new_type) (("2" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (goodstate type-eq-decl nil reduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (updateReduce const-decl "estate" reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (get const-decl "(value?)" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`context, typed_reduction.tK, typed_reduction.popn(typed_reduction.nS`stack_types, IL.popDepth(reduction.updateReduce(typed_reduction.D)(typed_reduction.nS`state)`redex)), typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)], typed_reduction.nS`def_types, typed_reduction.expr_type(typed_reduction.nS`redex_type))}")))
 (typed_reduce_TCC37 0
  (typed_reduce_TCC34-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`state"
    "{gS | IL.lookupRedex?(reduction.gS`redex)}")))
 (typed_reduce_TCC38 0
  (typed_reduce_TCC35-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand lookupReduce)
      (("" (assert)
        (("" (typepred "nS`dom_types") (("" (inst -1 r j) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((lookupReduce const-decl "estate" reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (goodstate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil)
    (Defs type-eq-decl nil reduction nil)
    (Definition type-eq-decl nil reduction nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (pure? def-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`dom_types"
    "{dom_types | FORALL (r: (reduction.lookupReduce(typed_reduction.D)(typed_reduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(reduction.lookupReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(reduction.lookupReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`seq(j), typed_reduction.dom_types(r), typed_reduction.dom_types)}")))
 (typed_reduce_TCC39 0
  (typed_reduce_TCC36-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand lookupReduce)
      (("" (assert)
        (("" (typepred "nS`stack_types") (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((lookupReduce const-decl "estate" reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`stack_types"
    "{stypes | booleans.AND(typed_reduction.stypes`length = reduction.lookupReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_reduction.stypes`length)): typed_reduction.value_of_type(reduction.lookupReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`seq(i), typed_reduction.stypes`seq(i), typed_reduction.nS`dom_types))}")))
 (typed_reduce_TCC40 0
  (typed_reduce_TCC37-2 nil 3705867162
   ("" (skeep* :preds? t)
    (("" (expand lookupReduce)
      (("" (lift-if)
        (("" (split)
          (("1" (flatten)
            (("1" (typepred "nS`dom_types")
              (("1" (inst?)
                (("1" (typepred "nS`redex_type")
                  (("1" (case "lookup?(nS`state`redex)")
                    (("1" (assert)
                      (("1" (expand is_well_typed -)
                        (("1" (expand is_well_typed -)
                          (("1" (typepred "nS`stack_types")
                            (("1"
                              (inst -2
                               "nS`stack_types`length - 1 - index(arrayvalue(nS`state`redex))")
                              (("1"
                                (replace -1)
                                (("1"
                                  (expand get)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (expand value_of_type -2)
                                      (("1"
                                        (rewrite value_well_typed +)
                                        (("1"
                                          (case-replace
                                           "nS`dom_types                        (refindex((nS`state`stack`seq                                      (nS`state`stack`length - 1                                      -                                        index                                        (arrayvalue(nS`state`redex)))))) = leaftype(nS`redex_type)")
                                          (("1" (grind) nil nil)
                                           ("2" (grind) nil nil)
                                           ("3"
                                            (typepred "nS`state`redex")
                                            (("3"
                                              (inst
                                               -2
                                               "index(arrayvalue(nS`state`redex))")
                                              (("3" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (typepred "nS`state`redex")
                                          (("2"
                                            (inst
                                             -2
                                             "index(arrayvalue(nS`state`redex))")
                                            (("2" (grind) nil nil))
                                            nil))
                                          nil)
                                         ("3"
                                          (typepred "nS`state`redex")
                                          (("3"
                                            (inst
                                             -2
                                             "index(position(nS`state`redex))")
                                            (("3" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (typepred "nS`state`redex")
                                (("2"
                                  (inst
                                   -2
                                   "index(arrayvalue(nS`state`redex))")
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (typepred "nS`redex_type") (("2" (propax) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lookupReduce const-decl "estate" reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (member const-decl "bool" sets nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (add const-decl "(nonempty?)" sets nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (value_well_typed formula-decl nil typed_reduction nil)
    (position adt-accessor-decl "[(lookup?) -> (variable?)]"
      IExpression_adt nil)
    (nS skolem-const-decl "typed_state" typed_reduction nil)
    (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt
     nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]"
     IExpression_adt nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`redex_type"
    "{tA | typed_reduction.is_well_typed(reduction.lookupReduce(typed_reduction.D)(typed_reduction.nS`state)`redex, typed_reduction.tA, typed_reduction.nS`stack_types, typed_reduction.nS`dom_types, typed_reduction.nS`def_types)}"))
  (typed_reduce_TCC37-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand lookupReduce)
      (("" (lift-if)
        (("" (split)
          (("1" (flatten)
            (("1" (typepred "nS`dom_types")
              (("1" (inst?)
                (("1" (typepred "nS`redex_type")
                  (("1" (case "lookup?(nS`state`redex)")
                    (("1" (assert)
                      (("1" (expand is_well_typed -)
                        (("1" (expand is_well_typed -)
                          (("1" (typepred "nS`stack_types")
                            (("1"
                              (inst -2
                               "nS`stack_types`length - 1 - index(arrayvalue(nS`state`redex))")
                              (("1"
                                (replace -1)
                                (("1"
                                  (expand get)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (expand value_of_type -2)
                                      (("1"
                                        (rewrite value_well_typed +)
                                        (("1"
                                          (case-replace
                                           "nS`dom_typesn                        (refindex((nS`state`stack`seqn                                       (nS`state`stack`length - 1n                                        -n                                        indexn                                        (arrayvalue(nS`state`redex)))))) = leaftype(nS`redex_type)")
                                          (("1" (grind) nil nil)
                                           ("2" (grind) nil nil)
                                           ("3"
                                            (typepred "nS`state`redex")
                                            (("3"
                                              (inst
                                               -2
                                               "index(arrayvalue(nS`state`redex))")
                                              (("3" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (typepred "nS`state`redex")
                                          (("2"
                                            (inst
                                             -2
                                             "index(arrayvalue(nS`state`redex))")
                                            (("2" (grind) nil nil))
                                            nil))
                                          nil)
                                         ("3"
                                          (typepred "nS`state`redex")
                                          (("3"
                                            (inst
                                             -2
                                             "index(position(nS`state`redex))")
                                            (("3" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (typepred "nS`state`redex")
                                (("2"
                                  (inst
                                   -2
                                   "index(arrayvalue(nS`state`redex))")
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (typepred "nS`redex_type") (("2" (propax) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lookupReduce const-decl "estate" reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (member const-decl "bool" sets nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (add const-decl "(nonempty?)" sets nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (refs def-decl "bool" IL nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (value_well_typed formula-decl nil typed_reduction nil)
    (position adt-accessor-decl "[(lookup?) -> (variable?)]"
      IExpression_adt nil)
    (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt
     nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]"
     IExpression_adt nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`redex_type"
    "{tA | typed_reduction.is_well_typed(reduction.lookupReduce(typed_reduction.D)(typed_reduction.nS`state)`redex, typed_reduction.tA, typed_reduction.nS`stack_types, typed_reduction.nS`dom_types, typed_reduction.nS`def_types)}")))
 (typed_reduce_TCC41 0
  (typed_reduce_TCC38-2 nil 3705867192
   ("" (skeep* :preds? t)
    ((""
      (case-replace
       "popDepth(lookupReduce(D)(nS`state)`redex) = popDepth(nS`state`redex)")
      (("1" (expand lookupReduce +) (("1" (assert) nil nil)) nil)
       ("2" (typepred "nS`context_type")
        (("2" (expand lookupReduce)
          (("2" (lift-if)
            (("2" (split)
              (("1" (flatten)
                (("1"
                  (typepred
                   "nS`state`store                   (refindex(get(nS`state`stack)                                (arrayvalue(nS`state`redex))))`seq                   (value(get(nS`state`stack)(position(nS`state`redex))))")
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                nil)
               ("2" (propax) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (popDepth def-decl "nat" IL nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (lookupReduce const-decl "estate" reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (get const-decl "(value?)" IL nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]"
     IExpression_adt nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt
     nil)
    (position adt-accessor-decl "[(lookup?) -> (variable?)]"
      IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (D skolem-const-decl "Defs" typed_reduction nil)
    (tS skolem-const-decl
     "{tS | NOT tS`state`error AND defs_well_typed(D, tS`def_types)}"
     typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(reduction.lookupReduce(typed_reduction.D)(typed_reduction.nS`state)`context, typed_reduction.tK, typed_reduction.popn(typed_reduction.nS`stack_types, IL.popDepth(reduction.lookupReduce(typed_reduction.D)(typed_reduction.nS`state)`redex)), typed_reduction.nS`dom_types, typed_reduction.nS`def_types, typed_reduction.expr_type(typed_reduction.nS`redex_type))}"))
  (typed_reduce_TCC38-1 nil 3701716715
   ("" (skeep* :preds? t)
    ((""
      (case-replace
       "popDepth(lookupReduce(D)(nS`state)`redex) = popDepth(nS`state`redex)")
      (("1" (expand lookupReduce +) (("1" (assert) nil nil)) nil)
       ("2" (typepred "nS`context_type")
        (("2" (expand lookupReduce)
          (("2" (lift-if)
            (("2" (split)
              (("1" (flatten)
                (("1"
                  (typepred
                   "nS`state`storen                   (refindex(get(nS`state`stack)n                                (arrayvalue(nS`state`redex))))`seqn                   (value(get(nS`state`stack)(position(nS`state`redex))))")
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                nil)
               ("2" (propax) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (lookupReduce const-decl "estate" reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (get const-decl "(value?)" IL nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]"
     IExpression_adt nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt
     nil)
    (position adt-accessor-decl "[(lookup?) -> (variable?)]"
      IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(reduction.lookupReduce(typed_reduction.D)(typed_reduction.nS`state)`context, typed_reduction.tK, typed_reduction.popn(typed_reduction.nS`stack_types, IL.popDepth(reduction.lookupReduce(typed_reduction.D)(typed_reduction.nS`state)`redex)), typed_reduction.nS`dom_types, typed_reduction.nS`def_types, typed_reduction.expr_type(typed_reduction.nS`redex_type))}")))
 (typed_reduce_TCC42 0
  (typed_reduce_TCC39-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil)) nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`state"
    "{gS | IL.newintRedex?(reduction.gS`redex)}")))
 (typed_reduce_TCC43 0
  (typed_reduce_TCC40-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil)) nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`redex_type"
    "(typeinfo_adt.leaft?)")))
 (typed_reduce_TCC44 0
  (typed_reduce_TCC41-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil)) nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (D skolem-const-decl "Defs" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (pure? def-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "(number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)"
    "nat")))
 (typed_reduce_TCC45 0
  (typed_reduce_TCC45-1 "" 3720743394
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (typepred "nS`redex_type") (("1" (grind) nil nil)) nil)
       ("2" (skeep* :preds? t)
        (("2" (name-replace nS2 "set_new_type(nS, 0)")
          (("2"
            (case-replace
             "nS`dom_types                      WITH [(least_out(nS`state`domain))                              |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
            (("1" (expand newintReduce)
              (("1" (lift-if)
                (("1" (split 1)
                  (("1" (flatten)
                    (("1" (expand value_of_type)
                      (("1" (expand nS2) (("1" (grind) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (typepred "nS2`dom_types")
                      (("2" (inst -1 r j)
                        (("1" (expand nS2)
                          (("1" (expand set_new_type)
                            (("1" (assert) (("1" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand nS2)
                          (("2" (expand set_new_type)
                            (("2" (assert) nil nil)) nil))
                          nil)
                         ("3" (expand nS2) (("3" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand nS2)
              (("2" (expand set_new_type)
                (("2" (typepred "nS`redex_type")
                  (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak
   (typed_reduce subtype
    "typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)]"
    "{dom_types | FORALL (r: (reduction.newintReduce(typed_reduction.D)(typed_reduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(reduction.newintReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(reduction.newintReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`seq(j), typed_reduction.dom_types(r), typed_reduction.dom_types)}"))
  (typed_reduce_TCC42-2 nil 3705867255
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (typepred "nS`redex_type") (("1" (grind) nil nil)) nil)
       ("2" (skeep* :preds? t)
        (("2" (name-replace nS2 "set_new_type(nS, 0)")
          (("2"
            (case-replace
             "nS`dom_types                      WITH [(least_out(nS`state`domain))                              |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
            (("1" (expand newintReduce)
              (("1" (lift-if)
                (("1" (split 1)
                  (("1" (flatten)
                    (("1" (expand value_of_type)
                      (("1" (expand nS2) (("1" (grind) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (typepred "nS2`dom_types")
                      (("2" (inst -1 r j)
                        (("1" (expand nS2)
                          (("1" (expand set_new_type)
                            (("1" (propax) nil nil)) nil))
                          nil)
                         ("2" (expand nS2)
                          (("2" (expand set_new_type)
                            (("2" (assert) nil nil)) nil))
                          nil)
                         ("3" (expand nS2) (("3" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand nS2)
              (("2" (expand set_new_type)
                (("2" (typepred "nS`redex_type")
                  (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (D skolem-const-decl "Defs" typed_reduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (newintReduce const-decl "estate" reduction nil)
    (nS2 skolem-const-decl "typed_state" typed_reduction nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (j skolem-const-decl
     "below(newintReduce(D)(nS`state)`store(r)`length)" typed_reduction
     nil)
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Store type-eq-decl nil reduction nil)
    (goodstate type-eq-decl nil reduction nil)
    (nS skolem-const-decl "typed_state" typed_reduction nil)
    (r skolem-const-decl "(newintReduce(D)(nS`state)`domain)"
     typed_reduction nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)]"
    "{dom_types | FORALL (r: (reduction.newintReduce(typed_reduction.D)(typed_reduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(reduction.newintReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(reduction.newintReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`seq(j), typed_reduction.dom_types(r), typed_reduction.dom_types)}"))
  (typed_reduce_TCC42-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (typepred "nS`redex_type") (("1" (grind) nil nil)) nil)
       ("2" (skeep* :preds? t)
        (("2" (name-replace nS2 "set_new_type(nS, 0)")
          (("2"
            (case-replace
             "nS`dom_typesn                      WITH [(least_out(nS`state`domain))n                              |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
            (("1" (expand newintReduce)
              (("1" (lift-if)
                (("1" (split 1)
                  (("1" (flatten)
                    (("1" (expand value_of_type)
                      (("1" (expand nS2) (("1" (grind) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (typepred "nS2`dom_types")
                      (("2" (inst -1 r j)
                        (("1" (expand nS2)
                          (("1" (expand set_new_type)
                            (("1" (propax) nil nil)) nil))
                          nil)
                         ("2" (expand nS2)
                          (("2" (expand set_new_type)
                            (("2" (assert) nil nil)) nil))
                          nil)
                         ("3" (expand nS2) (("3" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand nS2)
              (("2" (expand set_new_type)
                (("2" (typepred "nS`redex_type")
                  (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (newintReduce const-decl "estate" reduction nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (goodstate type-eq-decl nil reduction nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)]"
    "{dom_types | FORALL (r: (reduction.newintReduce(typed_reduction.D)(typed_reduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(reduction.newintReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(reduction.newintReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`seq(j), typed_reduction.dom_types(r), typed_reduction.dom_types)}")))
 (typed_reduce_TCC46 0
  (typed_reduce_TCC46-1 "" 3720743597
   ("" (skeep* :preds? t)
    ((""
      (name-replace nS2
       "set_new_type(nS, leaftype(nS`redex_type) - 1)")
      (("1"
        (case-replace
         "nS`dom_types                         WITH [(least_out(nS`state`domain))                                 |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
        (("1" (expand newintReduce)
          (("1" (typepred "nS2`stack_types")
            (("1" (expand nS2)
              (("1" (expand set_new_type)
                (("1" (assert)
                  (("1" (skeep)
                    (("1" (inst?)
                      (("1" (grind) nil nil)
                       ("2" (expand nS2) (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil))
        nil)
       ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil)
       ("3" (typepred "nS`redex_type") (("3" (grind) nil nil)) nil))
      nil))
    nil)
   nil shostak
   (typed_reduce subtype "typed_reduction.nS`stack_types"
    "{stypes | booleans.AND(typed_reduction.stypes`length = reduction.newintReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_reduction.stypes`length)): typed_reduction.value_of_type(reduction.newintReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`seq(i), typed_reduction.stypes`seq(i), typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)]))}"))
  (typed_reduce_TCC43-2 nil 3705867307
   ("" (skeep* :preds? t)
    ((""
      (name-replace nS2
       "set_new_type(nS, leaftype(nS`redex_type) - 1)")
      (("1"
        (case-replace
         "nS`dom_types                         WITH [(least_out(nS`state`domain))                                 |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
        (("1" (expand newintReduce)
          (("1" (typepred "nS2`stack_types")
            (("1" (expand nS2)
              (("1" (expand set_new_type)
                (("1" (assert)
                  (("1" (skeep)
                    (("1" (inst?)
                      (("1" (expand nS2) (("1" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand nS2) (("2" (grind) nil nil)) nil))
        nil)
       ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil)
       ("3" (typepred "nS`redex_type") (("3" (grind) nil nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (newintReduce const-decl "estate" reduction nil)
    (nS2 skolem-const-decl "typed_state" typed_reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nS skolem-const-decl "typed_state" typed_reduction nil)
    (i skolem-const-decl "below(nS`stack_types`length)" typed_reduction
       nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (D skolem-const-decl "Defs" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (pure? def-decl "bool" IL nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`stack_types"
    "{stypes | booleans.AND(typed_reduction.stypes`length = reduction.newintReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_reduction.stypes`length)): typed_reduction.value_of_type(reduction.newintReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`seq(i), typed_reduction.stypes`seq(i), typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)]))}"))
  (typed_reduce_TCC43-1 nil 3701716715
   ("" (skeep* :preds? t)
    ((""
      (name-replace nS2
       "set_new_type(nS, leaftype(nS`redex_type) - 1)")
      (("1"
        (case-replace
         "nS`dom_typesn                         WITH [(least_out(nS`state`domain))n                                 |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
        (("1" (expand newintReduce)
          (("1" (typepred "nS2`stack_types")
            (("1" (expand nS2)
              (("1" (expand set_new_type)
                (("1" (assert)
                  (("1" (skeep)
                    (("1" (inst?)
                      (("1" (expand nS2) (("1" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand nS2) (("2" (grind) nil nil)) nil))
        nil)
       ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil)
       ("3" (typepred "nS`redex_type") (("3" (grind) nil nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (newintReduce const-decl "estate" reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (pure? def-decl "bool" IL nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`stack_types"
    "{stypes | booleans.AND(typed_reduction.stypes`length = reduction.newintReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_reduction.stypes`length)): typed_reduction.value_of_type(reduction.newintReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`seq(i), typed_reduction.stypes`seq(i), typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)]))}")))
 (typed_reduce_TCC47 0
  (typed_reduce_TCC44-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand newintReduce)
      (("" (expand is_well_typed)
        (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((newintReduce const-decl "estate" reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`redex_type"
    "{tA | typed_reduction.is_well_typed(reduction.newintReduce(typed_reduction.D)(typed_reduction.nS`state)`redex, typed_reduction.tA, typed_reduction.nS`stack_types, typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)], typed_reduction.nS`def_types)}")))
 (typed_reduce_TCC48 0
  (typed_reduce_TCC48-1 "" 3720743649
   ("" (skeep* :preds? t)
    (("" (expand newintReduce)
      ((""
        (case-replace
         "popDepth(ref(least_out(nS`state`domain))) = popDepth(nS`state`redex)")
        (("1"
          (name-replace nS2
           "set_new_type(nS, leaftype(nS`redex_type) - 1)")
          (("1"
            (case-replace
             "nS`dom_types                         WITH [(least_out(nS`state`domain))                                 |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
            (("1" (typepred "nS2`context_type")
              (("1" (expand nS2)
                (("1" (expand set_new_type) (("1" (assert) nil nil))
                  nil))
                nil))
              nil)
             ("2" (expand nS2)
              (("2" (expand set_new_type) (("2" (propax) nil nil))
                nil))
              nil))
            nil)
           ("2" (typepred "nS`redex_type") (("2" (grind) nil nil))
            nil))
          nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   nil shostak
   (typed_reduce subtype "typed_reduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(reduction.newintReduce(typed_reduction.D)(typed_reduction.nS`state)`context, typed_reduction.tK, typed_reduction.popn(typed_reduction.nS`stack_types, IL.popDepth(reduction.newintReduce(typed_reduction.D)(typed_reduction.nS`state)`redex)), typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)], typed_reduction.nS`def_types, typed_reduction.expr_type(typed_reduction.nS`redex_type))}"))
  (typed_reduce_TCC45-2 nil 3705867361
   ("" (skeep* :preds? t)
    (("" (expand newintReduce)
      ((""
        (case-replace
         "popDepth(ref(least_out(nS`state`domain))) = popDepth(nS`state`redex)")
        (("1"
          (name-replace nS2
           "set_new_type(nS, leaftype(nS`redex_type) - 1)")
          (("1"
            (case-replace
             "nS`dom_types                         WITH [(least_out(nS`state`domain))                                 |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
            (("1" (typepred "nS2`context_type")
              (("1" (expand nS2)
                (("1" (expand set_new_type) (("1" (propax) nil nil))
                  nil))
                nil))
              nil)
             ("2" (expand nS2)
              (("2" (expand set_new_type) (("2" (propax) nil nil))
                nil))
              nil))
            nil)
           ("2" (typepred "nS`redex_type") (("2" (grind) nil nil))
            nil))
          nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((newintReduce const-decl "estate" reduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nS2 skolem-const-decl "typed_state" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (D skolem-const-decl "Defs" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (popDepth def-decl "nat" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(reduction.newintReduce(typed_reduction.D)(typed_reduction.nS`state)`context, typed_reduction.tK, typed_reduction.popn(typed_reduction.nS`stack_types, IL.popDepth(reduction.newintReduce(typed_reduction.D)(typed_reduction.nS`state)`redex)), typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)], typed_reduction.nS`def_types, typed_reduction.expr_type(typed_reduction.nS`redex_type))}"))
  (typed_reduce_TCC45-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand newintReduce)
      ((""
        (case-replace
         "popDepth(ref(least_out(nS`state`domain))) = popDepth(nS`state`redex)")
        (("1"
          (name-replace nS2
           "set_new_type(nS, leaftype(nS`redex_type) - 1)")
          (("1"
            (case-replace
             "nS`dom_typesn                         WITH [(least_out(nS`state`domain))n                                 |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
            (("1" (typepred "nS2`context_type")
              (("1" (expand nS2)
                (("1" (expand set_new_type) (("1" (propax) nil nil))
                  nil))
                nil))
              nil)
             ("2" (expand nS2)
              (("2" (expand set_new_type) (("2" (propax) nil nil))
                nil))
              nil))
            nil)
           ("2" (typepred "nS`redex_type") (("2" (grind) nil nil))
            nil))
          nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((newintReduce const-decl "estate" reduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(reduction.newintReduce(typed_reduction.D)(typed_reduction.nS`state)`context, typed_reduction.tK, typed_reduction.popn(typed_reduction.nS`stack_types, IL.popDepth(reduction.newintReduce(typed_reduction.D)(typed_reduction.nS`state)`redex)), typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)], typed_reduction.nS`def_types, typed_reduction.expr_type(typed_reduction.nS`redex_type))}")))
 (typed_reduce_TCC49 0
  (typed_reduce_TCC46-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`state"
    "{gS | IL.newrefRedex?(reduction.gS`redex)}")))
 (typed_reduce_TCC50 0
  (typed_reduce_TCC47-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil)) nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`redex_type"
    "(typeinfo_adt.leaft?)")))
 (typed_reduce_TCC51 0
  (typed_reduce_TCC48-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil)) nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "(number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)"
    "nat")))
 (typed_reduce_TCC52 0
  (typed_reduce_TCC52-1 "" 3720744960
   ("" (skeep* :preds? t)
    ((""
      (name-replace nS2
       "set_new_type(nS, leaftype(nS`redex_type) - 1)")
      (("1"
        (case-replace
         "nS`dom_types           WITH [(least_out(nS`state`domain))                   |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
        (("1" (split)
          (("1" (skeep)
            (("1" (typepred "nS2`dom_types(x1)")
              (("1" (propax) nil nil)) nil))
            nil)
           ("2" (skeep* :preds? t)
            (("2" (expand newrefReduce)
              (("2" (lift-if)
                (("2" (split)
                  (("1" (flatten)
                    (("1" (assert)
                      (("1" (expand value_of_type)
                        (("1" (expand nS2)
                          (("1" (expand set_new_type)
                            (("1" (typepred "nS`redex_type")
                              (("1" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert)
                    (("2" (flatten)
                      (("2" (assert)
                        (("2" (typepred "nS2`dom_types")
                          (("2" (inst -1 r j)
                            (("1" (expand nS2)
                              (("1"
                                (expand set_new_type)
                                (("1" (assert) nil nil))
                                nil))
                              nil)
                             ("2" (expand nS2)
                              (("2"
                                (expand set_new_type)
                                (("2" (assert) nil nil))
                                nil))
                              nil)
                             ("3" (expand nS2)
                              (("3"
                                (expand set_new_type)
                                (("3" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand nS2)
          (("2" (expand set_new_type) (("2" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil)
       ("3" (typepred "nS`redex_type") (("3" (grind) nil nil)) nil))
      nil))
    nil)
   nil shostak
   (typed_reduce subtype
    "typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)]"
    "{dom_types | FORALL (r: (reduction.newrefReduce(typed_reduction.D)(typed_reduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(reduction.newrefReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(reduction.newrefReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`seq(j), typed_reduction.dom_types(r), typed_reduction.dom_types)}"))
  (typed_reduce_TCC49-2 nil 3705867400
   ("" (skeep* :preds? t)
    ((""
      (name-replace nS2
       "set_new_type(nS, leaftype(nS`redex_type) - 1)")
      (("1"
        (case-replace
         "nS`dom_types           WITH [(least_out(nS`state`domain))                   |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
        (("1" (split)
          (("1" (skeep)
            (("1" (typepred "nS2`dom_types(x1)")
              (("1" (propax) nil nil)) nil))
            nil)
           ("2" (skeep* :preds? t)
            (("2" (expand newrefReduce)
              (("2" (lift-if)
                (("2" (split)
                  (("1" (flatten)
                    (("1" (assert)
                      (("1" (expand value_of_type)
                        (("1" (expand nS2)
                          (("1" (expand set_new_type)
                            (("1" (typepred "nS`redex_type")
                              (("1" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert)
                    (("2" (flatten)
                      (("2" (assert)
                        (("2" (typepred "nS2`dom_types")
                          (("2" (inst -1 r j)
                            (("1" (expand nS2)
                              (("1"
                                (expand set_new_type)
                                (("1" (propax) nil nil))
                                nil))
                              nil)
                             ("2" (expand nS2)
                              (("2"
                                (expand set_new_type)
                                (("2" (propax) nil nil))
                                nil))
                              nil)
                             ("3" (expand nS2)
                              (("3"
                                (expand set_new_type)
                                (("3" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand nS2)
          (("2" (expand set_new_type) (("2" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil)
       ("3" (typepred "nS`redex_type") (("3" (grind) nil nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (newrefReduce const-decl "estate" reduction nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nS2 skolem-const-decl "typed_state" typed_reduction nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (j skolem-const-decl
     "below(newrefReduce(D)(nS`state)`store(r)`length)" typed_reduction
     nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Store type-eq-decl nil reduction nil)
    (goodstate type-eq-decl nil reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (D skolem-const-decl "Defs" typed_reduction nil)
    (nS skolem-const-decl "typed_state" typed_reduction nil)
    (r skolem-const-decl "(newrefReduce(D)(nS`state)`domain)"
     typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)]"
    "{dom_types | FORALL (r: (reduction.newrefReduce(typed_reduction.D)(typed_reduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(reduction.newrefReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(reduction.newrefReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`seq(j), typed_reduction.dom_types(r), typed_reduction.dom_types)}"))
  (typed_reduce_TCC49-1 nil 3701716715
   ("" (skeep* :preds? t)
    ((""
      (name-replace nS2
       "set_new_type(nS, leaftype(nS`redex_type) - 1)")
      (("1"
        (case-replace
         "nS`dom_typesn           WITH [(least_out(nS`state`domain))n                   |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
        (("1" (split)
          (("1" (skeep)
            (("1" (typepred "nS2`dom_types(x1)")
              (("1" (propax) nil nil)) nil))
            nil)
           ("2" (skeep* :preds? t)
            (("2" (expand newrefReduce)
              (("2" (lift-if)
                (("2" (split)
                  (("1" (flatten)
                    (("1" (assert)
                      (("1" (expand value_of_type)
                        (("1" (expand nS2)
                          (("1" (expand set_new_type)
                            (("1" (typepred "nS`redex_type")
                              (("1" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert)
                    (("2" (flatten)
                      (("2" (assert)
                        (("2" (typepred "nS2`dom_types")
                          (("2" (inst -1 r j)
                            (("1" (expand nS2)
                              (("1"
                                (expand set_new_type)
                                (("1" (propax) nil nil))
                                nil))
                              nil)
                             ("2" (expand nS2)
                              (("2"
                                (expand set_new_type)
                                (("2" (propax) nil nil))
                                nil))
                              nil)
                             ("3" (expand nS2)
                              (("3"
                                (expand set_new_type)
                                (("3" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand nS2)
          (("2" (expand set_new_type) (("2" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil)
       ("3" (typepred "nS`redex_type") (("3" (grind) nil nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (newrefReduce const-decl "estate" reduction nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (goodstate type-eq-decl nil reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)]"
    "{dom_types | FORALL (r: (reduction.newrefReduce(typed_reduction.D)(typed_reduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(reduction.newrefReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(reduction.newrefReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`seq(j), typed_reduction.dom_types(r), typed_reduction.dom_types)}")))
 (typed_reduce_TCC53 0
  (typed_reduce_TCC53-1 "" 3720745166
   ("" (skeep* :preds? t)
    ((""
      (name-replace nS2
       "set_new_type(nS, leaftype(nS`redex_type) - 1)")
      (("1"
        (case-replace
         "nS`dom_types                             WITH [(least_out(nS`state`domain))                                     |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
        (("1" (expand newrefReduce)
          (("1" (typepred "nS2`stack_types")
            (("1" (expand nS2)
              (("1" (expand set_new_type)
                (("1" (assert)
                  (("1" (skeep)
                    (("1" (inst?)
                      (("1" (grind) nil nil)
                       ("2" (assert)
                        (("2" (expand nS2) (("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand nS2) (("2" (grind) nil nil)) nil))
        nil)
       ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil)
       ("3" (typepred "nS`redex_type") (("3" (grind) nil nil)) nil))
      nil))
    nil)
   nil shostak
   (typed_reduce subtype "typed_reduction.nS`stack_types"
    "{stypes | booleans.AND(typed_reduction.stypes`length = reduction.newrefReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_reduction.stypes`length)): typed_reduction.value_of_type(reduction.newrefReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`seq(i), typed_reduction.stypes`seq(i), typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)]))}"))
  (typed_reduce_TCC50-2 nil 3705867452
   ("" (skeep* :preds? t)
    ((""
      (name-replace nS2
       "set_new_type(nS, leaftype(nS`redex_type) - 1)")
      (("1"
        (case-replace
         "nS`dom_types                             WITH [(least_out(nS`state`domain))                                     |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
        (("1" (expand newrefReduce)
          (("1" (typepred "nS2`stack_types")
            (("1" (expand nS2)
              (("1" (expand set_new_type)
                (("1" (assert)
                  (("1" (skeep)
                    (("1" (inst?)
                      (("1" (expand nS2) (("1" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand nS2) (("2" (grind) nil nil)) nil))
        nil)
       ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil)
       ("3" (typepred "nS`redex_type") (("3" (grind) nil nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (newrefReduce const-decl "estate" reduction nil)
    (nS2 skolem-const-decl "typed_state" typed_reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nS skolem-const-decl "typed_state" typed_reduction nil)
    (i skolem-const-decl "below(nS`stack_types`length)" typed_reduction
       nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`stack_types"
    "{stypes | booleans.AND(typed_reduction.stypes`length = reduction.newrefReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_reduction.stypes`length)): typed_reduction.value_of_type(reduction.newrefReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`seq(i), typed_reduction.stypes`seq(i), typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)]))}"))
  (typed_reduce_TCC50-1 nil 3701716715
   ("" (skeep* :preds? t)
    ((""
      (name-replace nS2
       "set_new_type(nS, leaftype(nS`redex_type) - 1)")
      (("1"
        (case-replace
         "nS`dom_typesn                             WITH [(least_out(nS`state`domain))n                                     |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
        (("1" (expand newrefReduce)
          (("1" (typepred "nS2`stack_types")
            (("1" (expand nS2)
              (("1" (expand set_new_type)
                (("1" (assert)
                  (("1" (skeep)
                    (("1" (inst?)
                      (("1" (expand nS2) (("1" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand nS2) (("2" (grind) nil nil)) nil))
        nil)
       ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil)
       ("3" (typepred "nS`redex_type") (("3" (grind) nil nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (newrefReduce const-decl "estate" reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`stack_types"
    "{stypes | booleans.AND(typed_reduction.stypes`length = reduction.newrefReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_reduction.stypes`length)): typed_reduction.value_of_type(reduction.newrefReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`seq(i), typed_reduction.stypes`seq(i), typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)]))}")))
 (typed_reduce_TCC54 0
  (typed_reduce_TCC51-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand newrefReduce)
      (("" (expand is_well_typed)
        (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((newrefReduce const-decl "estate" reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`redex_type"
    "{tA | typed_reduction.is_well_typed(reduction.newrefReduce(typed_reduction.D)(typed_reduction.nS`state)`redex, typed_reduction.tA, typed_reduction.nS`stack_types, typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)], typed_reduction.nS`def_types)}")))
 (typed_reduce_TCC55 0
  (typed_reduce_TCC55-1 "" 3720745214
   ("" (skeep* :preds? t)
    (("" (expand newrefReduce)
      ((""
        (case-replace
         "popDepth(ref(least_out(nS`state`domain))) = popDepth(nS`state`redex)")
        (("1"
          (name-replace nS2
           "set_new_type(nS, leaftype(nS`redex_type) - 1)")
          (("1"
            (case-replace
             "nS`dom_types                               WITH [(least_out(nS`state`domain))                                       |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
            (("1" (typepred "nS2`context_type")
              (("1" (expand nS2)
                (("1" (expand set_new_type) (("1" (assert) nil nil))
                  nil))
                nil))
              nil)
             ("2" (expand nS2)
              (("2" (expand set_new_type) (("2" (propax) nil nil))
                nil))
              nil))
            nil)
           ("2" (typepred "nS`redex_type") (("2" (grind) nil nil))
            nil))
          nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   nil shostak
   (typed_reduce subtype "typed_reduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(reduction.newrefReduce(typed_reduction.D)(typed_reduction.nS`state)`context, typed_reduction.tK, typed_reduction.popn(typed_reduction.nS`stack_types, IL.popDepth(reduction.newrefReduce(typed_reduction.D)(typed_reduction.nS`state)`redex)), typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)], typed_reduction.nS`def_types, typed_reduction.expr_type(typed_reduction.nS`redex_type))}"))
  (typed_reduce_TCC52-2 nil 3705867535
   ("" (skeep* :preds? t)
    (("" (expand newrefReduce)
      ((""
        (case-replace
         "popDepth(ref(least_out(nS`state`domain))) = popDepth(nS`state`redex)")
        (("1"
          (name-replace nS2
           "set_new_type(nS, leaftype(nS`redex_type) - 1)")
          (("1"
            (case-replace
             "nS`dom_types                               WITH [(least_out(nS`state`domain))                                       |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
            (("1" (typepred "nS2`context_type")
              (("1" (expand nS2)
                (("1" (expand set_new_type) (("1" (propax) nil nil))
                  nil))
                nil))
              nil)
             ("2" (expand nS2)
              (("2" (expand set_new_type) (("2" (propax) nil nil))
                nil))
              nil))
            nil)
           ("2" (typepred "nS`redex_type") (("2" (grind) nil nil))
            nil))
          nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((newrefReduce const-decl "estate" reduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nS2 skolem-const-decl "typed_state" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (popDepth def-decl "nat" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(reduction.newrefReduce(typed_reduction.D)(typed_reduction.nS`state)`context, typed_reduction.tK, typed_reduction.popn(typed_reduction.nS`stack_types, IL.popDepth(reduction.newrefReduce(typed_reduction.D)(typed_reduction.nS`state)`redex)), typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)], typed_reduction.nS`def_types, typed_reduction.expr_type(typed_reduction.nS`redex_type))}"))
  (typed_reduce_TCC52-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand newrefReduce)
      ((""
        (case-replace
         "popDepth(ref(least_out(nS`state`domain))) = popDepth(nS`state`redex)")
        (("1"
          (name-replace nS2
           "set_new_type(nS, leaftype(nS`redex_type) - 1)")
          (("1"
            (case-replace
             "nS`dom_typesn                               WITH [(least_out(nS`state`domain))n                                       |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
            (("1" (typepred "nS2`context_type")
              (("1" (expand nS2)
                (("1" (expand set_new_type) (("1" (propax) nil nil))
                  nil))
                nil))
              nil)
             ("2" (expand nS2)
              (("2" (expand set_new_type) (("2" (propax) nil nil))
                nil))
              nil))
            nil)
           ("2" (typepred "nS`redex_type") (("2" (grind) nil nil))
            nil))
          nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((newrefReduce const-decl "estate" reduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(reduction.newrefReduce(typed_reduction.D)(typed_reduction.nS`state)`context, typed_reduction.tK, typed_reduction.popn(typed_reduction.nS`stack_types, IL.popDepth(reduction.newrefReduce(typed_reduction.D)(typed_reduction.nS`state)`redex)), typed_reduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_reduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_reduction.nS`redex_type), 1)], typed_reduction.nS`def_types, typed_reduction.expr_type(typed_reduction.nS`redex_type))}")))
 (typed_reduce_TCC56 0
  (typed_reduce_TCC53-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (popRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`state"
    "{gS | IL.popRedex?(reduction.gS`redex)}")))
 (typed_reduce_TCC57 0
  (typed_reduce_TCC57-1 "" 3720745235
   ("" (skeep* :preds? t)
    (("" (expand popReduce)
      (("" (typepred "nS`dom_types")
        (("" (inst -1 r j) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   nil shostak
   (typed_reduce subtype "typed_reduction.nS`dom_types"
    "{dom_types | FORALL (r: (reduction.popReduce(typed_reduction.D)(typed_reduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(reduction.popReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(reduction.popReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`seq(j), typed_reduction.dom_types(r), typed_reduction.dom_types)}"))
  (typed_reduce_TCC54-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand popReduce)
      (("" (typepred "nS`dom_types") (("" (inst -1 r j) nil nil)) nil))
      nil))
    nil)
   ((popReduce const-decl "estate" reduction nil)
    (D skolem-const-decl "Defs" typed_reduction nil)
    (nS skolem-const-decl "typed_state" typed_reduction nil)
    (r skolem-const-decl "(popReduce(D)(nS`state)`domain)"
     typed_reduction nil)
    (j skolem-const-decl
     "below(popReduce(D)(nS`state)`store(r)`length)" typed_reduction
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (popRedex? const-decl "bool" IL nil)
    (goodstate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil)
    (Defs type-eq-decl nil reduction nil)
    (Definition type-eq-decl nil reduction nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (pure? def-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`dom_types"
    "{dom_types | FORALL (r: (reduction.popReduce(typed_reduction.D)(typed_reduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(reduction.popReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(reduction.popReduce(typed_reduction.D)(typed_reduction.nS`state)`store(r)`seq(j), typed_reduction.dom_types(r), typed_reduction.dom_types)}")))
 (typed_reduce_TCC58 0
  (typed_reduce_TCC55-1 nil 3701716715
   ("" (skeep*)
    (("" (typepred "nS`stack_types")
      (("" (typepred "nS`state`redex")
        (("" (case "popDepth(nS`state`redex) > 0")
          (("1" (grind) nil nil)
           ("2" (case "pop?(nS`state`redex)")
            (("1" (assert) (("1" (grind) nil nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`stack_types"
    "nonempty_fs[nat]")))
 (typed_reduce_TCC59 0
  (typed_reduce_TCC56-1 nil 3701780462
   ("" (skeep* :preds? t)
    (("" (expand popReduce)
      (("" (expand pop)
        (("" (expand tail)
          (("" (typepred "nS`stack_types")
            (("" (split)
              (("1" (propax) nil nil)
               ("2" (skeep) (("2" (inst?) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((popReduce const-decl "estate" reduction nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (> const-decl "bool" reals nil)
    (nonempty_fs type-eq-decl nil finseq_theorems nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (pop const-decl "Stack" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "finseq_theorems[naturalnumbers.nat].tail(typed_reduction.nS`stack_types)"
    "{stypes | booleans.AND(typed_reduction.stypes`length = reduction.popReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_reduction.stypes`length)): typed_reduction.value_of_type(reduction.popReduce(typed_reduction.D)(typed_reduction.nS`state)`stack`seq(i), typed_reduction.stypes`seq(i), typed_reduction.nS`dom_types))}")))
 (typed_reduce_TCC60 0
  (typed_reduce_TCC57-1 nil 3702649677
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil)) nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`redex_type"
    "(typeinfo_adt.popt?)")))
 (typed_reduce_TCC61 0
  (typed_reduce_TCC58-1 nil 3702649677
   ("" (skeep* :preds? t)
    (("" (rewrite value_well_typed)
      (("1" (split)
        (("1" (typepred "nS`redex_type")
          (("1" (expand popRedex?)
            (("1" (flatten)
              (("1" (assert)
                (("1" (expand is_well_typed -)
                  (("1" (flatten) (("1" (grind) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand popReduce)
          (("2" (lift-if)
            (("2" (split)
              (("1" (flatten)
                (("1" (typepred "nS`redex_type")
                  (("1" (expand popRedex?)
                    (("1" (flatten)
                      (("1" (assert)
                        (("1" (expand is_well_typed)
                          (("1" (flatten)
                            (("1" (rewrite value_well_typed) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (expand popRedex?)
                  (("2" (flatten)
                    (("2" (assert)
                      (("2" (typepred "nS`redex_type")
                        (("2" (expand is_well_typed)
                          (("2" (flatten)
                            (("2" (assert)
                              (("2"
                                (case
                                 "variable?(pbody(nS`state`redex))")
                                (("1"
                                  (assert)
                                  (("1"
                                    (expand is_well_typed)
                                    (("1"
                                      (typepred "nS`stack_types")
                                      (("1"
                                        (expand get)
                                        (("1"
                                          (inst? -2)
                                          (("1" (grind) nil nil)
                                           ("2"
                                            (typepred "nS`state`redex")
                                            (("2"
                                              (inst
                                               -2
                                               "index(pbody(nS`state`redex)) - 1")
                                              (("1" (grind) nil nil)
                                               ("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand popReduce)
        (("2" (lift-if)
          (("2" (split)
            (("1" (grind) nil nil)
             ("2" (flatten)
              (("2"
                (typepred "get(nS`state`stack)(pbody(nS`state`redex))")
                (("2" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((value_well_typed formula-decl nil typed_reduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (> const-decl "bool" reals nil)
    (nonempty_fs type-eq-decl nil finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (ptbody adt-accessor-decl "[(popt?) -> typeinfo]" typeinfo_adt nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (Store type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (popRedex? const-decl "bool" IL nil)
    (popReduce const-decl "estate" reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "typeinfo_adt.ptbody(typed_reduction.nS`redex_type)"
    "{tA | typed_reduction.is_well_typed(reduction.popReduce(typed_reduction.D)(typed_reduction.nS`state)`redex, typed_reduction.tA, finseq_theorems[naturalnumbers.nat].tail(typed_reduction.nS`stack_types), typed_reduction.nS`dom_types, typed_reduction.nS`def_types)}")))
 (typed_reduce_TCC62 0
  (typed_reduce_TCC59-1 nil 3702649677
   ("" (skeep* :preds? t)
    (("" (case-replace "popDepth(popReduce(D)(nS`state)`redex) = 0")
      (("1" (expand popReduce +)
        (("1" (typepred "nS`context_type")
          (("1" (case-replace "popDepth(nS`state`redex) = 1")
            (("1"
              (case-replace
               "popn(nS`stack_types, 1) = popn(tail[nat](nS`stack_types), 0)")
              (("1"
                (case-replace
                 "expr_type(nS`redex_type) = expr_type(ptbody(nS`redex_type))")
                (("1" (typepred "nS`redex_type")
                  (("1" (expand popRedex?)
                    (("1" (flatten)
                      (("1" (assert)
                        (("1" (expand is_well_typed -1)
                          (("1" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand tail)
                (("2" (expand popn) (("2" (propax) nil nil)) nil))
                nil))
              nil)
             ("2" (expand popRedex?)
              (("2" (flatten)
                (("2" (assert)
                  (("2" (expand popDepth)
                    (("2" (hide-all-but (1 -6)) (("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand popReduce)
        (("2" (hide-all-but (1 -)) (("2" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (popDepth def-decl "nat" IL nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (popRedex? const-decl "bool" IL nil)
    (popReduce const-decl "estate" reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (nonempty_fs type-eq-decl nil finseq_theorems nil)
    (> const-decl "bool" reals nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (ptbody adt-accessor-decl "[(popt?) -> typeinfo]" typeinfo_adt nil)
    (tS skolem-const-decl
     "{tS | NOT tS`state`error AND defs_well_typed(D, tS`def_types)}"
     typed_reduction nil)
    (D skolem-const-decl "Defs" typed_reduction nil)
    (buildRedex def-decl "{(K, B) | fill(K, B) = A}" IL nil)
    (fill def-decl "IExpression" IL nil)
    (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt
     nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_reduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(reduction.popReduce(typed_reduction.D)(typed_reduction.nS`state)`context, typed_reduction.tK, typed_reduction.popn(finseq_theorems[naturalnumbers.nat].tail(typed_reduction.nS`stack_types), IL.popDepth(reduction.popReduce(typed_reduction.D)(typed_reduction.nS`state)`redex)), typed_reduction.nS`dom_types, typed_reduction.nS`def_types, typed_reduction.expr_type(typeinfo_adt.ptbody(typed_reduction.nS`redex_type)))}")))
 (typed_reduce_defs 0
  (typed_reduce_defs-1 nil 3702745109
   ("" (expand typed_reduce)
    (("" (assert)
      (("" (expand make_redex_typed)
        (("" (expand typed_to_topstate) (("" (propax) nil nil)) nil))
        nil))
      nil))
    nil)
   ((typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (typed_reduce const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (typed_reduce_state_TCC1 0
  (typed_reduce_state_TCC1-1 nil 3702745108 ("" (subtype-tcc) nil nil)
   nil nil
   (typed_reduce_state subtype "typed_reduction.tS`state"
    "goodstate")))
 (typed_reduce_state 0
  (typed_reduce_state-2 "" 3720745278
   ("" (skeep* :preds? t)
    (("" (expand typed_reduce)
      (("" (expand typed_to_topstate)
        (("" (expand make_redex_typed)
          (("" (expand reduce)
            (("" (assert) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (typed_reduce_state-1 nil 3702745146
   ("" (skeep* :preds? t)
    (("" (expand typed_reduce)
      (("" (expand typed_to_topstate)
        (("" (expand make_redex_typed)
          (("" (expand reduce) (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (typed_reduce const-decl "typed_state" typed_reduction nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (value? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (get const-decl "(value?)" IL nil)
    (variableReduce const-decl "estate" reduction nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (push const-decl "Stack" IL nil)
    (letReduce const-decl "estate" reduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (applyReduce const-decl "estate" reduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (ifReduce const-decl "estate" reduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (updateReduce const-decl "estate" reduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (lookupReduce const-decl "estate" reduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (newintReduce const-decl "estate" reduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newrefReduce const-decl "estate" reduction nil)
    (popRedex? const-decl "bool" IL nil)
    (pop const-decl "Stack" IL nil)
    (popReduce const-decl "estate" reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (reduce const-decl "estate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil))
   shostak)))

