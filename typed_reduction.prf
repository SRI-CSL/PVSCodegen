(typed_reduction
 (typeinfo_fill_TCC1 0
  (typeinfo_fill_TCC1-1 nil 3701693785 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[typeinfo_ctx])"
     typed_reduction nil))
   nil))
 (typeinfo_fill_TCC2 0
  (typeinfo_fill_TCC2-1 nil 3701693785 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[typeinfo_ctx])"
     typed_reduction nil))
   nil))
 (expr_type_TCC1 0
  (expr_type_TCC1-1 nil 3701611420 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[typeinfo])" typeinfo_adt
     nil))
   nil))
 (expr_type_TCC2 0
  (expr_type_TCC2-1 nil 3701611420 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[typeinfo])" typeinfo_adt
     nil))
   nil))
 (expr_type_TCC3 0
  (expr_type_TCC3-1 nil 3701611420 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[typeinfo])" typeinfo_adt
     nil))
   nil))
 (expr_type_TCC4 0
  (expr_type_TCC4-1 nil 3701611420 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[typeinfo])" typeinfo_adt
     nil))
   nil))
 (tvars_TCC1 0
  (tvars_TCC1-1 nil 3701615503 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (tvars_TCC2 0
  (tvars_TCC2-1 nil 3701615503 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (tvars_TCC3 0
  (tvars_TCC3-1 nil 3701615503 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (tvars_TCC4 0
  (tvars_TCC4-1 nil 3701615503 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (tvars_TCC5 0
  (tvars_TCC5-1 nil 3701615503 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (tvars_TCC6 0
  (tvars_TCC6-1 nil 3701615503 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (tvars_TCC7 0
  (tvars_TCC7-1 nil 3701615503 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (popn_TCC1 0
  (popn_TCC1-1 nil 3701626353 ("" (subtype-tcc) nil nil) nil nil))
 (popn_TCC2 0
  (popn_TCC2-1 nil 3701626353 ("" (subtype-tcc) nil nil) nil nil))
 (popn_popn_TCC1 0
  (popn_popn_TCC1-1 nil 3701697545 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (popn_popn_TCC2 0
  (popn_popn_TCC2-1 nil 3701697545 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (popn const-decl "finseq[nat]" typed_reduction nil))
   nil))
 (popn_popn 0
  (popn_popn-1 nil 3701697545 ("" (grind) nil nil)
   ((popn const-decl "finseq[nat]" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (popn_zero_TCC1 0
  (popn_zero_TCC1-1 nil 3701790265 ("" (subtype-tcc) nil nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (popn_zero 0
  (popn_zero-1 nil 3701790265 ("" (grind-with-ext) nil nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil))
   shostak))
 (add_append 0
  (add_append-1 nil 3702735873
   ("" (skeep)
    (("" (decompose-equality)
      (("1" (grind) nil nil)
       ("2" (decompose-equality)
        (("2" (expand* o add)
          (("2" (lift-if)
            (("2" (simplify)
              (("2" (lift-if) (("2" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((O const-decl "finseq" finite_sequences nil)
    (seq type-eq-decl nil more_finseq nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (< const-decl "bool" reals nil))
   shostak))
 (popn_append_TCC1 0
  (popn_append_TCC1-1 nil 3702735872 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (O const-decl "finseq" finite_sequences nil))
   nil))
 (popn_append 0
  (popn_append-1 nil 3702736020
   ("" (skeep*)
    (("" (decompose-equality)
      (("1" (grind) nil nil)
       ("2" (decompose-equality)
        (("2" (expand o)
          (("2" (expand popn) (("2" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (O const-decl "finseq" finite_sequences nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (< const-decl "bool" reals nil))
   shostak))
 (is_well_typed_TCC1 0
  (is_well_typed_TCC1-1 nil 3701611553
   ("" (skeep :preds? t) (("" (grind) nil nil)) nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil) nil
    (contextPure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_TCC2 0
  (is_well_typed_TCC2-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (grind) nil nil)
       ("2" (skeep) (("2" (inst -4 i) (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   (nil (contextPure? def-decl "bool" IL nil) nil
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/"))
   nil))
 (is_well_typed_TCC3 0
  (is_well_typed_TCC3-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (lemma pure_contextPure)
      (("" (inst -1 body) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((pure_contextPure formula-decl nil IL nil)
    (contextPure? def-decl "bool" IL nil) nil
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (IExpression type-decl nil IExpression_adt nil))
   nil))
 (is_well_typed_TCC4 0
  (is_well_typed_TCC4-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (lemma pure_contextPure)
      (("" (split)
        (("1" (rewrite purePopDepth)
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
         ("2" (skeep)
          (("2" (inst -5 "i-1")
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((pure_contextPure formula-decl nil IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (contextPure? def-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil))
   nil))
 (is_well_typed_TCC5 0
  (is_well_typed_TCC5-1 nil 3701611553
   ("" (skeep :preds? t) (("" (grind) nil nil)) nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil) nil
    (contextPure? def-decl "bool" IL nil) nil)
   nil))
 (is_well_typed_TCC6 0
  (is_well_typed_TCC6-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
       ("2" (skeep :preds? t)
        (("2" (inst -5 "i-1+popDepth(letrhs(A))")
          (("1" (grind) (("1" (rewrite cvars_pure) nil nil)) nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil) nil
    (add const-decl "finseq[T]" more_finseq nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (contextPure? def-decl "bool" IL nil) nil
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil nil
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (cvars_pure formula-decl nil preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (is_well_typed_TCC7 0
  (is_well_typed_TCC7-1 nil 3701611553
   ("" (skeep :preds? t) (("" (grind) nil nil)) nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil) nil
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil) nil)
   nil))
 (is_well_typed_TCC8 0
  (is_well_typed_TCC8-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (grind) nil nil)
       ("2" (skeep) (("2" (inst -4 "i+1") (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil (contextPure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_TCC9 0
  (is_well_typed_TCC9-1 nil 3701611553 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil) nil
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil))
 (is_well_typed_TCC10 0
  (is_well_typed_TCC10-1 nil 3701611553 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil) nil
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (is_well_typed_TCC11 0
  (is_well_typed_TCC11-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (grind) nil nil) ("2" (skeep) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil) nil
    (contextPure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_TCC12 0
  (is_well_typed_TCC12-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (grind) nil nil) ("2" (skeep) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   (nil (contextPure? def-decl "bool" IL nil) nil
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (is_well_typed_TCC13 0
  (is_well_typed_TCC13-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (grind) nil nil)
       ("2" (skeep) (("2" (inst -4 i) (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil) nil
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil) nil)
   nil))
 (is_well_typed_TCC14 0
  (is_well_typed_TCC14-1 nil 3701611553 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil) nil
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (singleton const-decl "(singleton?)" sets nil) nil
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (is_well_typed_TCC15 0
  (is_well_typed_TCC15-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (inst -3 index) (("" (grind) nil nil)) nil)) nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (contextPure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_TCC16 0
  (is_well_typed_TCC16-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   (nil
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (contextPure? def-decl "bool" IL nil) nil nil
    (singleton const-decl "(singleton?)" sets nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil))
   nil))
 (is_well_typed_TCC17 0
  (is_well_typed_TCC17-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil) nil nil
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil) nil)
   nil))
 (is_well_typed_TCC18 0
  (is_well_typed_TCC18-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (lemma pure_contextPure (A texpr)) (("" (grind) nil nil))
      nil))
    nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (pure_contextPure formula-decl nil IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil) nil nil
    (contextPure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_TCC19 0
  (is_well_typed_TCC19-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (rewrite cvars_pure)
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil) nil nil nil
    (contextPure? def-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (cvars_pure formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (is_well_typed_TCC20 0
  (is_well_typed_TCC20-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (rewrite cvars_pure)
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((purePopDepth formula-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    nil nil (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil) nil
    (pure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_TCC21 0
  (is_well_typed_TCC21-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (lemma pure_contextPure (A eexpr)) (("" (grind) nil nil))
      nil))
    nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (pure_contextPure formula-decl nil IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil) nil nil
    (contextPure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_TCC22 0
  (is_well_typed_TCC22-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (rewrite cvars_pure)
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil) nil nil nil
    (contextPure? def-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (cvars_pure formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (is_well_typed_TCC23 0
  (is_well_typed_TCC23-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (rewrite cvars_pure)
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((purePopDepth formula-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    nil nil (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil) nil
    (pure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_TCC24 0
  (is_well_typed_TCC24-1 nil 3701611553
   ("" (skeep* :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (contextPure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_TCC25 0
  (is_well_typed_TCC25-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   (nil
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil) nil nil
    (singleton const-decl "(singleton?)" sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil))
   nil))
 (is_well_typed_TCC26 0
  (is_well_typed_TCC26-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil) nil nil
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil) nil)
   nil))
 (is_well_typed_TCC27 0
  (is_well_typed_TCC27-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((contextPure? def-decl "bool" IL nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (is_well_typed_TCC28 0
  (is_well_typed_TCC28-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   (nil
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    nil nil (singleton const-decl "(singleton?)" sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil))
 (is_well_typed_TCC29 0
  (is_well_typed_TCC29-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil) nil nil
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil) nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil))
 (is_well_typed_TCC30 0
  (is_well_typed_TCC30-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((contextPure? def-decl "bool" IL nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (is_well_typed_TCC31 0
  (is_well_typed_TCC31-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   (nil
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil) nil nil
    (singleton const-decl "(singleton?)" sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (is_well_typed_TCC32 0
  (is_well_typed_TCC32-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil) nil nil
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil) nil)
   nil))
 (is_well_typed_TCC33 0
  (is_well_typed_TCC33-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((contextPure? def-decl "bool" IL nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (is_well_typed_TCC34 0
  (is_well_typed_TCC34-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   (nil
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil) nil nil
    (singleton const-decl "(singleton?)" sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (is_well_typed_TCC35 0
  (is_well_typed_TCC35-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil) nil nil
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil) nil)
   nil))
 (is_well_typed_TCC36 0
  (is_well_typed_TCC36-1 nil 3701611553 ("" (termination-tcc) nil nil)
   ((contextPure? def-decl "bool" IL nil)) nil))
 (is_well_typed_TCC37 0
  (is_well_typed_TCC37-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (is_well_typed_TCC38 0
  (is_well_typed_TCC38-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   (nil
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil) nil nil
    (singleton const-decl "(singleton?)" sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (is_well_typed_TCC39 0
  (is_well_typed_TCC39-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil) nil nil
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil) nil)
   nil))
 (is_well_typed_TCC40 0
  (is_well_typed_TCC40-1 nil 3701611553 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil) nil
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) nil
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (in_varlist const-decl "finite_set[nat]" IL nil) nil
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil))
   nil))
 (is_well_typed_TCC41 0
  (is_well_typed_TCC41-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (skeep :preds? t)
      (("" (split)
        (("1" (grind) nil nil)
         ("2" (skeep)
          (("2" (inst -5 "index(nth(args, i))")
            (("2" (grind)
              (("2" (rewrite some_nth) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (is_well_typed_TCC42 0
  (is_well_typed_TCC42-1 nil 3701611553
   ("" (skeep :preds? t)
    (("" (skeep)
      (("" (split)
        (("1" (grind) nil nil)
         ("2" (skeep)
          (("2" (replace -10)
            (("2" (inst -4 "i_1")
              (("2" (split -4)
                (("1" (propax) nil nil)
                 ("2" (expand cvars)
                  (("2" (expand vars)
                    (("2" (expand in_varlist)
                      (("2" (rewrite some_nth) (("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (contextPure? def-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (singleton const-decl "(singleton?)" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (= const-decl "[T, T -> boolean]" equalities nil) nil
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (in_varlist const-decl "finite_set[nat]" IL nil) nil nil nil)
   nil))
 (is_well_typed_TCC43 0
  (is_well_typed_TCC43-1 nil 3701626353
   ("" (skeep :preds? t)
    (("" (skeep)
      (("" (replace -9)
        (("" (expand <<)
          (("" (rewrite some_nth) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (contextPure? def-decl "bool" IL nil) nil nil nil
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil) nil
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (some_nth formula-decl nil finseq_theorems nil))
   nil))
 (is_well_typed_dom 0
  (is_well_typed_dom-1 nil 3702667920
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil)
     ("5" (skeep* :preds? t)
      (("5" (expand is_well_typed +)
        (("5" (case "lett?(tA)")
          (("1" (assert)
            (("1" (inst? -4)
              (("1" (inst -4 "dom_types2")
                (("1" (split -4)
                  (("1" (inst? -5)
                    (("1" (inst -5 dom_types2)
                      (("1" (split -5)
                        (("1" (grind) nil nil)
                         ("2" (use pure_contextPure)
                          (("2" (grind) nil nil)) nil)
                         ("3" (skeep)
                          (("3" (use pure_refs) (("3" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (split)
                      (("1" (rewrite purePopDepth)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil)
                       ("2" (skeep)
                        (("2" (rewrite cvars_pure)
                          (("1" (expand cvars -)
                            (("1"
                              (inst -5 "i-1+popDepth(letexpr1_var)")
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil)
                     ("3" (grind) nil nil))
                    nil)
                   ("2" (grind) nil nil) ("3" (grind) nil nil))
                  nil))
                nil)
               ("2" (split)
                (("1" (grind) nil nil)
                 ("2" (skeep) (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("6" (skeep* :preds? t)
      (("6" (expand is_well_typed +)
        (("6" (case "iftt?(tA)")
          (("1" (inst? -5)
            (("1" (inst -5 dom_types2)
              (("1" (inst? -6)
                (("1" (inst -6 dom_types2)
                  (("1" (inst? -7)
                    (("1" (inst -7 dom_types2)
                      (("1" (split -5)
                        (("1" (split -6)
                          (("1" (split -7)
                            (("1" (grind) nil nil)
                             ("2" (use pure_contextPure)
                              (("2" (grind) nil nil)) nil)
                             ("3" (skeep)
                              (("3"
                                (use pure_refs)
                                (("3" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (use pure_contextPure)
                            (("2" (grind) nil nil)) nil)
                           ("3" (skeep)
                            (("3" (use pure_refs)
                              (("3" (grind) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil) ("3" (grind) nil nil))
                        nil))
                      nil)
                     ("2" (split)
                      (("1" (rewrite purePopDepth)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil)
                       ("2" (expand cvars -)
                        (("2" (expand vars -)
                          (("2" (skeep)
                            (("2" (rewrite cvars_pure)
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (split)
                  (("1" (rewrite purePopDepth)
                    (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
                   ("2" (skeep)
                    (("2" (rewrite cvars_pure)
                      (("1" (expand cvars -) (("1" (grind) nil nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand cvars -3)
              (("2" (expand vars -3)
                (("2" (expand add)
                  (("2" (expand union)
                    (("2" (expand member)
                      (("2" (split)
                        (("1" (grind) nil nil)
                         ("2" (skeep) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)
     ("10" (grind) nil nil)
     ("11" (skeep* :preds? t)
      (("11" (expand is_well_typed +)
        (("11" (case "popt?(tA)")
          (("1" (assert)
            (("1" (inst -4 "ptbody(tA)" _ _ _ _)
              (("1" (inst? -4)
                (("1" (split -4)
                  (("1" (propax) nil nil) ("2" (grind) nil nil)
                   ("3" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("12" (grind) nil nil)
     ("13" (skeep* :preds? t)
      (("13" (expand is_well_typed +)
        (("13" (inst? -5)
          (("13" (split -5)
            (("1" (propax) nil nil) ("2" (grind) nil nil)
             ("3" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (emptyset const-decl "set" sets nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (ptbody adt-accessor-decl "[(popt?) -> typeinfo]" typeinfo_adt nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (iftt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (singleton const-decl "(singleton?)" sets nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (add const-decl "(nonempty?)" sets nil)
    (telse adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (tthen adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    nil
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaft adt-constructor-decl "[nat -> (leaft?)]" typeinfo_adt nil)
    nil nil nil
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    nil
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    nil
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    nil nil
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (purePopDepth formula-decl nil IL nil)
    (cvars_pure formula-decl nil preprocess nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (pure_refs formula-decl nil IL nil)
    (pure_contextPure formula-decl nil IL nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil) nil
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (seq type-eq-decl nil more_finseq nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (in_varlist const-decl "finite_set[nat]" IL nil) nil
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) nil
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (refs def-decl "bool" IL nil) (contextPure? def-decl "bool" IL nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil) nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) nil
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (letApply_type_TCC1 0
  (letApply_type_TCC1-1 nil 3702672884 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) nil
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (letApply_type_TCC2 0
  (letApply_type_TCC2-1 nil 3702672884 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) nil
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (letApply_type_TCC3 0
  (letApply_type_TCC3-1 nil 3702672884
   ("" (skeep* :preds? t)
    (("" (expand length -) (("" (grind) nil nil)) nil)) nil)
   ((length def-decl "nat" list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (letApply_type_TCC4 0
  (letApply_type_TCC4-1 nil 3702672884 ("" (termination-tcc) nil nil)
   nil nil))
 (is_well_typed_extend_stack_TCC1 0
  (is_well_typed_extend_stack_TCC1-1 nil 3702733169
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (grind) nil nil)
       ("2" (skeep) (("2" (inst?) (("2" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (O const-decl "finseq" finite_sequences nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (is_well_typed_extend_stack 0
  (is_well_typed_extend_stack-1 nil 3702733170
   ("" (induct A)
    (("1" (skeep* :preds? t)
      (("1" (expand is_well_typed)
        (("1" (expand o)
          (("1" (case "variable1_var < stypes`length")
            (("1" (assert) nil nil) ("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (skeep* :preds? t)
      (("4" (expand is_well_typed +)
        (("4" (assert)
          (("4"
            (case "application1_var < def_types`length AND
        tA = leaft(def_types`seq(application1_var)`return_type) AND
         length(application2_var) =
          def_types`seq(application1_var)`args_type`length")
            (("1" (flatten)
              (("1" (assert)
                (("1"
                  (case "forall (i: below(length(application2_var))): is_well_typed(nth(application2_var, i),
                       leaft(def_types`seq(application1_var)`args_type`seq
                                 (i)),
                       stypes2 o stypes, dom_types, def_types) =
         is_well_typed(nth(application2_var, i),
                       leaft(def_types`seq(application1_var)`args_type`seq
                                 (i)),
                       stypes, dom_types, def_types)")
                  (("1" (iff)
                    (("1" (split)
                      (("1" (flatten)
                        (("1" (skeep)
                          (("1" (inst?)
                            (("1" (inst?) (("1" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (skeep)
                          (("2" (inst?)
                            (("2" (inst?) (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (delete 2)
                    (("2" (skeep)
                      (("2" (rewrite every_nth)
                        (("2" (rewrite every_nth)
                          (("1" (inst -8 i)
                            (("1" (inst? -8) (("1" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (delete 2)
                            (("2" (skeep* :preds? t)
                              (("2"
                                (expand o)
                                (("2"
                                  (split)
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (skeep)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (delete 2)
                    (("3" (skeep :preds? t)
                      (("3" (split)
                        (("1" (grind) nil nil)
                         ("2" (skeep)
                          (("2"
                            (case "variable?(nth(application2_var, i))")
                            (("1" (assert)
                              (("1"
                                (expand cvars)
                                (("1"
                                  (expand vars)
                                  (("1"
                                    (expand singleton)
                                    (("1"
                                      (grind)
                                      (("1"
                                        (rewrite some_nth)
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("4" (delete 2)
                    (("4" (skeep)
                      (("4" (split)
                        (("1" (grind) nil nil)
                         ("2" (skeep)
                          (("2" (expand o)
                            (("2"
                              (case "variable?(nth(application2_var, i))")
                              (("1"
                                (assert)
                                (("1"
                                  (expand cvars)
                                  (("1"
                                    (expand vars)
                                    (("1"
                                      (expand singleton)
                                      (("1"
                                        (typepred "stypes")
                                        (("1"
                                          (inst -2 i_1)
                                          (("1"
                                            (expand cvars)
                                            (("1"
                                              (expand vars)
                                              (("1"
                                                (expand in_varlist)
                                                (("1"
                                                  (rewrite some_nth)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("5" (skeep)
                    (("5" (case "variable?(nth(application2_var, i))")
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep* :preds? t)
      (("5" (expand is_well_typed +)
        (("5" (case "lett?(tA)")
          (("1" (assert)
            (("1" (inst? -4)
              (("1"
                (inst -5 "lbody(tA)" "add(lettype(tA),
                            popn(stypes, popDepth(letexpr1_var)))"
                 stypes2 dom_types def_types)
                (("1" (rewrite add_append)
                  (("1" (rewrite popn_append)
                    (("1" (split -5)
                      (("1" (split -5)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil)
                       ("2" (use pure_contextPure)
                        (("2" (grind) nil nil)) nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (delete 2)
                  (("2" (split)
                    (("1" (rewrite purePopDepth)
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil)
                     ("2" (skeep)
                      (("2" (rewrite cvars_pure)
                        (("1" (inst -4 "i-1+popDepth(letexpr1_var)")
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (grind) nil nil))
                nil)
               ("2" (delete 2)
                (("2" (split)
                  (("1" (grind) nil nil)
                   ("2" (skeep) (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("6" (skeep* :preds? t)
      (("6" (expand is_well_typed +)
        (("6" (case "iftt?(tA)")
          (("1" (assert)
            (("1" (inst? -5)
              (("1" (inst? -6)
                (("1" (inst? -7)
                  (("1" (split -7)
                    (("1" (split -7)
                      (("1" (split -7)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil)
                       ("2" (use pure_contextPure)
                        (("2" (grind) nil nil)) nil))
                      nil)
                     ("2" (use pure_contextPure)
                      (("2" (grind) nil nil)) nil))
                    nil)
                   ("2" (delete 2)
                    (("2" (split)
                      (("1" (rewrite purePopDepth)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil)
                       ("2" (skeep)
                        (("2" (inst?)
                          (("2" (rewrite cvars_pure)
                            (("1" (grind) nil nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete 2)
                  (("2" (split)
                    (("1" (rewrite purePopDepth)
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil)
                     ("2" (skeep)
                      (("2" (rewrite cvars_pure)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (delete 2)
                (("2" (split)
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand is_well_typed +)
        (("7" (case "leaft?(tA) AND leaftype(tA) > 0")
          (("1" (assert)
            (("1" (flatten)
              (("1" (assert)
                (("1" (inst? -8)
                  (("1" (inst? -9)
                    (("1" (inst? -10)
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil)
                     ("2" (delete 2) (("2" (grind) nil nil)) nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("8" (skeep* :preds? t)
      (("8" (expand is_well_typed +)
        (("8" (case "leaft?(tA)")
          (("1" (assert)
            (("1" (inst? -6)
              (("1" (inst? -7)
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
               ("2" (grind) nil nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (skeep* :preds? t)
      (("11" (expand is_well_typed +)
        (("11" (case "popt?(tA)")
          (("1" (assert) (("1" (inst? -4) (("1" (grind) nil nil)) nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("12" (grind) nil nil)
     ("13" (skeep* :preds? t)
      (("13" (expand is_well_typed +)
        (("13" (inst? -5) (("13" (grind) nil nil)) nil)) nil))
      nil)
     ("14" (delete 2)
      (("14" (skeep* :preds? t)
        (("14" (expand o)
          (("14" (split)
            (("1" (grind) nil nil)
             ("2" (skeep) (("2" (inst?) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((O const-decl "finseq" finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (< const-decl "bool" reals nil) nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) nil
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil (singleton const-decl "(singleton?)" sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaft adt-constructor-decl "[nat -> (leaft?)]" typeinfo_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil) nil
    (length def-decl "nat" list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (every_nth formula-decl nil list_props nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil) nil
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (seq type-eq-decl nil more_finseq nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (popn_append formula-decl nil typed_reduction nil)
    (pure_contextPure formula-decl nil IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (add_append formula-decl nil typed_reduction nil)
    (purePopDepth formula-decl nil IL nil)
    (cvars_pure formula-decl nil preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil) nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    nil nil
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    nil
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (tthen adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (telse adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    nil nil nil
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    nil
    (iftt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (emptyset const-decl "set" sets nil) nil nil nil
    (update adt-constructor-decl
     "[[(variable?), (variable?), (variable?)] -> (update?)]"
     IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    nil
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (> const-decl "bool" reals nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    nil nil
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    nil
    (ptbody adt-accessor-decl "[(popt?) -> typeinfo]" typeinfo_adt nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil))
   shostak))
 (is_well_typed_letApply_TCC1 0
  (is_well_typed_letApply_TCC1-1 nil 3702730461
   ("" (subtype-tcc) nil nil)
   ((in_varlist const-decl "finite_set[nat]" IL nil)) nil))
 (is_well_typed_letApply_TCC2 0
  (is_well_typed_letApply_TCC2-1 nil 3702730461
   ("" (skeep* :preds? t) (("" (grind) nil nil)) nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (contextPure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_letApply_TCC3 0
  (is_well_typed_letApply_TCC3-1 nil 3702730461
   ("" (subtype-tcc) nil nil)
   ((in_varlist const-decl "finite_set[nat]" IL nil)) nil))
 (is_well_typed_letApply_TCC4 0
  (is_well_typed_letApply_TCC4-1 nil 3702730461
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (rewrite cvars_pure)
          (("1" (inst -8 i_1)
            (("1" (split -8)
              (("1" (propax) nil nil)
               ("2" (expand in_varlist)
                (("2" (rewrite some_nth) (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((pure? def-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    nil (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (cvars_pure formula-decl nil preprocess nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (singleton const-decl "(singleton?)" sets nil) nil
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (in_varlist const-decl "finite_set[nat]" IL nil))
   nil))
 (is_well_typed_letApply_TCC5 0
  (is_well_typed_letApply_TCC5-1 nil 3702730461
   ("" (skeep* :preds? t)
    (("" (use pure_contextPure) (("" (grind) nil nil)) nil)) nil)
   ((pure_contextPure formula-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil))
   nil))
 (is_well_typed_letApply_TCC6 0
  (is_well_typed_letApply_TCC6-1 nil 3702730461
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth) (("1" (grind) nil nil)) nil)
       ("2" (skeep) (("2" (inst -9 i) (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((list2finseq const-decl "finseq[T]" list2finseq nil)
    (O const-decl "finseq" finite_sequences nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (is_well_typed_letApply_TCC7 0
  (is_well_typed_letApply_TCC7-1 nil 3702730461
   ("" (skeep* :preds? t)
    (("" (use pure_contextPure)
      (("" (use pure_letApply) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((pure_contextPure formula-decl nil IL nil)
    (letApply def-decl "IExpression" reduction nil)
    (length def-decl "nat" list_props nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    nil (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) nil
    (pure_letApply recursive-judgement-axiom nil reduction nil))
   nil))
 (is_well_typed_letApply_TCC8 0
  (is_well_typed_letApply_TCC8-1 nil 3702730461
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth)
        (("1" (grind) nil nil) ("2" (use pure_letApply) nil nil)) nil)
       ("2" (skeep)
        (("2" (rewrite cvars_pure)
          (("1" (rewrite vars_letApply)
            (("1" (inst -8 "i + arity")
              (("1" (inst -9 i)
                (("1" (rewrite cvars_pure) (("1" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (use pure_letApply) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((pure? def-decl "bool" IL nil)
    (pure_letApply recursive-judgement-axiom nil reduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (letApply def-decl "IExpression" reduction nil)
    (length def-decl "nat" list_props nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    nil (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (cvars_pure formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (vars_letApply formula-decl nil reduction nil))
   nil))
 (is_well_typed_letApply 0
  (is_well_typed_letApply-1 nil 3702730461
   ("" (induct arity)
    (("1" (skeep* :preds? t)
      (("1" (expand letApply)
        (("1" (expand letApply_type)
          (("1"
            (case-replace
             "stypes o list2finseq[nat](args_type) = stypes")
            (("1" (lemma is_well_typed_dom)
              (("1" (inst?)
                (("1" (inst -1 dom_types)
                  (("1" (split -1)
                    (("1" (grind) nil nil)
                     ("2" (use pure_contextPure)
                      (("2" (grind) nil nil)) nil)
                     ("3" (skeep)
                      (("3" (use pure_refs) (("3" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (delete 2)
              (("2" (decompose-equality)
                (("1" (grind) nil nil)
                 ("2" (decompose-equality) (("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skeep* :preds? t)
      (("2" (expand letApply +)
        (("2" (expand letApply_type +)
          (("2" (expand is_well_typed +)
            (("2" (split)
              (("1" (inst -10 0) (("1" (grind) nil nil)) nil)
               ("2" (expand expr_type) (("2" (propax) nil nil)) nil)
               ("3" (inst? -6)
                (("3" (split -6)
                  (("1" (propax) nil nil) ("2" (propax) nil nil)
                   ("3" (delete 2)
                    (("3" (expand add +)
                      (("3" (expand popn +)
                        (("3" (case-replace "popDepth(car(args)) = 0")
                          (("1" (assert) nil nil) ("2" (grind) nil nil)
                           ("3" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("4" (delete 2)
                    (("4" (skeep*)
                      (("4" (case "in_varlist(args)(i-1)")
                        (("1" (expand add)
                          (("1" (expand popn)
                            (("1"
                              (case-replace "popDepth(car(args)) = 0")
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand in_varlist)
                          (("2" (rewrite some_map)
                            (("2" (expand o)
                              (("2"
                                (case-replace
                                 "(lambda (v: (variable?)): index(v) = i - 1) = (LAMBDA (x_1: (variable?)): 1 + index(x_1) = i)")
                                (("1"
                                  (expand some +)
                                  (("1"
                                    (lift-if)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (apply-extensionality)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("3" (grind) nil nil))
                        nil))
                      nil))
                    nil)
                   ("5" (delete 2)
                    (("5" (skeep :preds? t)
                      (("5" (rewrite map_nth_rw)
                        (("1"
                          (case-replace
                           "nth(cdr(args), i) = nth(args, i + 1)")
                          (("1"
                            (case-replace
                             "nth(cdr(args_type), i) = nth(args_type, i+1)")
                            (("1"
                              (case-replace "popDepth(car(args)) = 0")
                              (("1"
                                (assert)
                                (("1"
                                  (expand is_well_typed +)
                                  (("1"
                                    (inst -13 "1+i")
                                    (("1"
                                      (expand is_well_typed -13)
                                      (("1"
                                        (expand add +)
                                        (("1" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil)
                             ("2" (expand nth 1 2)
                              (("2" (propax) nil nil)) nil))
                            nil)
                           ("2" (expand nth 1 2)
                            (("2" (propax) nil nil)) nil))
                          nil)
                         ("2" (expand length -3)
                          (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("6" (case-replace "popDepth(car(args)) = 0")
                    (("1" (assert)
                      (("1"
                        (case-replace
                         "stypes o list2finseq[nat](args_type) = add(car(args_type), stypes) o
                     list2finseq[nat](cdr(args_type))")
                        (("1" (delete 2)
                          (("1" (delete 2)
                            (("1" (decompose-equality)
                              (("1"
                                (grind)
                                (("1"
                                  (grind)
                                  (("1"
                                    (expand length -4)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (expand length -4)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (decompose-equality)
                                (("2"
                                  (expand o)
                                  (("2"
                                    (expand add)
                                    (("2"
                                      (lift-if)
                                      (("2"
                                        (lift-if)
                                        (("2"
                                          (lift-if)
                                          (("2"
                                            (assert)
                                            (("2"
                                              (expand list2finseq)
                                              (("2"
                                                (expand nth 1 2)
                                                (("2"
                                                  (ground)
                                                  (("2"
                                                    (case-replace
                                                     "x!1 = stypes`length")
                                                    (("1"
                                                      (expand nth)
                                                      (("1"
                                                        (propax)
                                                        nil
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (delete 2)
      (("3" (skeep :preds? t)
        (("3" (split)
          (("1" (rewrite popdepth_letApply)
            (("1" (rewrite purePopDepth)
              (("1" (rewrite purePopDepth)
                (("1" (grind) nil nil) ("2" (grind) nil nil)
                 ("3" (grind) nil nil))
                nil))
              nil))
            nil)
           ("2" (skeep)
            (("2" (rewrite cvars_pure)
              (("1" (rewrite vars_letApply)
                (("1" (inst -8 "arity + i")
                  (("1" (inst -9 i)
                    (("1" (rewrite cvars_pure) (("1" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (use pure_letApply) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (delete 2)
      (("4" (skeep* :preds? t)
        (("4" (use pure_contextPure)
          (("4" (use pure_letApply) (("4" (grind) nil nil)) nil)) nil))
        nil))
      nil)
     ("5" (delete 2)
      (("5" (skeep* :preds? t)
        (("5" (split)
          (("1" (rewrite purePopDepth) (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("6" (delete 2)
      (("6" (skeep* :preds? t)
        (("6" (use pure_contextPure) (("6" (grind) nil nil)) nil))
        nil))
      nil)
     ("7" (delete 2)
      (("7" (skeep* :preds? t)
        (("7" (split)
          (("1" (rewrite purePopDepth)
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
           ("2" (skeep)
            (("2" (rewrite cvars_pure)
              (("1" (inst -8 i_1)
                (("1" (split -8)
                  (("1" (propax) nil nil)
                   ("2" (expand in_varlist)
                    (("2" (rewrite some_nth)
                      (("2" (inst 1 i1) (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (delete 2)
      (("8" (skeep* :preds? t) (("8" (grind) nil nil)) nil)) nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nth def-decl "T" list_props nil)
    (contextPure? def-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (pure? def-decl "bool" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil) nil
    (< const-decl "bool" reals nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    nil (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil) nil
    (<= const-decl "bool" reals nil)
    (leaft adt-constructor-decl "[nat -> (leaft?)]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (O const-decl "finseq" finite_sequences nil)
    (letApply def-decl "IExpression" reduction nil)
    (pred type-eq-decl nil defined_types nil)
    (letApply_type def-decl "typeinfo" typed_reduction nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pure_contextPure formula-decl nil IL nil)
    (pure_refs formula-decl nil IL nil)
    (is_well_typed_dom formula-decl nil typed_reduction nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    nil (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (seq type-eq-decl nil more_finseq nil)
    (map_nth_rw formula-decl nil more_map_props nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (TRUE const-decl "bool" booleans nil)
    (some_map formula-decl nil finseq_theorems nil)
    (int_plus_int_is_int application-judgement "int" integers nil) nil
    (O const-decl "T3" function_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (pure_letApply recursive-judgement-axiom nil reduction nil)
    (vars_letApply formula-decl nil reduction nil)
    (cvars_pure formula-decl nil preprocess nil)
    (popdepth_letApply formula-decl nil reduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (purePopDepth formula-decl nil IL nil) nil
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (singleton const-decl "(singleton?)" sets nil) nil
    (some_nth formula-decl nil finseq_theorems nil))
   shostak))
 (letApply_expr_type 0
  (letApply_expr_type-1 nil 3702738102
   ("" (induct arity) (("1" (grind) nil nil) ("2" (grind) nil nil))
    nil)
   ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (letApply_type def-decl "typeinfo" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (is_well_typed_ctx_TCC1 0
  (is_well_typed_ctx_TCC1-1 nil 3701633858
   ("" (skeep :preds? t) (("" (grind) nil nil)) nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil) nil
    (cpure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_ctx_TCC2 0
  (is_well_typed_ctx_TCC2-1 nil 3701633858
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (grind) nil nil) ("2" (skeep) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   (nil (cpure? def-decl "bool" IL nil) nil
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   nil))
 (is_well_typed_ctx_TCC3 0
  (is_well_typed_ctx_TCC3-1 nil 3701633858
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil) nil
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IContext])" IL nil))
   nil))
 (is_well_typed_ctx_TCC4 0
  (is_well_typed_ctx_TCC4-1 nil 3701633858
   ("" (skeep :preds? t)
    (("" (use pure_contextPure) (("" (grind) nil nil)) nil)) nil)
   ((pure_contextPure formula-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil) (cpure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_ctx_TCC5 0
  (is_well_typed_ctx_TCC5-1 nil 3701633858 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil) nil
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (is_well_typed_ctx_TCC6 0
  (is_well_typed_ctx_TCC6-1 nil 3701633858 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil) nil
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (is_well_typed_ctx_TCC7 0
  (is_well_typed_ctx_TCC7-1 nil 3701633858
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (inst -4 "i - 1 + popDepth(letcrhs(K))")
          (("1" (grind) (("1" (rewrite cvars_pure) nil nil)) nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil) nil
    (add const-decl "finseq[T]" more_finseq nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) nil
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil) nil nil
    (letcrhs adt-accessor-decl "[(letc?) -> IContext]" IL nil)
    (letc? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (IContext type-decl nil IL nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (cvars_pure formula-decl nil preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (is_well_typed_ctx_TCC8 0
  (is_well_typed_ctx_TCC8-1 nil 3701633858 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil) nil
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil))
 (is_well_typed_ctx_TCC9 0
  (is_well_typed_ctx_TCC9-1 nil 3701633858
   ("" (skeep :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    nil (cpure? def-decl "bool" IL nil) nil
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (is_well_typed_ctx_TCC10 0
  (is_well_typed_ctx_TCC10-1 nil 3701633858
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil) nil
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (<< adt-def-decl "(strict_well_founded?[IContext])" IL nil))
   nil))
 (is_well_typed_ctx_dom 0
  (is_well_typed_ctx_dom-1 nil 3702669372
   ("" (induct K)
    (("1" (grind) nil nil)
     ("2" (skeep* :preds? t)
      (("2" (expand is_well_typed_ctx +)
        (("2" (case "letct?(tK)")
          (("1" (inst? -5)
            (("1" (inst -5 dom_types2)
              (("1" (split -5)
                (("1" (lemma is_well_typed_dom)
                  (("1"
                    (inst -1 letc2_var "lcbody(tK)" "add(letctype(tK),
                            popn(stypes, popDepth(letc1_var)))"
                     dom_types dom_types2 def_types)
                    (("1" (split -1)
                      (("1" (grind) nil nil)
                       ("2" (use pure_contextPure)
                        (("2" (grind) nil nil)) nil)
                       ("3" (skeep)
                        (("3" (use pure_refs) (("3" (grind) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (split)
                      (("1" (rewrite purePopDepth)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil)
                       ("2" (skeep)
                        (("2" (rewrite cvars_pure)
                          (("1" (expand cvars -)
                            (("1" (inst -5 "i-1+popDepth(letc1_var)")
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil)
                     ("3" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil)
             ("2" (split)
              (("1" (grind) nil nil)
               ("2" (skeep) (("2" (grind) nil nil)) nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("3" (skeep* :preds? t)
      (("3" (expand is_well_typed_ctx +)
        (("3" (inst? -4)
          (("1" (inst -4 dom_types2) (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil) ("3" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((popct? adt-recognizer-decl "[typeinfo_ctx -> boolean]"
     typed_reduction nil)
    nil nil (popc? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (popc adt-constructor-decl "[IContext -> (popc?)]" IL nil) nil
    (pctbody adt-accessor-decl "[(popct?) -> typeinfo_ctx]"
     typed_reduction nil)
    (letct? adt-recognizer-decl "[typeinfo_ctx -> boolean]"
     typed_reduction nil)
    (is_well_typed_dom formula-decl nil typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (purePopDepth formula-decl nil IL nil)
    (cvars_pure formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pure_contextPure formula-decl nil IL nil)
    (pure_refs formula-decl nil IL nil)
    (lcbody adt-accessor-decl "[(letct?) -> typeinfo]" typed_reduction
     nil)
    nil (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (letctype adt-accessor-decl "[(letct?) -> nat]" typed_reduction
     nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (seq type-eq-decl nil more_finseq nil) nil
    (lcrhs adt-accessor-decl "[(letct?) -> typeinfo_ctx]"
     typed_reduction nil)
    nil nil
    (letc adt-constructor-decl "[[IContext, IExpression] -> (letc?)]"
     IL nil)
    (letc? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (IExpression type-decl nil IExpression_adt nil) nil nil
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IContext_induction formula-decl nil IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (< const-decl "bool" reals nil) nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) nil
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   shostak))
 (value_of_type_TCC1 0
  (value_of_type_TCC1-1 nil 3701781238 ("" (cases-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil))
   nil))
 (value_well_typed_TCC1 0
  (value_well_typed_TCC1-1 nil 3701795278 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (contextPure? def-decl "bool" IL nil))
   nil))
 (value_well_typed_TCC2 0
  (value_well_typed_TCC2-1 nil 3701795278 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (emptyset const-decl "set" sets nil) nil nil
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil) nil
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (value_well_typed 0
  (value_well_typed-1 nil 3701795278
   ("" (skeep* :preds? t) (("" (grind-with-ext) nil nil)) nil)
   ((is_well_typed def-decl "bool" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (leaft adt-constructor-decl "[nat -> (leaft?)]" typeinfo_adt nil)
    (typeinfo_leaft_extensionality formula-decl nil typeinfo_adt nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil))
   shostak))
 (typed_state_TCC1 0
  (typed_state_TCC1-1 nil 3701630090
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (typepred "state`redex") (("1" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (typepred "state`redex")
          (("2" (inst -2 "i - popDepth(state`redex)")
            (("1" (split -2)
              (("1" (grind) nil nil)
               ("2" (rewrite cvars_vars) nil nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (typed_state_TCC2 0
  (typed_state_TCC2-1 nil 3701631485
   ("" (with-labels (skeep* :preds? t) ((dmt sttl sttv obj)))
    (("" (split obj)
      (("1" (typepred "state`redex") (("1" (grind) nil nil)) nil)
       ("2"
        (with-labels (typepred "state`redex")
         ((href hvar hcvar hsl hcp)))
        (("2" (skeep)
          (("2" (inst hvar "i-popDepth(state`redex)")
            (("1" (rewrite cvars_vars) (("1" (grind) nil nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (cpure? def-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil) nil
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (cvars_vars formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil) nil
    nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_state_TCC3 0
  (typed_state_TCC3-1 nil 3701631485
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (typepred "state`redex") (("1" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (typepred "state`redex")
          (("2" (inst -3 "i - popDepth(state`context)")
            (("1" (split -3)
              (("1" (grind) nil nil)
               ("2" (rewrite cvars_vars_ctx) (("2" (grind) nil nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_state_TCC4 0
  (typed_state_TCC4-1 nil 3701781238
   ("" (with-labels (skeep* :preds? t) ((dmt sttl sttv obj)))
    (("" (split obj)
      (("1" (typepred "state`redex") (("1" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2"
          (with-labels (typepred "state`redex")
           ((href hvar hcvar hsl hcp)))
          (("2" (inst hcvar "i-popDepth(state`context)")
            (("1" (rewrite cvars_vars_ctx)
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((popn const-decl "finseq[nat]" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (cpure? def-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil) nil
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (cvars_vars_ctx formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil) nil
    nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (fill_type 0
  (fill_type-1 nil 3701697451
   ("" (induct tK)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil))
    nil)
   ((typeinfo_ctx_induction formula-decl nil typed_reduction nil)
    (ctx_type def-decl "nat" typed_reduction nil)
    (typeinfo_fill def-decl "typeinfo" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (typeinfo_ctx type-decl nil typed_reduction nil))
   shostak))
 (fill_well_typed_TCC1 0
  (fill_well_typed_TCC1-1 nil 3701694762 ("" (subtype-tcc) nil nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (fill_well_typed_TCC2 0
  (fill_well_typed_TCC2-1 nil 3701694762 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (fill_well_typed_TCC3 0
  (fill_well_typed_TCC3-1 nil 3701694762
   ("" (skeep)
    (("" (split)
      (("1" (grind) nil nil)
       ("2" (skeep) (("2" (inst -3 i) (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (fill_well_typed_TCC4 0
  (fill_well_typed_TCC4-1 nil 3701694762
   ("" (skeep)
    (("" (rewrite contextPurefill) (("" (grind) nil nil)) nil)) nil)
   ((contextPurefill formula-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IContext type-decl nil IL nil))
   nil))
 (fill_well_typed_TCC5 0
  (fill_well_typed_TCC5-1 nil 3701694762
   ("" (skeep)
    (("" (split)
      (("1" (rewrite popdepth_fill) nil nil)
       ("2" (skeep)
        (("2" (rewrite cvars_fill)
          (("2" (split)
            (("1" (inst -6 "i-popDepth(A)")
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
             ("2" (inst -5 i) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((IContext type-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (popdepth_fill formula-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (cvars_fill formula-decl nil preprocess nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil) nil
    nil nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (fill_well_typed 0
  (fill_well_typed-1 nil 3701695580
   ("" (induct K)
    (("1" (skeep*)
      (("1" (case-replace "tK = holet")
        (("1" (grind) nil nil)
         ("2" (expand is_well_typed_ctx) (("2" (grind) nil nil)) nil))
        nil))
      nil)
     ("2"
      (with-labels (skeep*)
       ((hrec acp kcp sl hvar hcvar hwt hwtc obj)))
      (("2" (expand is_well_typed_ctx hwtc)
        (("2" (with-labels (flatten) ((tklc hwtc ctxt hwt2)))
          (("2" (apply-eta "tK" "(letct?)")
            (("2" (replace -1 :dir RL)
              (("2" (simplify)
                (("2" (expand fill obj)
                  (("2" (expand typeinfo_fill obj)
                    (("2" (expand is_well_typed obj)
                      (("2" (split)
                        (("1" (inst?)
                          (("1" (split hrec)
                            (("1" (propax) nil nil)
                             ("2" (propax) nil nil)
                             ("3" (grind) nil nil)
                             ("4" (grind) nil nil)
                             ("5" (propax) nil nil)
                             ("6" (grind) nil nil)
                             ("7" (propax) nil nil)
                             ("8" (propax) nil nil))
                            nil))
                          nil)
                         ("2" (rewrite fill_type) nil nil)
                         ("3" (rewrite popn_popn)
                          (("1" (rewrite popdepth_fill) nil nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3"
      (with-labels (skeep*)
       ((hrec acp kcp sl hvar hcvar hwl hwlc obj)))
      (("3" (expand is_well_typed_ctx hwlc)
        (("3" (with-labels (flatten) ((kpc hwlc)))
          (("3" (apply-eta "tK" "(popct?)")
            (("3" (replace -1 :dir RL)
              (("3" (simplify)
                (("3" (expand fill obj)
                  (("3" (expand typeinfo_fill obj)
                    (("3" (expand is_well_typed obj)
                      (("3" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (delete 2)
      (("4" (lemma fill_well_typed_TCC5)
        (("4" (skeep) (("4" (inst?) (("4" (prop) nil nil)) nil)) nil))
        nil))
      nil)
     ("5" (lemma fill_well_typed_TCC4)
      (("5" (skeep*) (("5" (inst?) (("5" (prop) nil nil)) nil)) nil))
      nil)
     ("6" (lemma fill_well_typed_TCC3)
      (("6" (skeep*)
        (("6" (inst?) (("6" (inst?) (("6" (prop) nil nil)) nil)) nil))
        nil))
      nil)
     ("7" (lemma fill_well_typed_TCC2)
      (("7" (skeep*)
        (("7" (inst?) (("7" (inst?) (("7" (prop) nil nil)) nil)) nil))
        nil))
      nil)
     ("8" (lemma fill_well_typed_TCC1)
      (("8" (skeep*) (("8" (inst?) (("8" (prop) nil nil)) nil)) nil))
      nil))
    nil)
   ((fill_well_typed_TCC1 subtype-tcc nil typed_reduction nil)
    (fill_well_typed_TCC2 subtype-tcc nil typed_reduction nil)
    (fill_well_typed_TCC3 subtype-tcc nil typed_reduction nil)
    (fill_well_typed_TCC4 subtype-tcc nil typed_reduction nil)
    (fill_well_typed_TCC5 subtype-tcc nil typed_reduction nil)
    (pctbody adt-accessor-decl "[(popct?) -> typeinfo_ctx]"
     typed_reduction nil)
    (popct? adt-recognizer-decl "[typeinfo_ctx -> boolean]"
     typed_reduction nil)
    (typeinfo_ctx_popct_eta formula-decl nil typed_reduction nil)
    (popn_popn formula-decl nil typed_reduction nil)
    (popdepth_fill formula-decl nil IL nil)
    (fill_type formula-decl nil typed_reduction nil)
    (lcrhs adt-accessor-decl "[(letct?) -> typeinfo_ctx]"
     typed_reduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (letct? adt-recognizer-decl "[typeinfo_ctx -> boolean]"
     typed_reduction nil)
    (typeinfo_ctx_letct_eta formula-decl nil typed_reduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (holet? adt-recognizer-decl "[typeinfo_ctx -> boolean]"
     typed_reduction nil)
    (holet adt-constructor-decl "(holet?)" typed_reduction nil)
    (IContext_induction formula-decl nil IL nil)
    (typeinfo_fill def-decl "typeinfo" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (fill def-decl "IExpression" IL nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (IContext type-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil (<= const-decl "bool" reals nil) nil
    (cpure? def-decl "bool" IL nil)
    (contextPure? def-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (typed_to_topstate_TCC1 0
  (typed_to_topstate_TCC1-1 nil 3701694762
   ("" (skeep* :preds? t)
    (("" (typepred "tS`dom_types") (("" (grind) nil nil)) nil)) nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil) nil nil
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil) nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) nil
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil) nil
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil (Store type-eq-decl nil reduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (topstate type-eq-decl nil reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (typed_to_topstate_TCC2 0
  (typed_to_topstate_TCC2-1 nil 3701694762
   ("" (skeep)
    (("" (typepred "tS`stack_types")
      (("" (expand to_topstate)
        (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil) nil nil
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil) nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) nil
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (to_topstate const-decl "topstate" reduction nil))
   nil))
 (typed_to_topstate_TCC3 0
  (typed_to_topstate_TCC3-1 nil 3701694762
   ("" (with-labels (skeep) ((obj)))
    (("" (expand to_topstate)
      ((""
        (with-labels (typepred "tS`state`redex")
         ((href hvar hcvar hsl hcp)))
        (("" (use fill_well_typed)
          (("" (split -1)
            (("1" (propax) nil nil) ("2" (propax) nil nil)
             ("3" (typepred "tS`state`context")
              (("3" (propax) nil nil)) nil)
             ("4" (typepred "tS`stack_types") (("4" (grind) nil nil))
              nil)
             ("5" (typepred "tS`stack_types")
              (("5" (skeep)
                (("5" (inst hvar "i-popDepth(tS`state`redex)")
                  (("1" (rewrite cvars_vars) (("1" (grind) nil nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil)
             ("6" (typepred "tS`stack_types")
              (("6" (skeep)
                (("6" (inst hcvar "i-popDepth(tS`state`context)")
                  (("1" (rewrite cvars_vars_ctx)
                    (("1" (grind) nil nil)) nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil)
             ("7" (typepred "tS`redex_type") (("7" (propax) nil nil))
              nil)
             ("8" (typepred "tS`context_type") (("8" (propax) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((to_topstate const-decl "topstate" reduction nil)
    (fill_well_typed formula-decl nil typed_reduction nil) nil
    (cvars_vars_ctx formula-decl nil preprocess nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cvars_vars formula-decl nil preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) nil
    nil (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil) nil
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_to_topstate_TCC4 0
  (typed_to_topstate_TCC4-1 nil 3701694762
   ("" (skeep :preds? t)
    (("" (expand to_topstate) (("" (grind) nil nil)) nil)) nil)
   ((to_topstate const-decl "topstate" reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (buildRedexType_TCC1 0
  (buildRedexType_TCC1-1 nil 3701699428 ("" (grind) nil nil)
   ((value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (typeinfo_fill def-decl "typeinfo" typed_reduction nil))
   nil))
 (buildRedexType_TCC2 0
  (buildRedexType_TCC2-1 nil 3701699428
   ("" (skeep :preds? t)
    (("" (skeep)
      (("" (typepred "v(B, lrhs(tA))")
        (("" (grind) (("" (grind-with-ext) nil nil)) nil)) nil))
      nil))
    nil)
   ((atom? const-decl "bool" IL nil) (value? const-decl "bool" IL nil)
    (typeinfo_lett_extensionality formula-decl nil typeinfo_adt nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (lett adt-constructor-decl "[[nat, typeinfo, typeinfo] -> (lett?)]"
     typeinfo_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (typeinfo_fill def-decl "typeinfo" typed_reduction nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil))
   nil))
 (buildRedexType_TCC3 0
  (buildRedexType_TCC3-1 nil 3701699428 ("" (grind) nil nil)
   ((value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (typeinfo_fill def-decl "typeinfo" typed_reduction nil))
   nil))
 (buildRedexType_TCC4 0
  (buildRedexType_TCC4-1 nil 3701699428
   ("" (skeep :preds? t)
    (("" (skeep)
      (("" (typepred "v(B, ptbody(tA))")
        (("" (grind) (("" (grind-with-ext) nil nil)) nil)) nil))
      nil))
    nil)
   ((atom? const-decl "bool" IL nil) (value? const-decl "bool" IL nil)
    (typeinfo_popt_extensionality formula-decl nil typeinfo_adt nil)
    (popt adt-constructor-decl "[typeinfo -> (popt?)]" typeinfo_adt
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (typeinfo_fill def-decl "typeinfo" typed_reduction nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (ptbody adt-accessor-decl "[(popt?) -> typeinfo]" typeinfo_adt
     nil))
   nil))
 (buildRedexType_TCC5 0
  (buildRedexType_TCC5-1 nil 3701699428 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil))
   nil))
 (buildRedexType_TCC6 0
  (buildRedexType_TCC6-1 nil 3701699428 ("" (grind) nil nil)
   ((typeinfo_fill def-decl "typeinfo" typed_reduction nil)) nil))
 (buildRedexType_args_correct_TCC1 0
  (buildRedexType_args_correct_TCC1-1 nil 3701702657
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (buildRedexType_args_correct 0
  (buildRedexType_args_correct-1 nil 3701701286
   ("" (simplify :let-reduce? t)
    (("" (skeep)
      (("" (typepred "buildRedex(A)")
        (("" (replace -1 - :dir RL)
          (("" (rewrite contextPurefill)
            (("" (rewrite popdepth_fill)
              (("" (assert)
                (("" (flatten)
                  (("" (assert)
                    (("" (split)
                      (("1" (skeep)
                        (("1" (inst - i)
                          (("1" (rewrite cvars_fill)
                            (("1" (grind) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (skeep)
                        (("2" (inst - "i+popDepth(buildRedex(A)`2)")
                          (("2" (rewrite cvars_fill)
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((popdepth_fill formula-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (cvars_fill formula-decl nil preprocess nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (contextPurefill formula-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (fill def-decl "IExpression" IL nil)
    (buildRedex def-decl "{K, B | fill(K, B) = A}" IL nil))
   shostak))
 (buildRedexType_correct_TCC1 0
  (buildRedexType_correct_TCC1-1 nil 3701699904
   ("" (subtype-tcc) nil nil) nil nil))
 (buildRedexType_correct_TCC2 0
  (buildRedexType_correct_TCC2-1 nil 3701699904
   ("" (skeep*)
    (("" (use buildRedexType_args_correct) (("" (grind) nil nil)) nil))
    nil)
   ((buildRedexType_args_correct formula-decl nil typed_reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (buildRedexType_correct_TCC3 0
  (buildRedexType_correct_TCC3-1 nil 3701699904
   ("" (skeep*)
    (("" (use buildRedexType_args_correct) (("" (grind) nil nil)) nil))
    nil)
   ((buildRedexType_args_correct formula-decl nil typed_reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (popn const-decl "finseq[nat]" typed_reduction nil))
   nil))
 (buildRedexType_correct_TCC4 0
  (buildRedexType_correct_TCC4-1 nil 3701699904
   ("" (skeep*)
    (("" (use buildRedexType_args_correct) (("" (grind) nil nil)) nil))
    nil)
   ((buildRedexType_args_correct formula-decl nil typed_reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (buildRedexType_correct_TCC5 0
  (buildRedexType_correct_TCC5-1 nil 3701701059
   ("" (skeep*)
    (("" (use buildRedexType_args_correct) (("" (grind) nil nil)) nil))
    nil)
   ((buildRedexType_args_correct formula-decl nil typed_reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (buildRedexType_correct_TCC6 0
  (buildRedexType_correct_TCC6-1 nil 3701701059
   ("" (skeep*)
    (("" (use buildRedexType_args_correct)
      (("" (split)
        (("1" (grind) nil nil)
         ("2" (skeep)
          (("2" (simplify :let-reduce? t)
            (("2" (split)
              (("1" (flatten)
                (("1" (inst -5 i) (("1" (grind) nil nil)) nil)) nil)
               ("2" (propax) nil nil) ("3" (propax) nil nil)
               ("4" (propax) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((buildRedexType_args_correct formula-decl nil typed_reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (popn const-decl "finseq[nat]" typed_reduction nil))
   nil))
 (buildRedexType_correct 0
  (buildRedexType_correct-1 nil 3701700006
   ("" (simplify :let-reduce? t)
    (("" (induct A)
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (grind) nil nil) ("4" (grind) nil nil)
       ("5" (with-labels (skeep*) ((hrec1 hrec2 cp sl hvar iwt obj)))
        (("5" (expand is_well_typed iwt)
          (("5" (with-labels (flatten) ((letta iwt1 et iwt2)))
            (("5" (case "atom?(letexpr1_var)")
              (("1" (expand buildRedex obj)
                (("1" (expand buildRedexType obj)
                  (("1" (assert) (("1" (grind) nil nil)) nil)) nil))
                nil)
               ("2" (expand buildRedex obj)
                (("2" (expand buildRedexType obj)
                  (("2" (assert)
                    (("2" (split obj)
                      (("1" (grind) nil nil)
                       ("2" (expand is_well_typed_ctx obj)
                        (("2" (split obj)
                          (("1" (grind) nil nil)
                           ("2"
                            (typepred
                             "buildRedexType(letexpr1_var, lrhs(tA))")
                            (("2" (replace -1 et :dir RL)
                              (("2" (rewrite fill_type) nil nil)) nil))
                            nil)
                           ("3" (typepred "buildRedex(letexpr1_var)")
                            (("3" (replace -1 iwt2 :dir RL)
                              (("3"
                                (rewrite popdepth_fill)
                                (("3"
                                  (rewrite popn_popn)
                                  (("3" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("6" (grind) nil nil) ("7" (grind) nil nil)
       ("8" (grind) nil nil) ("9" (grind) nil nil)
       ("10" (grind) nil nil)
       ("11" (with-labels (skeep*) ((hrec cp sl hvar iwt obj)))
        (("11" (expand is_well_typed iwt)
          (("11" (with-labels (flatten) ((popta iwt)))
            (("11" (case "atom?(pop1_var)")
              (("1" (expand buildRedex obj)
                (("1" (expand buildRedexType obj)
                  (("1" (assert) (("1" (grind) nil nil)) nil)) nil))
                nil)
               ("2" (expand buildRedex obj)
                (("2" (expand buildRedexType obj)
                  (("2" (assert)
                    (("2" (split obj)
                      (("1" (grind) nil nil)
                       ("2" (expand is_well_typed_ctx obj)
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("12" (grind) nil nil) ("13" (grind) nil nil)
       ("14" (delete 2)
        (("14" (skeep)
          (("14" (use buildRedexType_args_correct)
            (("14" (grind) nil nil)) nil))
          nil))
        nil)
       ("15" (delete 2)
        (("15" (skeep)
          (("15" (use buildRedexType_args_correct)
            (("15" (grind) nil nil)) nil))
          nil))
        nil)
       ("16" (delete 2)
        (("16" (skeep)
          (("16" (use buildRedexType_args_correct)
            (("16" (grind) nil nil)) nil))
          nil))
        nil)
       ("17" (delete 2)
        (("17" (skeep)
          (("17" (use buildRedexType_args_correct)
            (("17" (grind) nil nil)) nil))
          nil))
        nil)
       ("18" (delete 2)
        (("18" (skeep)
          (("18" (use buildRedexType_args_correct)
            (("18" (grind) nil nil)) nil))
          nil))
        nil)
       ("19" (delete 2)
        (("19" (skeep)
          (("19" (use buildRedexType_args_correct)
            (("19" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((contextPure? def-decl "bool" IL nil) nil
    (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    nil (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (buildRedex def-decl "{K, B | fill(K, B) = A}" IL nil)
    (fill def-decl "IExpression" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (cpure? def-decl "bool" IL nil)
    (buildRedexType def-decl "{tK, tB | typeinfo_fill(tK, tB) = tA}"
     typed_reduction nil)
    (typeinfo_fill def-decl "typeinfo" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil) nil
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil) nil
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (singleton const-decl "(singleton?)" sets nil) nil
    (int_minus_int_is_int application-judgement "int" integers nil)
    (emptyset const-decl "set" sets nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    nil (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (atom? const-decl "bool" IL nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (value? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (fill_type formula-decl nil typed_reduction nil)
    (popn_popn formula-decl nil typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (popdepth_fill formula-decl nil IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (ptbody adt-accessor-decl "[(popt?) -> typeinfo]" typeinfo_adt nil)
    (buildRedexType_args_correct formula-decl nil typed_reduction nil))
   shostak))
 (make_redex_typed_TCC1 0
  (make_redex_typed_TCC1-1 nil 3701707876 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (make_redex_typed_TCC2 0
  (make_redex_typed_TCC2-1 nil 3701707876
   ("" (skeep)
    (("" (typepred "tS`dom_types")
      (("" (skeep*)
        (("" (inst?)
          (("1" (inst -1 j)
            (("1" (grind) nil nil)
             ("2" (typepred j) (("2" (grind) nil nil)) nil))
            nil)
           ("2" (typepred r) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((atom? const-decl "bool" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil) nil nil
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil) nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) nil
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil) nil
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureRedex? const-decl "bool" IL nil)
    (topstate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil) nil
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) nil
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    nil
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (make_redex_typed_TCC3 0
  (make_redex_typed_TCC3-1 nil 3701707876
   ("" (skeep* :preds? t)
    (("" (expand make_redex_e)
      (("" (typepred "tS`stack_types") (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) nil
    nil (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (atom? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (make_redex_typed_TCC4 0
  (make_redex_typed_TCC4-1 nil 3701707876
   ("" (skeep* :preds? t)
    (("" (expand make_redex_e)
      (("" (lemma buildRedexType_correct)
        (("" (simplify :let-reduce? t)
          ((""
            (inst -1 "tS`state`redex" "tS`def_types" "tS`dom_types"
             "tS`stack_types" "tS`redex_type")
            (("" (split -1)
              (("1" (assert) nil nil)
               ("2" (typepred "tS`state`redex")
                (("2" (propax) nil nil)) nil)
               ("3" (typepred "tS`state`redex")
                (("3" (typepred "tS`stack_types")
                  (("3" (grind) nil nil)) nil))
                nil)
               ("4" (typepred "tS`stack_types")
                (("4"
                  (with-labels (typepred "tS`state`redex")
                   ((href hvar hcvar hsl hcp)))
                  (("4" (skeep)
                    (("4" (inst hvar "i-popDepth(tS`state`redex)")
                      (("1" (rewrite cvars_vars)
                        (("1" (grind) nil nil)) nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("5" (typepred "tS`redex_type") (("5" (propax) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (refs def-decl "bool" IL nil) nil
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cvars_vars formula-decl nil preprocess nil)
    (atom? const-decl "bool" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil) nil nil
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil) nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) nil
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (buildRedexType_correct formula-decl nil typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (make_redex_typed_TCC5 0
  (make_redex_typed_TCC5-1 nil 3701707876
   ("" (skeep* :preds? t)
    (("" (expand make_redex_e)
      (("" (lemma buildRedexType_correct)
        (("" (simplify :let-reduce? t)
          ((""
            (inst -1 "tS`state`redex" "tS`def_types" "tS`dom_types"
             "tS`stack_types" "tS`redex_type")
            (("" (split -1)
              (("1" (assert) nil nil)
               ("2" (typepred "tS`state`redex")
                (("2" (propax) nil nil)) nil)
               ("3" (typepred "tS`state`redex")
                (("3" (typepred "tS`stack_types")
                  (("3" (grind) nil nil)) nil))
                nil)
               ("4" (typepred "tS`stack_types")
                (("4"
                  (with-labels (typepred "tS`state`redex")
                   ((href hvar hcvar hsl hcp)))
                  (("4" (skeep)
                    (("4" (inst hvar "i-popDepth(tS`state`redex)")
                      (("1" (rewrite cvars_vars)
                        (("1" (grind) nil nil)) nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("5" (typepred "tS`redex_type") (("5" (propax) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (refs def-decl "bool" IL nil) nil
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cvars_vars formula-decl nil preprocess nil)
    (atom? const-decl "bool" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil) nil nil
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil) nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) nil
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (buildRedexType_correct formula-decl nil typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (defs_well_typed_TCC1 0
  (defs_well_typed_TCC1-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil) nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (defs_well_typed_TCC2 0
  (defs_well_typed_TCC2-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (typepred "D`seq(i)`body")
      (("" (use pure_contextPure) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil) nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pure_contextPure formula-decl nil IL nil))
   nil))
 (defs_well_typed_TCC3 0
  (defs_well_typed_TCC3-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth) (("1" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (typepred "D`seq(i)`body")
          (("2" (rewrite cvars_pure)
            (("2" (assert) (("2" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil) nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cvars_pure formula-decl nil preprocess nil))
   nil))
 (set_new_type_TCC1 0
  (set_new_type_TCC1-1 nil 3702647357
   ("" (skeep* :preds? t)
    (("" (lift-if)
      (("" (split)
        (("1" (flatten) (("1" (grind) nil nil)) nil)
         ("2" (flatten)
          (("2" (typepred "tS`dom_types")
            (("2" (inst -1 r j)
              (("2" (expand value_of_type)
                (("2" (lift-if)
                  (("2" (ground)
                    (("2" (typepred "tS`state`store(r)`seq(j)")
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((domainValue? const-decl "bool" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) nil
    nil (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil))
   nil))
 (set_new_type_TCC2 0
  (set_new_type_TCC2-1 nil 3702647357
   ("" (skeep* :preds? t)
    (("" (typepred "tS`stack_types")
      (("" (split)
        (("1" (propax) nil nil)
         ("2" (skeep :preds? t)
          (("2" (inst?)
            (("2" (expand value_of_type)
              (("2" (ground)
                (("2" (lift-if)
                  (("2" (ground)
                    (("2" (typepred "tS`state`stack")
                      (("2" (grind)
                        (("2" (typepred "tS`state`stack`seq(i_1)")
                          (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil) nil nil
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil) nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) nil
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (set_new_type_TCC3 0
  (set_new_type_TCC3-1 nil 3702647357
   ("" (lemma is_well_typed_dom)
    (("" (skeep)
      (("" (inst?)
        (("" (inst -1 "tS`dom_types")
          (("" (split -1)
            (("1" (typepred "tS`redex_type") (("1" (assert) nil nil))
              nil)
             ("2" (typepred "tS`state`redex") (("2" (propax) nil nil))
              nil)
             ("3" (typepred "tS`state`redex")
              (("3" (skeep)
                (("3" (inst -1 i_1) (("3" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil) nil
    (refs def-decl "bool" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil) nil nil
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil) nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) nil
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (is_well_typed_dom formula-decl nil typed_reduction nil))
   nil))
 (set_new_type_TCC4 0
  (set_new_type_TCC4-1 nil 3702647357
   ("" (skeep)
    (("" (lemma is_well_typed_ctx_dom)
      (("" (inst?)
        (("" (inst -1 "tS`dom_types")
          (("" (split -1)
            (("1" (typepred "tS`context_type") (("1" (assert) nil nil))
              nil)
             ("2" (typepred "tS`state`context")
              (("2" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((is_well_typed_ctx_dom formula-decl nil typed_reduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil) nil nil
    (cpure? def-decl "bool" IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil) nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) nil
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IContext type-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC1 0
  (typed_reduce_TCC1-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) nil
    nil (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil) nil
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC2 0
  (typed_reduce_TCC2-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC3 0
  (typed_reduce_TCC3-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (typepred "nS`dom_types")
      (("" (expand letReduce) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (goodstate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil)
    (Defs type-eq-decl nil reduction nil)
    (Definition type-eq-decl nil reduction nil)
    (pure? def-decl "bool" IL nil)
    (letReduce const-decl "estate" reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC4 0
  (typed_reduce_TCC4-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type")
      (("" (apply-eta "nS`state`redex" "(letexpr?)")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression_letexpr_eta formula-decl nil IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC5 0
  (typed_reduce_TCC5-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (typepred "nS`stack_types")
        (("1" (expand letReduce) (("1" (grind) nil nil)) nil)) nil)
       ("2" (skeep :preds? t)
        (("2" (with-labels (typepred "nS`stack_types") ((sll slv)))
          (("2" (case-replace "i = nS`stack_types`length")
            (("1" (expand add)
              (("1" (expand letReduce)
                (("1" (replace sll +)
                  (("1" (expand push)
                    (("1" (expand add)
                      (("1" (lift-if)
                        (("1" (split)
                          (("1" (flatten)
                            (("1"
                              (inst slv
                               "nS`stack_types`length - 1 - index(letrhs(nS`state`redex))")
                              (("1"
                                (typepred "nS`redex_type")
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (with-labels
                                 (typepred "nS`state`redex")
                                 ((href hvar hcvar hsl hcp)))
                                (("2"
                                  (inst
                                   hvar
                                   "index(letrhs(nS`state`redex))")
                                  (("2"
                                    (split hvar)
                                    (("1" (grind) nil nil)
                                     ("2"
                                      (apply-eta
                                       "nS`state`redex"
                                       "(letexpr?)")
                                      (("2"
                                        (replace -1 :dir RL)
                                        (("2"
                                          (expand vars)
                                          (("2"
                                            (expand union)
                                            (("2"
                                              (expand member)
                                              (("2"
                                                (simplify)
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten)
                            (("2"
                              (case "value?(letrhs(nS`state`redex))")
                              (("1"
                                (typepred "nS`redex_type")
                                (("1"
                                  (apply-eta
                                   "nS`state`redex"
                                   "(letexpr?)")
                                  (("1"
                                    (replace -1 :dir RL)
                                    (("1"
                                      (simplify)
                                      (("1"
                                        (expand is_well_typed)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (rewrite value_well_typed)
                                            (("1" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand add)
              (("2" (lift-if)
                (("2" (assert)
                  (("2" (expand letReduce)
                    (("2" (lift-if)
                      (("2" (expand push)
                        (("2" (expand add) (("2" (inst slv i) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((letReduce const-decl "estate" reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (push const-decl "Stack" IL nil) (get const-decl "(value?)" IL nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (IExpression_letexpr_eta formula-decl nil IExpression_adt nil)
    (member const-decl "bool" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (singleton const-decl "(singleton?)" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (refs def-decl "bool" IL nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (value_well_typed formula-decl nil typed_reduction nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (seq type-eq-decl nil more_finseq nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC6 0
  (typed_reduce_TCC6-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand letReduce)
      (("" (expand is_well_typed)
        (("" (typepred "nS`redex_type")
          (("" (apply-eta "nS`state`redex" "(letexpr?)")
            (("" (replace -1 :dir RL)
              (("" (assert)
                (("" (expand is_well_typed -)
                  ((""
                    (case-replace
                     "popn(nS`stack_types, popDepth(letrhs(nS`state`redex))) = nS`stack_types")
                    (("1" (assert) nil nil)
                     ("2"
                      (case-replace
                       "popDepth(letrhs(nS`state`redex)) = 0")
                      (("1" (use popn_zero) nil nil)
                       ("2" (expand pureLetRedex?)
                        (("2" (expand letRedex?)
                          (("2" (flatten) (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((letReduce const-decl "estate" reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (letRedex? const-decl "bool" IL nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (fill def-decl "IExpression" IL nil)
    (buildRedex def-decl "{K, B | fill(K, B) = A}" IL nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression_letexpr_eta formula-decl nil IExpression_adt nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC7 0
  (typed_reduce_TCC7-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand letReduce)
      (("" (expand popDepth)
        (("" (rewrite purePopDepth)
          (("1" (assert)
            (("1"
              (case-replace
               "popn(add(lettype(nS`redex_type), nS`stack_types), 1) = nS`stack_types")
              (("1" (typepred "nS`context_type")
                (("1" (case-replace "popDepth(nS`state`redex) = 0")
                  (("1" (expand expr_type +)
                    (("1" (case "lett?(nS`redex_type)")
                      (("1" (grind) nil nil)
                       ("2" (typepred "nS`redex_type")
                        (("2" (apply-eta "nS`state`redex" "(letexpr?)")
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (apply-eta "nS`state`redex" "(letexpr?)")
                    (("1" (case "atom?(letrhs(nS`state`redex))")
                      (("1" (replace -2 :dir RL)
                        (("1" (expand popDepth)
                          (("1" (simplify) (("1" (grind) nil nil))
                            nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (expand add)
                (("2" (expand popn)
                  (("2" (decompose-equality)
                    (("2" (decompose-equality) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((letReduce const-decl "estate" reduction nil)
    (purePopDepth formula-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (body adt-accessor-decl "[(letexpr?) -> IExpression]"
          IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (seq type-eq-decl nil more_finseq nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (IExpression_letexpr_eta formula-decl nil IExpression_adt nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (fill def-decl "IExpression" IL nil)
    (buildRedex def-decl "{K, B | fill(K, B) = A}" IL nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC8 0
  (typed_reduce_TCC8-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC9 0
  (typed_reduce_TCC9-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand applyReduce)
      (("" (assert)
        (("" (typepred "nS`dom_types") (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((applyReduce const-decl "estate" reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (goodstate type-eq-decl nil reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC10 0
  (typed_reduce_TCC10-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand applyReduce)
      (("" (assert)
        (("" (typepred "nS`stack_types") (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((applyReduce const-decl "estate" reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC11 0
  (typed_reduce_TCC11-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand applyReduce)
      (("" (case "fun(nS`state`redex) < D`length")
        (("1" (assert)
          (("1"
            (case "length(args(nS`state`redex)) = D`seq(fun(nS`state`redex))`arity")
            (("1" (assert) (("1" (postpone) nil nil)) nil)
             ("2" (assert) nil nil))
            nil))
          nil)
         ("2" (assert) nil nil) ("3" (grind) nil nil))
        nil))
      nil))
    nil)
   nil nil))
 (typed_reduce_TCC12 0
  (typed_reduce_TCC12-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (case-replace "popDepth(applyReduce(D)(nS`state)`redex) = 0")
      (("1" (expand applyReduce)
        (("1" (assert)
          (("1" (typepred "nS`context_type")
            (("1" (assert)
              (("1" (case-replace "popDepth(nS`state`redex) = 0")
                (("1" (assert) nil nil) ("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand applyReduce 1)
        (("2" (lift-if)
          (("2" (ground)
            (("1" (rewrite popdepth_letApply)
              (("1" (lift-if)
                (("1" (ground)
                  (("1" (rewrite purePopDepth) nil nil)
                   ("2" (typepred "args(nS`state`redex)")
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil) ("3" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (applyReduce const-decl "estate" reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (args adt-accessor-decl "[(application?) -> list[(variable?)]]"
          IExpression_adt nil)
    (length def-decl "nat" list_props nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (popdepth_letApply formula-decl nil reduction nil)
    (purePopDepth formula-decl nil IL nil)
    (pure_letApply rec-application-judgement "(pure?)" reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC13 0
  (typed_reduce_TCC13-1 nil 3701716715 ("" (grind) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC14 0
  (typed_reduce_TCC14-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (case-replace "reduce(D)(tS`state) = ifReduce(D)(nS`state)")
      (("1" (typepred "nS`dom_types") (("1" (grind) nil nil)) nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (reduce const-decl "estate" reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (ifReduce const-decl "estate" reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (get const-decl "(value?)" IL nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (push const-decl "Stack" IL nil)
    (letReduce const-decl "estate" reduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (applyReduce const-decl "estate" reduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (updateReduce const-decl "estate" reduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (lookupReduce const-decl "estate" reduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (newintReduce const-decl "estate" reduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newrefReduce const-decl "estate" reduction nil)
    (popRedex? const-decl "bool" IL nil)
    (pop const-decl "Stack" IL nil)
    (popReduce const-decl "estate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC15 0
  (typed_reduce_TCC15-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand ifReduce)
      (("" (typepred "nS`stack_types") (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((ifReduce const-decl "estate" reduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC16 0
  (typed_reduce_TCC16-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC17 0
  (typed_reduce_TCC17-1 nil 3701716715
   ("" (skeep* :preds? t)
    ((""
      (with-labels (typepred "nS`state`redex")
       ((href hvar hcvar hsl hcp)))
      (("" (inst hvar "index(condition(nS`state`redex))")
        (("" (split hvar)
          (("1" (grind) nil nil)
           ("2" (apply-eta "nS`state`redex" "(ift?)")
            (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (add const-decl "(nonempty?)" sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (IExpression_ift_eta formula-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC18 0
  (typed_reduce_TCC18-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (apply-eta "nS`state`redex" "(ift?)")
      (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((IExpression_ift_eta formula-decl nil IExpression_adt nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (get const-decl "(value?)" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC19 0
  (typed_reduce_TCC19-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (apply-eta "nS`state`redex" "(ift?)")
      (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((IExpression_ift_eta formula-decl nil IExpression_adt nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (get const-decl "(value?)" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC20 0
  (typed_reduce_TCC20-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand ifReduce)
      (("" (lift-if)
        (("" (typepred "nS`redex_type")
          (("" (apply-eta "nS`state`redex" "(ift?)")
            (("1" (replace -1 :dir RL)
              (("1" (simplify)
                (("1" (expand is_well_typed -) (("1" (grind) nil nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ifReduce const-decl "estate" reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression_ift_eta formula-decl nil IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC21 0
  (typed_reduce_TCC21-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand ifReduce)
      (("" (assert)
        (("" (typepred "nS`redex_type")
          (("" (typepred "nS`context_type")
            (("" (apply-eta "nS`state`redex" "(ift?)")
              (("1" (replace -1 :dir RL)
                (("1" (simplify)
                  (("1" (expand is_well_typed -)
                    (("1"
                      (case-replace
                       "expr_type(nS`redex_type) = expr_type(tthen(nS`redex_type))")
                      (("1" (expand popDepth -)
                        (("1"
                          (case-replace
                           "popDepth(elseexpr(nS`state`redex)) = 0")
                          (("1"
                            (case-replace
                             "popDepth(thenexpr(nS`state`redex)) = 0")
                            (("1" (assert) (("1" (grind) nil nil)) nil)
                             ("2" (use purePopDepth)
                              (("2" (grind) nil nil)) nil))
                            nil)
                           ("2" (use purePopDepth)
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ifReduce const-decl "estate" reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression_ift_eta formula-decl nil IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (tthen adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (iftt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (get const-decl "(value?)" IL nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC22 0
  (typed_reduce_TCC22-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC23 0
  (typed_reduce_TCC23-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type")
      (("" (expand updateRedex?) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (updateRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC24 0
  (typed_reduce_TCC24-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil)) nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC25 0
  (typed_reduce_TCC25-1 nil 3701716715
   (""
    (with-labels (skeep* :preds? t)
     ((tsr defswt natom ttop upr ifr apr letr nst obj)))
    (("" (split obj)
      (("1" (typepred "nS`redex_type") (("1" (grind) nil nil)) nil)
       ("2" (with-labels (skeep* obj :preds? t) ((jl rdom obj)))
        (("2"
          (name-replace "nS2"
           "set_new_type(nS, leaftype(nS`redex_type) - 1)")
          (("1"
            (case-replace "nS`dom_types
                      WITH [(least_out(nS`state`domain))
                              |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
            (("1" (case-replace "nS`state = nS2`state")
              (("1" (expand updateReduce)
                (("1" (split rdom)
                  (("1" (flatten rdom)
                    (("1" (assert)
                      (("1" (lift-if)
                        (("1" (split obj)
                          (("1" (flatten)
                            (("1" (replace -1)
                              (("1"
                                (case-replace
                                 "nS2`dom_types(least_out(nS2`state`domain)) = leaftype(nS`redex_type) - 1")
                                (("1"
                                  (case-replace
                                   "nS`redex_type = nS2`redex_type")
                                  (("1"
                                    (typepred "nS2`dom_types")
                                    (("1"
                                      (inst
                                       -1
                                       "refindex(get(nS2`state`stack)(target(nS2`state`redex)))"
                                       j)
                                      (("1"
                                        (simplify)
                                        (("1"
                                          (lift-if)
                                          (("1"
                                            (split obj)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (replace -1)
                                                (("1"
                                                  (typepred
                                                   "nS2`redex_type")
                                                  (("1"
                                                    (case
                                                     "update?(nS2`state`redex)")
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (expand
                                                         is_well_typed
                                                         -2)
                                                        (("1"
                                                          (flatten)
                                                          (("1"
                                                            (expand
                                                             is_well_typed
                                                             -5)
                                                            (("1"
                                                              (typepred
                                                               "nS2`stack_types")
                                                              (("1"
                                                                (expand
                                                                 get)
                                                                (("1"
                                                                  (inst
                                                                   -2
                                                                   "nS2`state`stack`length - 1 - index(rhs(nS2`state`redex))")
                                                                  (("1"
                                                                    (grind)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (typepred
                                                                     "nS2`state`redex")
                                                                    (("2"
                                                                      (inst
                                                                       -2
                                                                       "index(rhs(nS2`state`redex))")
                                                                      (("2"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (typepred
                                                 "nS2`redex_type")
                                                (("2"
                                                  (case
                                                   "update?(nS2`state`redex)")
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (expand
                                                       is_well_typed
                                                       -2)
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (expand
                                                           is_well_typed
                                                           -3)
                                                          (("1"
                                                            (case
                                                             "value_of_type(get(nS2`state`stack)(target(nS2`state`redex)), leaftype(nS2`redex_type), nS2`dom_types)")
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil)
                                                             ("2"
                                                              (typepred
                                                               "nS2`stack_types")
                                                              (("2"
                                                                (expand
                                                                 get)
                                                                (("2"
                                                                  (inst?)
                                                                  (("1"
                                                                    (grind)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (typepred
                                                                     "nS2`state`redex")
                                                                    (("2"
                                                                      (inst
                                                                       -2
                                                                       "index(target(nS2`state`redex))")
                                                                      (("2"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil)
                                 ("2"
                                  (expand nS2)
                                  (("2"
                                    (expand set_new_type)
                                    (("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (typepred "nS2`dom_types")
                            (("2" (flatten)
                              (("2" (inst -1 r j) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten rdom)
                    (("2" (assert)
                      (("2" (typepred "nS2`dom_types")
                        (("2" (inst -1 r j) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand nS2)
                (("2" (expand set_new_type) (("2" (propax) nil nil))
                  nil))
                nil))
              nil)
             ("2" (expand nS2)
              (("2" (expand set_new_type) (("2" (propax) nil nil))
                nil))
              nil))
            nil)
           ("2" (typepred "nS`redex_type") (("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (typeinfo_fill def-decl "typeinfo" typed_reduction nil)
    (buildRedexType def-decl "{tK, tB | typeinfo_fill(tK, tB) = tA}"
     typed_reduction nil)
    (fill def-decl "IExpression" IL nil) (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (goodstate type-eq-decl nil reduction nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (get const-decl "(value?)" IL nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (add const-decl "(nonempty?)" sets nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (member const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (updateReduce const-decl "estate" reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC26 0
  (typed_reduce_TCC26-1 nil 3701716715
   ("" (skeep* :preds? t)
    ((""
      (name-replace nS2
       "set_new_type(nS, leaftype(nS`redex_type) - 1)")
      (("1"
        (case-replace "nS`dom_types
                         WITH [(least_out(nS`state`domain))
                                 |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
        (("1" (expand updateReduce)
          (("1" (assert)
            (("1" (typepred "nS2`stack_types")
              (("1" (expand nS2)
                (("1" (skeep)
                  (("1" (inst -2 i)
                    (("1" (grind) nil nil)
                     ("2" (expand nS2) (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand nS2)
          (("2" (expand set_new_type) (("2" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil)
       ("3" (typepred "nS`redex_type") (("3" (grind) nil nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (updateReduce const-decl "estate" reduction nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (get const-decl "(value?)" IL nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC27 0
  (typed_reduce_TCC27-1 nil 3701716715
   ("" (skeep* :preds? t)
    ((""
      (name-replace nS2 "set_new_type(nS, leaftype(nS`redex_type) -1)")
      (("1"
        (case-replace "nS`dom_types
                      WITH [(least_out(nS`state`domain))
                              |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
        (("1" (expand updateReduce)
          (("1" (lift-if)
            (("1" (split)
              (("1" (flatten)
                (("1" (expand is_well_typed)
                  (("1" (expand nS2)
                    (("1" (expand set_new_type)
                      (("1" (typepred "nS`redex_type")
                        (("1" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (typepred "nS2`redex_type")
                  (("2" (expand nS2)
                    (("2" (expand set_new_type)
                      (("2" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand nS2)
          (("2" (expand set_new_type) (("2" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (updateReduce const-decl "estate" reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (get const-decl "(value?)" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC28 0
  (typed_reduce_TCC28-1 nil 3701716715
   ("" (skeep* :preds? t)
    ((""
      (name-replace nS2 "set_new_type(nS, leaftype(nS`redex_type) -1)")
      (("1"
        (case-replace "nS`dom_types
                         WITH [(least_out(nS`state`domain))
                                 |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
        (("1"
          (case-replace
           "popDepth(updateReduce(D)(nS`state)`redex) = popDepth(nS`state`redex)")
          (("1" (expand updateReduce +)
            (("1" (assert)
              (("1" (typepred "nS2`context_type")
                (("1" (expand nS2)
                  (("1" (expand set_new_type) (("1" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand updateReduce)
            (("2" (lift-if)
              (("2" (split 1)
                (("1" (flatten)
                  (("1" (expand popDepth) (("1" (grind) nil nil)) nil))
                  nil)
                 ("2" (propax) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand nS2)
          (("2" (expand set_new_type) (("2" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (goodstate type-eq-decl nil reduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (updateReduce const-decl "estate" reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (get const-decl "(value?)" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC29 0
  (typed_reduce_TCC29-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC30 0
  (typed_reduce_TCC30-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand lookupReduce)
      (("" (assert)
        (("" (typepred "nS`dom_types") (("" (inst -1 r j) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((lookupReduce const-decl "estate" reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (goodstate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil)
    (Defs type-eq-decl nil reduction nil)
    (Definition type-eq-decl nil reduction nil)
    (pure? def-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC31 0
  (typed_reduce_TCC31-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand lookupReduce)
      (("" (assert)
        (("" (typepred "nS`stack_types") (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((lookupReduce const-decl "estate" reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC32 0
  (typed_reduce_TCC32-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand lookupReduce)
      (("" (lift-if)
        (("" (split)
          (("1" (flatten)
            (("1" (typepred "nS`dom_types")
              (("1" (inst?)
                (("1" (typepred "nS`redex_type")
                  (("1" (case "lookup?(nS`state`redex)")
                    (("1" (assert)
                      (("1" (expand is_well_typed -)
                        (("1" (expand is_well_typed -)
                          (("1" (typepred "nS`stack_types")
                            (("1"
                              (inst -2
                               "nS`stack_types`length - 1 - index(arrayvalue(nS`state`redex))")
                              (("1"
                                (replace -1)
                                (("1"
                                  (expand get)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (expand value_of_type -2)
                                      (("1"
                                        (rewrite value_well_typed +)
                                        (("1"
                                          (case-replace
                                           "nS`dom_types
                        (refindex((nS`state`stack`seq
                                       (nS`state`stack`length - 1
                                        -
                                        index
                                        (arrayvalue(nS`state`redex)))))) = leaftype(nS`redex_type)")
                                          (("1" (grind) nil nil)
                                           ("2" (grind) nil nil)
                                           ("3"
                                            (typepred "nS`state`redex")
                                            (("3"
                                              (inst
                                               -2
                                               "index(arrayvalue(nS`state`redex))")
                                              (("3" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (typepred "nS`state`redex")
                                          (("2"
                                            (inst
                                             -2
                                             "index(arrayvalue(nS`state`redex))")
                                            (("2" (grind) nil nil))
                                            nil))
                                          nil)
                                         ("3"
                                          (typepred "nS`state`redex")
                                          (("3"
                                            (inst
                                             -2
                                             "index(position(nS`state`redex))")
                                            (("3" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (typepred "nS`state`redex")
                                (("2"
                                  (inst
                                   -2
                                   "index(arrayvalue(nS`state`redex))")
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (typepred "nS`redex_type") (("2" (propax) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lookupReduce const-decl "estate" reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (member const-decl "bool" sets nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (add const-decl "(nonempty?)" sets nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (refs def-decl "bool" IL nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (value_well_typed formula-decl nil typed_reduction nil)
    (position adt-accessor-decl "[(lookup?) -> (variable?)]"
      IExpression_adt nil)
    (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt
     nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]"
     IExpression_adt nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC33 0
  (typed_reduce_TCC33-1 nil 3701716715
   ("" (skeep* :preds? t)
    ((""
      (case-replace
       "popDepth(lookupReduce(D)(nS`state)`redex) = popDepth(nS`state`redex)")
      (("1" (expand lookupReduce +) (("1" (assert) nil nil)) nil)
       ("2" (typepred "nS`context_type")
        (("2" (expand lookupReduce)
          (("2" (lift-if)
            (("2" (split)
              (("1" (flatten)
                (("1"
                  (typepred "nS`state`store
                   (refindex(get(nS`state`stack)
                                (arrayvalue(nS`state`redex))))`seq
                   (value(get(nS`state`stack)(position(nS`state`redex))))")
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                nil)
               ("2" (propax) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (lookupReduce const-decl "estate" reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (get const-decl "(value?)" IL nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]"
     IExpression_adt nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt
     nil)
    (position adt-accessor-decl "[(lookup?) -> (variable?)]"
      IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC34 0
  (typed_reduce_TCC34-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil)) nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC35 0
  (typed_reduce_TCC35-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil)) nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC36 0
  (typed_reduce_TCC36-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil)) nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (pure? def-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC37 0
  (typed_reduce_TCC37-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (typepred "nS`redex_type") (("1" (grind) nil nil)) nil)
       ("2" (skeep* :preds? t)
        (("2" (name-replace nS2 "set_new_type(nS, 0)")
          (("2"
            (case-replace "nS`dom_types
                      WITH [(least_out(nS`state`domain))
                              |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
            (("1" (expand newintReduce)
              (("1" (lift-if)
                (("1" (split 1)
                  (("1" (flatten)
                    (("1" (expand value_of_type)
                      (("1" (expand nS2) (("1" (grind) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (typepred "nS2`dom_types")
                      (("2" (inst -1 r j)
                        (("1" (expand nS2)
                          (("1" (expand set_new_type)
                            (("1" (propax) nil nil)) nil))
                          nil)
                         ("2" (expand nS2)
                          (("2" (expand set_new_type)
                            (("2" (assert) nil nil)) nil))
                          nil)
                         ("3" (expand nS2) (("3" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand nS2)
              (("2" (expand set_new_type)
                (("2" (typepred "nS`redex_type")
                  (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (newintReduce const-decl "estate" reduction nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (goodstate type-eq-decl nil reduction nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC38 0
  (typed_reduce_TCC38-1 nil 3701716715
   ("" (skeep* :preds? t)
    ((""
      (name-replace nS2
       "set_new_type(nS, leaftype(nS`redex_type) - 1)")
      (("1"
        (case-replace "nS`dom_types
                         WITH [(least_out(nS`state`domain))
                                 |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
        (("1" (expand newintReduce)
          (("1" (typepred "nS2`stack_types")
            (("1" (expand nS2)
              (("1" (expand set_new_type)
                (("1" (assert)
                  (("1" (skeep)
                    (("1" (inst?)
                      (("1" (expand nS2) (("1" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand nS2) (("2" (grind) nil nil)) nil))
        nil)
       ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil)
       ("3" (typepred "nS`redex_type") (("3" (grind) nil nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (newintReduce const-decl "estate" reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (pure? def-decl "bool" IL nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC39 0
  (typed_reduce_TCC39-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand newintReduce)
      (("" (expand is_well_typed)
        (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((newintReduce const-decl "estate" reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC40 0
  (typed_reduce_TCC40-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand newintReduce)
      ((""
        (case-replace
         "popDepth(ref(least_out(nS`state`domain))) = popDepth(nS`state`redex)")
        (("1"
          (name-replace nS2
           "set_new_type(nS, leaftype(nS`redex_type) - 1)")
          (("1"
            (case-replace "nS`dom_types
                         WITH [(least_out(nS`state`domain))
                                 |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
            (("1" (typepred "nS2`context_type")
              (("1" (expand nS2)
                (("1" (expand set_new_type) (("1" (propax) nil nil))
                  nil))
                nil))
              nil)
             ("2" (expand nS2)
              (("2" (expand set_new_type) (("2" (propax) nil nil))
                nil))
              nil))
            nil)
           ("2" (typepred "nS`redex_type") (("2" (grind) nil nil))
            nil))
          nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((newintReduce const-decl "estate" reduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC41 0
  (typed_reduce_TCC41-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC42 0
  (typed_reduce_TCC42-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil)) nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC43 0
  (typed_reduce_TCC43-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil)) nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC44 0
  (typed_reduce_TCC44-1 nil 3701716715
   ("" (skeep* :preds? t)
    ((""
      (name-replace nS2
       "set_new_type(nS, leaftype(nS`redex_type) - 1)")
      (("1"
        (case-replace "nS`dom_types
           WITH [(least_out(nS`state`domain))
                   |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
        (("1" (split)
          (("1" (skeep)
            (("1" (typepred "nS2`dom_types(x1)")
              (("1" (propax) nil nil)) nil))
            nil)
           ("2" (skeep* :preds? t)
            (("2" (expand newrefReduce)
              (("2" (lift-if)
                (("2" (split)
                  (("1" (flatten)
                    (("1" (assert)
                      (("1" (expand value_of_type)
                        (("1" (expand nS2)
                          (("1" (expand set_new_type)
                            (("1" (typepred "nS`redex_type")
                              (("1" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert)
                    (("2" (flatten)
                      (("2" (assert)
                        (("2" (typepred "nS2`dom_types")
                          (("2" (inst -1 r j)
                            (("1" (expand nS2)
                              (("1"
                                (expand set_new_type)
                                (("1" (propax) nil nil))
                                nil))
                              nil)
                             ("2" (expand nS2)
                              (("2"
                                (expand set_new_type)
                                (("2" (propax) nil nil))
                                nil))
                              nil)
                             ("3" (expand nS2)
                              (("3"
                                (expand set_new_type)
                                (("3" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand nS2)
          (("2" (expand set_new_type) (("2" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil)
       ("3" (typepred "nS`redex_type") (("3" (grind) nil nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (newrefReduce const-decl "estate" reduction nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (goodstate type-eq-decl nil reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC45 0
  (typed_reduce_TCC45-1 nil 3701716715
   ("" (skeep* :preds? t)
    ((""
      (name-replace nS2
       "set_new_type(nS, leaftype(nS`redex_type) - 1)")
      (("1"
        (case-replace "nS`dom_types
                             WITH [(least_out(nS`state`domain))
                                     |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
        (("1" (expand newrefReduce)
          (("1" (typepred "nS2`stack_types")
            (("1" (expand nS2)
              (("1" (expand set_new_type)
                (("1" (assert)
                  (("1" (skeep)
                    (("1" (inst?)
                      (("1" (expand nS2) (("1" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand nS2) (("2" (grind) nil nil)) nil))
        nil)
       ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil)
       ("3" (typepred "nS`redex_type") (("3" (grind) nil nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (newrefReduce const-decl "estate" reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC46 0
  (typed_reduce_TCC46-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand newrefReduce)
      (("" (expand is_well_typed)
        (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((newrefReduce const-decl "estate" reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC47 0
  (typed_reduce_TCC47-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand newrefReduce)
      ((""
        (case-replace
         "popDepth(ref(least_out(nS`state`domain))) = popDepth(nS`state`redex)")
        (("1"
          (name-replace nS2
           "set_new_type(nS, leaftype(nS`redex_type) - 1)")
          (("1"
            (case-replace "nS`dom_types
                               WITH [(least_out(nS`state`domain))
                                       |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
            (("1" (typepred "nS2`context_type")
              (("1" (expand nS2)
                (("1" (expand set_new_type) (("1" (propax) nil nil))
                  nil))
                nil))
              nil)
             ("2" (expand nS2)
              (("2" (expand set_new_type) (("2" (propax) nil nil))
                nil))
              nil))
            nil)
           ("2" (typepred "nS`redex_type") (("2" (grind) nil nil))
            nil))
          nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((newrefReduce const-decl "estate" reduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (set_new_type const-decl "typed_state" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC48 0
  (typed_reduce_TCC48-1 nil 3701716715 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (popRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC49 0
  (typed_reduce_TCC49-1 nil 3701716715
   ("" (skeep* :preds? t)
    (("" (expand popReduce)
      (("" (typepred "nS`dom_types") (("" (inst -1 r j) nil nil)) nil))
      nil))
    nil)
   ((popReduce const-decl "estate" reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (goodstate type-eq-decl nil reduction nil)
    (popRedex? const-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC50 0
  (typed_reduce_TCC50-1 nil 3701716715
   ("" (skeep*)
    (("" (typepred "nS`stack_types")
      (("" (typepred "nS`state`redex")
        (("" (case "popDepth(nS`state`redex) > 0")
          (("1" (grind) nil nil)
           ("2" (case "pop?(nS`state`redex)")
            (("1" (assert) (("1" (grind) nil nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (estate type-eq-decl nil reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC51 0
  (typed_reduce_TCC51-1 nil 3701780462
   ("" (skeep* :preds? t)
    (("" (expand popReduce)
      (("" (expand pop)
        (("" (expand tail)
          (("" (typepred "nS`stack_types")
            (("" (split)
              (("1" (propax) nil nil)
               ("2" (skeep) (("2" (inst?) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((popReduce const-decl "estate" reduction nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (> const-decl "bool" reals nil)
    (nonempty_fs type-eq-decl nil finseq_theorems nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (pop const-decl "Stack" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC52 0
  (typed_reduce_TCC52-1 nil 3702649677
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil)) nil)
   ((typed_state type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (estate type-eq-decl nil reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (to_topstate const-decl "topstate" reduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC53 0
  (typed_reduce_TCC53-1 nil 3702649677
   ("" (skeep* :preds? t)
    (("" (rewrite value_well_typed)
      (("1" (split)
        (("1" (typepred "nS`redex_type")
          (("1" (expand popRedex?)
            (("1" (flatten)
              (("1" (assert)
                (("1" (expand is_well_typed -)
                  (("1" (flatten) (("1" (grind) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand popReduce)
          (("2" (lift-if)
            (("2" (split)
              (("1" (flatten)
                (("1" (typepred "nS`redex_type")
                  (("1" (expand popRedex?)
                    (("1" (flatten)
                      (("1" (assert)
                        (("1" (expand is_well_typed)
                          (("1" (flatten)
                            (("1" (rewrite value_well_typed) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (expand popRedex?)
                  (("2" (flatten)
                    (("2" (assert)
                      (("2" (typepred "nS`redex_type")
                        (("2" (expand is_well_typed)
                          (("2" (flatten)
                            (("2" (assert)
                              (("2"
                                (case
                                 "variable?(pbody(nS`state`redex))")
                                (("1"
                                  (assert)
                                  (("1"
                                    (expand is_well_typed)
                                    (("1"
                                      (typepred "nS`stack_types")
                                      (("1"
                                        (expand get)
                                        (("1"
                                          (inst? -2)
                                          (("1" (grind) nil nil)
                                           ("2"
                                            (typepred "nS`state`redex")
                                            (("2"
                                              (inst
                                               -2
                                               "index(pbody(nS`state`redex)) - 1")
                                              (("1" (grind) nil nil)
                                               ("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand popReduce)
        (("2" (lift-if)
          (("2" (split)
            (("1" (grind) nil nil)
             ("2" (flatten)
              (("2"
                (typepred "get(nS`state`stack)(pbody(nS`state`redex))")
                (("2" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((value_well_typed formula-decl nil typed_reduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (estate type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (> const-decl "bool" reals nil)
    (nonempty_fs type-eq-decl nil finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (ptbody adt-accessor-decl "[(popt?) -> typeinfo]" typeinfo_adt nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (popRedex? const-decl "bool" IL nil)
    (popReduce const-decl "estate" reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt
     nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (singleton const-decl "(singleton?)" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (get const-decl "(value?)" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (typed_to_topstate const-decl "typed_state" typed_reduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (make_redex_typed const-decl "typed_state" typed_reduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC54 0
  (typed_reduce_TCC54-1 nil 3702649677
   ("" (skeep* :preds? t)
    (("" (case-replace "popDepth(popReduce(D)(nS`state)`redex) = 0")
      (("1" (expand popReduce +)
        (("1" (typepred "nS`context_type")
          (("1" (case-replace "popDepth(nS`state`redex) = 1")
            (("1"
              (case-replace
               "popn(nS`stack_types, 1) = popn(tail[nat](nS`stack_types), 0)")
              (("1"
                (case-replace
                 "expr_type(nS`redex_type) = expr_type(ptbody(nS`redex_type))")
                (("1" (typepred "nS`redex_type")
                  (("1" (expand popRedex?)
                    (("1" (flatten)
                      (("1" (assert)
                        (("1" (expand is_well_typed -1)
                          (("1" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand tail)
                (("2" (expand popn) (("2" (propax) nil nil)) nil))
                nil))
              nil)
             ("2" (expand popRedex?)
              (("2" (flatten)
                (("2" (assert)
                  (("2" (expand popDepth)
                    (("2" (hide-all-but (1 -6)) (("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand popReduce)
        (("2" (lift-if)
          (("2" (split)
            (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)
             ("2" (hide-all-but 1)
              (("2" (flatten)
                (("2"
                  (case "value?(get(nS`state`stack)(pbody(nS`state`redex)))")
                  (("1" (grind) nil nil)
                   ("2"
                    (typepred
                     "get(nS`state`stack)(pbody(nS`state`redex))")
                    (("2" (propax) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (popRedex? const-decl "bool" IL nil)
    (popReduce const-decl "estate" reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_state type-eq-decl nil typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (nonempty_fs type-eq-decl nil finseq_theorems nil)
    (> const-decl "bool" reals nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (ptbody adt-accessor-decl "[(popt?) -> typeinfo]" typeinfo_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (get const-decl "(value?)" IL nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil)))

