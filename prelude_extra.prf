(list2finseq_extra
 (finseq2list_length_rec 0
  (finseq2list_length_rec-1 nil 3703275952
   ("" (induct n) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (finseq2list_rec def-decl "list[T]" list2finseq nil)
    (length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (T formal-type-decl nil list2finseq_extra nil)
    (below type-eq-decl nil nat_types nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (finseq2list_length 0
  (finseq2list_length-1 nil 3703275469
   ("" (lemma finseq2list_length_rec) (("" (grind) nil nil)) nil)
   ((finseq2list const-decl "list[T]" list2finseq nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (T formal-type-decl nil list2finseq_extra nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq2list_length_rec formula-decl nil list2finseq_extra nil))
   shostak))
 (finseq2list_nth_rec_TCC1 0
  (finseq2list_nth_rec_TCC1-1 nil 3703275951 ("" (subtype-tcc) nil nil)
   nil nil))
 (finseq2list_nth_rec_TCC2 0
  (finseq2list_nth_rec_TCC2-1 nil 3703275951 ("" (subtype-tcc) nil nil)
   nil nil))
 (finseq2list_nth_rec 0
  (finseq2list_nth_rec-1 nil 3703275978
   ("" (induct i)
    (("1" (grind) nil nil)
     ("2" (skeep* :preds? t)
      (("2" (expand finseq2list_rec)
        (("2" (case "n = 0")
          (("1" (grind) nil nil)
           ("2" (assert)
            (("2" (expand nth +) (("2" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil)
     ("3" (grind) nil nil)
     ("4" (skeep) (("4" (rewrite finseq2list_length_rec) nil nil))
      nil))
    nil)
   ((finseq2list_length_rec formula-decl nil list2finseq_extra nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (T formal-type-decl nil list2finseq_extra nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (list type-decl nil list_adt nil)
    (length def-decl "nat" list_props nil)
    (finseq2list_rec def-decl "list[T]" list2finseq nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (finseq2list_nth_TCC1 0
  (finseq2list_nth_TCC1-1 nil 3703275468 ("" (subtype-tcc) nil nil) nil
   nil))
 (finseq2list_nth 0
  (finseq2list_nth-1 nil 3703275605
   ("" (skeep* :preds? t)
    (("" (expand finseq2list)
      (("" (rewrite finseq2list_nth_rec) nil nil)) nil))
    nil)
   ((finseq2list const-decl "list[T]" list2finseq nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (T formal-type-decl nil list2finseq_extra nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq2list_nth_rec formula-decl nil list2finseq_extra nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak))
 (list2finseq_finseq2list 0
  (list2finseq_finseq2list-1 nil 3703276068
   ("" (skeep*)
    (("" (expand list2finseq)
      (("" (decompose-equality)
        (("1" (rewrite finseq2list_length) nil nil)
         ("2" (decompose-equality)
          (("2" (rewrite finseq2list_nth)
            (("2" (typepred "x!1")
              (("2" (rewrite finseq2list_length) nil nil)) nil))
            nil))
          nil)
         ("3" (skeep)
          (("3" (rewrite finseq2list_length) (("3" (assert) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((list2finseq const-decl "finseq[T]" list2finseq nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finseq2list_nth formula-decl nil list2finseq_extra nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq2list_length formula-decl nil list2finseq_extra nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (T formal-type-decl nil list2finseq_extra nil)
    (list type-decl nil list_adt nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (finseq2list const-decl "list[T]" list2finseq nil)
    (nth def-decl "T" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil) nil)
   shostak))
 (list2finseq_inj 0
  (list2finseq_inj-1 nil 3703276701
   ("" (induct l1)
    (("1" (skeep)
      (("1" (iff)
        (("1" (split)
          (("1" (grind) nil nil)
           ("2" (flatten)
            (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil)
     ("2" (skeep*)
      (("2" (iff)
        (("2" (split)
          (("1" (flatten)
            (("1" (decompose-equality +)
              (("1" (case-replace "car(l2) = list2finseq(l2)`seq(0)")
                (("1" (replace -2 :dir RL) (("1" (grind) nil nil)) nil)
                 ("2" (grind) nil nil) ("3" (grind) nil nil))
                nil)
               ("2" (inst -2 "cdr(l2)")
                (("2" (replace -2 :dir RL)
                  (("2" (delete -2)
                    (("2" (decompose-equality)
                      (("1" (case "cons?(l2)")
                        (("1" (assert) (("1" (grind) nil nil)) nil)
                         ("2" (grind) nil nil))
                        nil)
                       ("2" (case "cons?(l2)")
                        (("1" (decompose-equality)
                          (("1" (expand list2finseq)
                            (("1" (expand nth -)
                              (("1"
                                (flatten)
                                (("1"
                                  (grind)
                                  (("1"
                                    (decompose-equality)
                                    (("1"
                                      (inst -1 "x!1 + 1")
                                      (("1" (grind) nil nil)
                                       ("2"
                                        (grind)
                                        (("2"
                                          (typepred "x!1")
                                          (("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (grind) nil nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((l2 skolem-const-decl "list[T]" list2finseq_extra nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nth def-decl "T" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (< const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (cons2_var skolem-const-decl "list[T]" list2finseq_extra nil)
    (x!1 skolem-const-decl "below[list2finseq(cons2_var)`length]"
     list2finseq_extra nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (length def-decl "nat" list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil list2finseq_extra nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (finseq2list_list2finseq 0
  (finseq2list_list2finseq-1 nil 3703276137
   ("" (skeep)
    ((""
      (case "list2finseq(finseq2list(list2finseq(l))) = list2finseq(l)")
      (("1" (rewrite list2finseq_inj) nil nil)
       ("2" (rewrite list2finseq_finseq2list) nil nil))
      nil))
    nil)
   ((finseq2list const-decl "list[T]" list2finseq nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (T formal-type-decl nil list2finseq_extra nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list2finseq_inj formula-decl nil list2finseq_extra nil)
    (list2finseq_finseq2list formula-decl nil list2finseq_extra nil))
   shostak)))

