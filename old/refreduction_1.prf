(refreduction
 (refcountStore_TCC1 0
  (refcountStore_TCC1-1 nil 3650675711
   ("" (skeep)
    (("" (rewrite "empty_card") (("" (ground) nil nil)) nil)) nil)
   ((empty_card formula-decl nil finite_sets nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (refcountStore_TCC2 0
  (refcountStore_TCC2-1 nil 3650675711
   ("" (skeep)
    (("" (rewrite "empty_card") (("" (ground) nil nil)) nil)) nil)
   ((empty_card formula-decl nil finite_sets nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (refcountStore_TCC3 0
  (refcountStore_TCC3-1 nil 3652501920 ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (integer nonempty-type-from-decl nil integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil) (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil))
   nil))
 (refcountExpr_popit 0
  (refcountExpr_popit-1 nil 3683904062
   ("" (skeep)
    (("" (expand "refcountExpr") (("" (rewrite "popit_refs") nil nil))
      nil))
    nil)
   ((refcountExpr const-decl "nat" refcount nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (popit_refs formula-decl nil reduction nil))
   shostak))
 (allcount_TCC1 0
  (allcount_TCC1-1 nil 3684597206 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (allcount_TCC2 0
  (allcount_TCC2-1 nil 3684597206 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (allcount_TCC3 0
  (allcount_TCC3-1 nil 3684597206 ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (integer nonempty-type-from-decl nil integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil))
   nil))
 (finite_enumeration_inverse_TCC1 0
  (finite_enumeration_inverse_TCC1-1 nil 3692735784
   ("" (skeep)
    (("" (inst + 0)
      (("" (use "card_is_0")
        (("" (expand "emptyset") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (dom skolem-const-decl "finite_set[nat]" refreduction nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (card_is_0 formula-decl nil finite_sets nil))
   nil))
 (finite_enumeration_inverse 0
  (finite_enumeration_inverse-1 nil 3692735785
   ("" (skeep)
    (("" (rewrite "inverse_surjective")
      (("" (use "finite_enumeration_bij")
        (("" (expand "bijective?") (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((inverse_surjective formula-decl nil function_inverse nil)
    (surjective? const-decl "bool" functions nil)
    (finite_enumeration const-decl "[below[card(X)] -> (X)]"
     finite_enumeration "sigma_set/")
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (bijective? const-decl "bool" functions nil)
    (finite_enumeration_bij formula-decl nil finite_enumeration
     "sigma_set/"))
   shostak))
 (rstate_TCC1 0
  (rstate_TCC1-1 nil 3693496106 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (Stack type-eq-decl nil IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (refcountStore_ref 0
  (refcountStore_ref-1 nil 3685183232
   ("" (skeep :preds? t)
    (("" (expand "refcountStore")
      (("" (ground)
        (("" (lift-if)
          (("" (ground)
            (("1" (grind) nil nil)
             ("2"
              (rewrite "sigma_split" :subst
               ("z" "inverse(finite_enumeration(rS`domain))(r)"))
              (("1" (rewrite "sigma")
                (("1" (use "sigma_ge_0[below[card(rS`domain)]]")
                  (("1"
                    (use "sigma_ge_0[below[card(rS`domain)]]" :subst
                         ("low"
                          "1 + inverse(finite_enumeration(rS`domain))(r)"))
                    (("1" (ground)
                      (("1" (rewrite "o")
                        (("1" (rewrite "inverse_surjective")
                          (("1" (expand "refcountArray")
                            (("1"
                              (lemma "recompose" :subst
                               ("S" "rS`store(r)"))
                              (("1"
                                (inst - "j+ 1")
                                (("1"
                                  (replace -1 :dir RL :hide? t)
                                  (("1"
                                    (rewrite "count_compose")
                                    (("1"
                                      (rewrite "lsplit")
                                      (("1"
                                        (rewrite "count")
                                        (("1"
                                          (rewrite "finseqtolist")
                                          (("1"
                                            (rewrite "count")
                                            (("1"
                                              (expand "head")
                                              (("1"
                                                (expand "finseq_appl")
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (use "finite_enumeration_bij")
                            (("2" (expand "bijective?")
                              (("2" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide-all-but 1) (("2" (grind) nil nil))
                        nil)
                       ("3" (hide-all-but 1) (("3" (grind) nil nil))
                        nil)
                       ("4" (grind) nil nil))
                      nil)
                     ("2" (hide-all-but 1) (("2" (grind) nil nil))
                      nil))
                    nil)
                   ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil))
                  nil)
                 ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcountStore const-decl "nat" refcount nil)
    (integer nonempty-type-from-decl nil integers nil)
    (sigma_split formula-decl nil sigma "reals/")
    (O const-decl "T3" function_props nil)
    (refcountArray const-decl "nat" refcount nil)
    (finite_enumeration const-decl "[below[card(X)] -> (X)]"
     finite_enumeration "sigma_set/")
    (T_high type-eq-decl nil sigma "reals/")
    (T_low type-eq-decl nil sigma "reals/")
    (inverse const-decl "D" function_inverse nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sigma_ge_0 formula-decl nil sigma "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (surjective? const-decl "bool" functions nil)
    (inverse_surjective formula-decl nil function_inverse nil)
    (recompose formula-decl nil finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (O const-decl "finseq" finite_sequences nil)
    (bijective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (count def-decl "nat" finseq_theorems nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (> const-decl "bool" reals nil)
    (nonempty_fs type-eq-decl nil finseq_theorems nil)
    (head const-decl "T" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (count const-decl "nat" finseq_theorems nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (count_compose formula-decl nil finseq_theorems nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (lsplit const-decl "finseq[T]" finseq_theorems nil)
    (rsplit const-decl "finseq[T]" finseq_theorems nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (finite_enumeration_bij formula-decl nil finite_enumeration
     "sigma_set/")
    (subrange type-eq-decl nil integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (sigma def-decl "real" sigma "reals/")
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refcount nil)
    (rstate type-eq-decl nil refcount nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (sigma_nat application-judgement "nat" sigma "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (refcountArray_update_TCC1 0
  (refcountArray_update_TCC1-1 nil 3692674266
   ("" (subtype-tcc) nil nil) ((value? const-decl "bool" IL nil)) nil))
 (refcountArray_update 0
  (refcountArray_update-1 nil 3692674266
   ("" (skeep)
    (("" (expand "refcountArray")
      (("" (rewrite "count_update")
        (("1" (assert) nil nil) ("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((refcountArray const-decl "nat" refcount nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (value? const-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (count_update formula-decl nil finseq_theorems nil))
   shostak))
 (store_update_TCC1 0
  (store_update_TCC1-1 nil 3692717400 ("" (subtype-tcc) nil nil)
   ((value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil))
   nil))
 (store_update_TCC2 0
  (store_update_TCC2-1 nil 3692717400 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (below type-eq-decl nil naturalnumbers nil))
   nil))
 (store_update 0
  (store_update-1 nil 3692717400
   ("" (skeep)
    (("" (case "r = k") (("1" (assert) nil nil) ("2" (assert) nil nil))
      nil))
    nil)
   ((rstate type-eq-decl nil refcount nil)
    (refcount const-decl "nat" refcount nil)
    (Store type-eq-decl nil reduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (refcountStore_update 0
  (refcountStore_update-1 nil 3692670917
   ("" (skeep)
    (("" (expand "refcountStore")
      (("" (lift-if)
        (("" (ground)
          (("1" (expand "empty?")
            (("1" (inst - "r") (("1" (grind) nil nil)) nil)) nil)
           ("2" (expand "o")
            (("2"
              (case-replace "(LAMBDA (x: below[card(rS`domain)]):
                 refcountArray(rS`store WITH [(r)`seq(j) := nil]
                                   (finite_enumeration(rS`domain)(x)))
                              (i)) = (LAMBDA (x: below[card(rS`domain)]):
                  refcountArray(rS`store(finite_enumeration(rS`domain)(x)))(i)) WITH [(inverse(finite_enumeration(rS`domain))(r)) := refcountArray(rS`store(r))(i) - 1]"
               :hide? t)
              (("1" (lemma "sigma_with[below(card(rS`domain))]")
                (("1"
                  (inst - "(lambda (x: below[card(rS`domain)]):
                      refcountArray(rS`store(finite_enumeration(rS`domain)(x)))(i))
                     WITH [(inverse(finite_enumeration(rS`domain))(r))
                             := refcountArray(rS`store(r))(i) - 1]"
                   "(lambda (x: below[card(rS`domain)]):
                      refcountArray(rS`store(finite_enumeration(rS`domain)(x)))(i))"
                   "refcountArray(rS`store(r))(i) - 1"
                   "card(rS`domain) - 1"
                   "(inverse(finite_enumeration(rS`domain))(r))" "0")
                  (("1" (ground)
                    (("1" (replace -1 :hide? t)
                      (("1" (rewrite "inverse_surjective")
                        (("1" (assert) nil nil)
                         ("2" (use "finite_enumeration_bij")
                          (("2" (expand "bijective?")
                            (("2" (propax) nil nil)) nil))
                          nil)
                         ("3" (inst + "card[nat](rS`domain) - 1") nil
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (inst + "card[nat](rS`domain) - 1")
                    (("2" (assert) nil nil)) nil))
                  nil)
                 ("2" (grind) nil nil))
                nil)
               ("2" (hide 3)
                (("2" (apply-extensionality)
                  (("1" (hide 2)
                    (("1" (auto-rewrite! "store_update")
                      (("1" (assert)
                        (("1" (lift-if)
                          (("1" (ground)
                            (("1" (rewrite "refcountArray_update")
                              (("1"
                                (replace -1)
                                (("1"
                                  (rewrite "inverse_injective")
                                  (("1" (assert) nil nil)
                                   ("2"
                                    (use "finite_enumeration_bij")
                                    (("2"
                                      (expand "bijective?")
                                      (("2" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("3"
                                    (inst + "card[nat](rS`domain) - 1")
                                    nil
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (replace -1)
                                (("2"
                                  (rewrite "inverse_injective")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (replace -2)
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (use "finite_enumeration_bij")
                                    (("2"
                                      (expand "bijective?")
                                      (("2" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("3"
                                    (inst + "card[nat](rS`domain) - 1")
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (lift-if)
                              (("2"
                                (ground)
                                (("2"
                                  (replace -1)
                                  (("2"
                                    (rewrite "inverse_surjective")
                                    (("1"
                                      (use "finite_enumeration_bij")
                                      (("1"
                                        (expand "bijective?")
                                        (("1" (propax) nil nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (inst
                                       +
                                       "card[nat](rS`domain) - 1")
                                      nil
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide 2)
                    (("2" (expand "refcountArray")
                      (("2" (use "count_elem[(value?)]")
                        (("2" (ground)
                          (("1" (inst?) (("1" (assert) nil nil)) nil)
                           ("2" (replace -1) (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (inst + "card[nat](rS`domain) - 1") nil nil)
                   ("4" (grind) nil nil))
                  nil))
                nil)
               ("3" (expand "refcountArray")
                (("3" (hide 3)
                  (("3" (use "count_elem[(value?)]")
                    (("3" (grind) nil nil)) nil))
                  nil))
                nil)
               ("4" (inst + "card[nat](rS`domain) - 1")
                (("4" (assert)
                  (("4" (use "card_is_0") (("4" (grind) nil nil)) nil))
                  nil))
                nil)
               ("5" (hide 3) (("5" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcountStore const-decl "nat" refcount nil)
    (sigma_nat application-judgement "nat" sigma "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (refcount const-decl "nat" refcount nil)
    (rstate type-eq-decl nil refcount nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (refcountArray const-decl "nat" refcount nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (finite_enumeration const-decl "[below[card(X)] -> (X)]"
     finite_enumeration "sigma_set/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (inverse const-decl "D" function_inverse nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (count const-decl "nat" finseq_theorems nil)
    (head const-decl "T" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (sigma def-decl "real" sigma "reals/")
    (T_low type-eq-decl nil sigma "reals/")
    (T_high type-eq-decl nil sigma "reals/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finite_enumeration_bij formula-decl nil finite_enumeration
     "sigma_set/")
    (bijective? const-decl "bool" functions nil)
    (inverse_surjective formula-decl nil function_inverse nil)
    (surjective? const-decl "bool" functions nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (integer nonempty-type-from-decl nil integers nil)
    (sigma_with formula-decl nil sigma "reals/")
    (refcountArray_update formula-decl nil refcount nil)
    (inverse_injective formula-decl nil function_inverse nil)
    (store_update formula-decl nil refcount nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (count_elem formula-decl nil finseq_theorems nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (card_is_0 formula-decl nil finite_sets nil)
    (O const-decl "T3" function_props nil))
   shostak))
 (allcountStore_decrease_TCC1 0
  (allcountStore_decrease_TCC1-1 nil 3692982211
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil))
   nil))
 (allcountStore_decrease_TCC2 0
  (allcountStore_decrease_TCC2-1 nil 3692982211
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil))
   nil))
 (allcountStore_decrease 0
  (allcountStore_decrease-1 nil 3692982211
   ("" (skeep*)
    (("" (expand "allcountStore")
      (("" (expand "allcount")
        (("" (lift-if)
          (("" (ground)
            (("1" (use "card_is_0")
              (("1" (assert)
                (("1" (expand "emptyset")
                  (("1" (case "rS1`domain(s)")
                    (("1" (replace -2) (("1" (grind) nil nil)) nil)
                     ("2" (typepred "s") (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2"
              (use "sigma_split[below(card(rS1`domain))]" :subst
                   ("low" 0 "z"
                    "inverse(finite_enumeration(rS1`domain))(s)"))
              (("1" (ground)
                (("1" (replace -1 :hide? t)
                  (("1"
                    (use "sigma_split[below(card(rS`domain))]" :subst
                         ("low" 0 "z"
                          "inverse(finite_enumeration(rS`domain))(s)"))
                    (("1" (ground)
                      (("1" (replace -1 :hide? t)
                        (("1" (rewrite "sigma")
                          (("1" (expand "sigma" + :occurrence 3)
                            (("1" (expand "o")
                              (("1"
                                (rewrite "finite_enumeration_inverse")
                                (("1"
                                  (rewrite
                                   "finite_enumeration_inverse")
                                  (("1"
                                    (case
                                     "sigma[below(card(rS1`domain))](0, inverse(finite_enumeration(rS1`domain))(s) - 1,
                                           LAMBDA (x: below[card(rS1`domain)]):
                                             rS1`count(finite_enumeration(rS1`domain)(x))) = sigma[below(card(rS`domain))](0, inverse(finite_enumeration(rS`domain))(s) - 1,
                                            LAMBDA (x: below[card(rS`domain)]):
                                              rS`count(finite_enumeration(rS`domain)(x)))")
                                    (("1"
                                      (replace -1 :hide? t)
                                      (("1"
                                        (case-replace
                                         "sigma[below[card(rS1`domain)]](1 + inverse(finite_enumeration(rS1`domain))(s),
                         card(rS1`domain) - 1,
                         LAMBDA (x: below[card(rS1`domain)]):
                           rS1`count(finite_enumeration(rS1`domain)(x))) = sigma[below[card(rS`domain)]](1 + inverse(finite_enumeration(rS`domain))(s),
                          card(rS`domain) - 1,
                          LAMBDA (x: below[card(rS`domain)]):
                            rS`count(finite_enumeration(rS`domain)(x)))"
                                         :hide?
                                         t)
                                        (("1"
                                          (inst?)
                                          (("1" (assert) nil nil))
                                          nil)
                                         ("2"
                                          (hide 3)
                                          (("2"
                                            (same-name
                                             "sigma[below[card(rS1`domain)]]"
                                             "sigma[below[card(rS`domain)]]")
                                            (("1"
                                              (replace -1)
                                              (("1"
                                                (lemma
                                                 "sigma_eq[below[card(rS`domain)]]")
                                                (("1"
                                                  (inst?)
                                                  (("1"
                                                    (inst
                                                     -
                                                     "lambda (x: below[card(rS`domain)]):
                                rS`count(finite_enumeration(rS`domain)(x))")
                                                    (("1"
                                                      (ground)
                                                      (("1"
                                                        (replace -3)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (replace
                                                             -1)
                                                            (("1"
                                                              (same-name
                                                               "inverse[below(card(rS1`domain)), (rS1`domain)]"
                                                               "inverse[below(card(rS`domain)), (rS`domain)]")
                                                              (("1"
                                                                (replace
                                                                 -1)
                                                                (("1"
                                                                  (propax)
                                                                  nil
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (hide
                                                                 -1
                                                                 2)
                                                                (("2"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (hide 2)
                                                        (("2"
                                                          (skeep
                                                           :preds?
                                                           t)
                                                          (("2"
                                                            (inst
                                                             -
                                                             "finite_enumeration(rS1`domain)(n)")
                                                            (("1"
                                                              (ground)
                                                              (("1"
                                                                (replace
                                                                 -1
                                                                 :dir
                                                                 RL)
                                                                (("1"
                                                                  (rewrite
                                                                   "inverse_injective")
                                                                  (("1"
                                                                    (assert)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (use
                                                                     "finite_enumeration_bij")
                                                                    (("2"
                                                                      (expand
                                                                       "bijective?")
                                                                      (("2"
                                                                        (propax)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (hide 2)
                                                    (("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (hide 2)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (hide 3)
                                      (("2"
                                        (same-name
                                         "sigma[below[card(rS1`domain)]]"
                                         "sigma[below[card(rS`domain)]]")
                                        (("1"
                                          (replace -1)
                                          (("1"
                                            (lemma
                                             "sigma_eq[below[card(rS`domain)]]")
                                            (("1"
                                              (inst?)
                                              (("1"
                                                (inst
                                                 -
                                                 "lambda (x: below[card(rS`domain)]):
                                                rS`count(finite_enumeration(rS`domain)(x))")
                                                (("1"
                                                  (ground)
                                                  (("1"
                                                    (replace -3)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (replace -1)
                                                        (("1"
                                                          (same-name
                                                           "inverse[below(card(rS1`domain)), (rS1`domain)]"
                                                           "inverse[below(card(rS`domain)), (rS`domain)]")
                                                          (("1"
                                                            (replace
                                                             -1)
                                                            (("1"
                                                              (propax)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (hide 2)
                                                            (("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (hide 2)
                                                    (("2"
                                                      (skeep :preds? t)
                                                      (("2"
                                                        (inst
                                                         -
                                                         "finite_enumeration(rS1`domain)(n)")
                                                        (("1"
                                                          (ground)
                                                          (("1"
                                                            (replace
                                                             -1
                                                             :dir
                                                             RL)
                                                            (("1"
                                                              (rewrite
                                                               "inverse_injective")
                                                              (("1"
                                                                (assert)
                                                                nil
                                                                nil)
                                                               ("2"
                                                                (use
                                                                 "finite_enumeration_bij")
                                                                (("2"
                                                                  (expand
                                                                   "bijective?")
                                                                  (("2"
                                                                    (propax)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (hide 2)
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (hide 2)
                                          (("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("3"
                                      (hide 3)
                                      (("3" (grind) nil nil))
                                      nil)
                                     ("4"
                                      (hide 3)
                                      (("4" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide 3) (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide 3) (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (hide 3) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((allcountStore const-decl "nat" refcount nil)
    (integer nonempty-type-from-decl nil integers nil)
    (sigma_split formula-decl nil sigma "reals/")
    (T_low type-eq-decl nil sigma "reals/")
    (inverse const-decl "D" function_inverse nil)
    (finite_enumeration const-decl "[below[card(X)] -> (X)]"
     finite_enumeration "sigma_set/")
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (below type-eq-decl nil naturalnumbers nil)
    (O const-decl "T3" function_props nil)
    (T_high type-eq-decl nil sigma "reals/")
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (sigma def-decl "real" sigma "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (inverse_injective formula-decl nil function_inverse nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (bijective? const-decl "bool" functions nil)
    (finite_enumeration_bij formula-decl nil finite_enumeration
     "sigma_set/")
    (subrange type-eq-decl nil integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sigma_eq formula-decl nil sigma "reals/")
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (finite_enumeration_inverse formula-decl nil refcount nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (card_is_0 formula-decl nil finite_sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (rstate type-eq-decl nil refcount nil)
    (refcount const-decl "nat" refcount nil)
    (Store type-eq-decl nil reduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (emptyset const-decl "set" sets nil)
    (sigma_nat application-judgement "nat" sigma "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (allcount const-decl "nat" refcount nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (decref_TCC1 0
  (decref_TCC1-1 nil 3692915538 ("" (subtype-tcc) nil nil)
   ((rstate type-eq-decl nil refreduction nil)
    (refcount const-decl "nat" refreduction nil)
    (Store type-eq-decl nil reduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (allcountStore const-decl "nat" refreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (decref_TCC2 0
  (decref_TCC2-1 nil 3692915538 ("" (subtype-tcc) nil nil)
   ((allcountStore const-decl "nat" refreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (decref_TCC3 0
  (decref_TCC3-1 nil 3692915538 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (decref_TCC4 0
  (decref_TCC4-1 nil 3692915538 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (decref_TCC5 0
  (decref_TCC5-1 nil 3692915538 ("" (subtype-tcc) nil nil)
   ((value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil))
   nil))
 (decref_TCC6 0
  (decref_TCC6-1 nil 3692915538
   ("" (skeep*)
    (("" (expand "refcount")
      (("" (rewrite "refcountStore_update")
        (("1" (ground)
          (("1" (typepred "rS`count(subrefindex)")
            (("1" (replace -1 :hide? t)
              (("1" (expand "refcount")
                (("1" (use "refcountStore_ref")
                  (("1" (ground)
                    (("1" (case "ref(refindex(subref)) = subref")
                      (("1" (assert) nil nil)
                       ("2" (apply-extensionality :hide? t) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (typepred "rS`count(subrefindex)")
            (("2" (expand "refcount") (("2" (assert) nil nil)) nil))
            nil))
          nil)
         ("2" (case "ref(refindex(subref)) = subref")
          (("1" (assert) nil nil)
           ("2" (apply-extensionality :hide? t) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (refcount const-decl "nat" refreduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (refcountStore_ref formula-decl nil refreduction nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (rstate type-eq-decl nil refreduction nil)
    (Store type-eq-decl nil reduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (refcountStore_update formula-decl nil refreduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (decref_TCC7 0
  (decref_TCC7-1 nil 3692915538 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (decref_TCC8 0
  (decref_TCC8-1 nil 3692915538
   ("" (skeep*)
    (("" (replace -6 :hide? t)
      (("" (assert)
        (("" (case "r = subrefindex")
          (("1" (assert) nil nil) ("2" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((rstate type-eq-decl nil refreduction nil)
    (refcount const-decl "nat" refreduction nil)
    (Store type-eq-decl nil reduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (decref_TCC9 0
  (decref_TCC9-1 nil 3692915538
   ("" (skeep*)
    (("" (rewrite "lex2_lt")
      (("" (flatten)
        (("" (lemma "allcountStore_decrease")
          (("" (inst?)
            (("" (inst - "subrefindex") (("" (ground) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lex2_lt formula-decl nil lex2 nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (allcountStore const-decl "nat" refreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (allcountStore_decrease formula-decl nil refreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (decref_TCC10 0
  (decref_TCC10-1 nil 3692915538 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (decref_TCC11 0
  (decref_TCC11-1 nil 3692915538
   ("" (subtype-tcc)
    ((""
      (typepred "v!1(rS!1
             WITH [`store(r!1)`seq(i!1 - 1) := nil,
                   `count(refindex(rS!1`store(r!1)`seq(i!1 - 1)))
                     := rS!1`count(refindex(rS!1`store(r!1)`seq(i!1 - 1)))
                         - 1],
           refindex(rS!1`store(r!1)`seq(i!1 - 1)),
           rS!1`store(refindex(rS!1`store(r!1)`seq(i!1 - 1)))`length)")
      (("1" (typepred "i!1")
        (("1" (inst? -4) (("1" (ground) nil nil)) nil)) nil)
       ("2" (assert)
        (("2" (case "refindex(rS!1`store(r!1)`seq(i!1 - 1)) = r!1")
          (("1" (assert) nil nil) ("2" (assert) nil nil)) nil))
        nil)
       ("3" (use "decref_TCC6")
        (("3" (assert)
          (("3" (inst?)
            (("3" (assert)
              (("3" (inst?)
                (("3" (assert) (("3" (inst?) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (< def-decl "bool" ordinals nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (allcountStore const-decl "nat" refreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (refcountStore const-decl "nat" refreduction nil)
    (refcountExpr const-decl "nat" refreduction nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountStack const-decl "nat" refreduction nil)
    (decref_TCC6 subtype-tcc nil refreduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (decref_TCC12 0
  (decref_TCC12-1 nil 3692915538
   ("" (skeep*)
    (("" (rewrite "lex2_lt")
      (("" (lift-if)
        (("" (ground)
          ((""
            (typepred "v(rS
             WITH [`store(r)`seq(i - 1) := nil,
                   `count(refindex(subref))
                     := rS`count(refindex(subref)) - 1],
           refindex(subref), rS`store(refindex(subref))`length)")
            (("1" (hide -2 -3)
              (("1" (assert)
                (("1" (lemma "allcountStore_decrease")
                  (("1"
                    (inst - "rS" "rS
                       WITH [`store(r)`seq(i - 1) := nil,
                             `count(refindex(subref))
                               := rS`count(refindex(subref)) - 1]"
                     "refindex(subref)")
                    (("1" (ground) nil nil)
                     ("2" (hide -1)
                      (("2" (use "decref_TCC6")
                        (("2" (assert)
                          (("2" (inst?)
                            (("2" (assert)
                              (("2"
                                (inst?)
                                (("2"
                                  (assert)
                                  (("2" (inst?) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("3" (hide -1) (("3" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (assert)
              (("2" (case "r = refindex(subref)")
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil))
              nil)
             ("3" (use "decref_TCC6")
              (("3" (assert)
                (("3" (inst?)
                  (("3" (assert)
                    (("3" (inst?)
                      (("3" (assert) (("3" (inst?) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("4" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lex2_lt formula-decl nil lex2 nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (allcountStore const-decl "nat" refreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (allcountStore_decrease formula-decl nil refreduction nil)
    (decref_TCC6 subtype-tcc nil refreduction nil)
    (i skolem-const-decl "upto(rS`store(r)`length)" refreduction nil)
    (r skolem-const-decl "(rS`domain)" refreduction nil)
    (subref skolem-const-decl "(domainValue?(rS`domain))" refreduction
     nil)
    (rS skolem-const-decl "rstate" refreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (decref_TCC13 0
  (decref_TCC13-1 nil 3692915538
   ("" (skeep*)
    (("" (ground)
      (("1" (lift-if)
        (("1" (ground)
          (("1"
            (typepred "v(rS
                           WITH [`store(r)`seq(i - 1) := nil,
                                 `count(refindex(subref))
                                   := rS`count(refindex(subref)) - 1],
                         refindex(subref), rS`store(refindex(subref))`length)")
            (("1" (hide -2 -3)
              (("1" (lemma "allcountStore_decrease")
                (("1"
                  (inst - "rS" "rS
                                   WITH [`store(r)`seq(i - 1) := nil,
                                         `count(refindex(subref))
                                           := rS`count(refindex(subref)) - 1]"
                   "refindex(subref)")
                  (("1" (ground) nil nil)
                   ("2" (use "decref_TCC6")
                    (("2" (assert)
                      (("2" (inst?)
                        (("2" (assert)
                          (("2" (inst?)
                            (("2" (assert) (("2" (inst?) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (hide -1) (("3" (grind) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (case "r = refindex(subref)")
              (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
             ("3" (use "decref_TCC6")
              (("3" (assert)
                (("3" (inst?)
                  (("3" (assert)
                    (("3" (inst?)
                      (("3" (assert) (("3" (inst?) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("4" (grind) nil nil))
            nil))
          nil))
        nil)
       ("2" (typepred "v(newrS, r, i - 1)")
        (("1" (hide -3) (("1" (grind) nil nil)) nil)
         ("2" (grind) nil nil) ("3" (grind) nil nil))
        nil)
       ("3" (typepred "v(newrS, r, i - 1)")
        (("1" (skeep)
          (("1" (inst?)
            (("1" (lift-if)
              (("1" (split -)
                (("1" (flatten)
                  (("1"
                    (typepred "v(rS
                     WITH [`store(r)`seq(i - 1) := nil,
                           `count(refindex(subref))
                             := rS`count(refindex(subref)) - 1],
                   refindex(subref), rS`store(refindex(subref))`length)")
                    (("1" (hide -1 -2)
                      (("1" (inst - "s")
                        (("1" (case "r = s")
                          (("1" (ground)
                            (("1" (replace -10)
                              (("1"
                                (replace -7 +)
                                (("1"
                                  (replace -4)
                                  (("1" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (ground)
                            (("2" (case "s = refindex(subref)")
                              (("1" (assert) nil nil)
                               ("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (case "r = refindex(subref)")
                      (("1" (assert) nil nil) ("2" (assert) nil nil))
                      nil)
                     ("3" (hide 2)
                      (("3" (use "decref_TCC6")
                        (("3" (assert)
                          (("3" (inst?)
                            (("3" (assert)
                              (("3"
                                (inst?)
                                (("3"
                                  (assert)
                                  (("3" (inst?) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("4" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (ground) nil nil))
                nil))
              nil)
             ("2" (assert)
              (("2" (hide 2)
                (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil))
              nil))
            nil))
          nil)
         ("2" (hide 2)
          (("2" (use "decref_TCC12")
            (("2" (assert)
              (("2" (inst?)
                (("2" (assert)
                  (("2" (inst?) (("2" (ground) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (hide 2)
          (("3" (lift-if)
            (("3" (ground)
              (("3"
                (typepred "v(rS
           WITH [`store(r)`seq(i - 1) := nil,
                 `count(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)")
                (("1" (hide -1 -2)
                  (("1" (inst - "r") (("1" (ground) nil nil)) nil))
                  nil)
                 ("2" (case "r = refindex(subref)")
                  (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
                 ("3" (use "decref_TCC6")
                  (("3" (assert)
                    (("3" (inst?)
                      (("3" (assert)
                        (("3" (inst?)
                          (("3" (assert) (("3" (inst?) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("4" (grind) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("4" (hide 2) (("4" (lift-if) (("4" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (rS skolem-const-decl "rstate" refreduction nil)
    (subref skolem-const-decl "(domainValue?(rS`domain))" refreduction
     nil)
    (r skolem-const-decl "(rS`domain)" refreduction nil)
    (i skolem-const-decl "upto(rS`store(r)`length)" refreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (decref_TCC6 subtype-tcc nil refreduction nil)
    (allcountStore_decrease formula-decl nil refreduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (allcountStore const-decl "nat" refreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (allcount const-decl "nat" refreduction nil)
    (finite_enumeration const-decl "[below[card(X)] -> (X)]"
     finite_enumeration "sigma_set/")
    (bijective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (decref_TCC12 termination-tcc nil refreduction nil)
    (s skolem-const-decl "(rS`domain)" refreduction nil)
    (newrS skolem-const-decl "rstate" refreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (decref_TCC14 0
  (decref_TCC14-1 nil 3692915538 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (decref_TCC15 0
  (decref_TCC15-1 nil 3692972887 ("" (subtype-tcc) nil nil)
   ((allcountStore const-decl "nat" refreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (mark_letApply 0
  (mark_letApply-1 nil 3693496107
   ("" (induct "L")
    (("1" (grind)
      (("1" (lemma "mark_idem")
        (("1" (inst?) (("1" (postpone) nil nil)) nil)) nil)
       ("2" (postpone) nil nil) ("3" (postpone) nil nil))
      nil)
     ("2" (postpone) nil nil))
    nil)
   nil shostak))
 (applyReduce_TCC1 0
  (applyReduce_TCC1-1 nil 3676345135 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (goodrstate type-eq-decl nil refreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (injective? const-decl "bool" functions nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (applyReduce_TCC2 0
  (applyReduce_TCC2-1 nil 3676345135
   ("" (skeep*) (("" (assert) nil nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (applyReduce_TCC3 0
  (applyReduce_TCC3-1 nil 3676345135
   ("" (skeep*)
    ((""
      (lemma "reduction.applyReduce_TCC3" :subst
       ("gS" "rstate2estate(grS)"))
      (("1" (inst?)
        (("1" (inst - "stack")
          (("1" (split -)
            (("1" (inst - "store")
              (("1" (split -)
                (("1" (inst - "expr")
                  (("1" (split -)
                    (("1" (inst - "fun")
                      (("1" (split -)
                        (("1" (inst - "args")
                          (("1" (split -)
                            (("1" (inst - "lenargs")
                              (("1"
                                (split -)
                                (("1"
                                  (inst - "def")
                                  (("1"
                                    (split -)
                                    (("1"
                                      (inst - "arity")
                                      (("1"
                                        (split -)
                                        (("1"
                                          (inst - "body")
                                          (("1"
                                            (split -)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (split)
                                                (("1"
                                                  (skeep)
                                                  (("1"
                                                    (inst - "i")
                                                    (("1"
                                                      (ground)
                                                      (("1"
                                                        (grind)
                                                        nil
                                                        nil)
                                                       ("2"
                                                        (rewrite
                                                         "pure_refs"
                                                         -)
                                                        (("2"
                                                          (rewrite
                                                           "pure_letApply")
                                                          (("2"
                                                            (typepred
                                                             "body")
                                                            (("2"
                                                              (hide 2)
                                                              (("2"
                                                                (rewrite
                                                                 "pure_mark")
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (skeep)
                                                  (("2"
                                                    (inst -3 "i")
                                                    (("2"
                                                      (ground)
                                                      (("1"
                                                        (rewrite
                                                         "popdepth_letApply")
                                                        (("1"
                                                          (lift-if)
                                                          (("1"
                                                            (ground)
                                                            (("1"
                                                              (rewrite
                                                               "popdepth_letApply")
                                                              (("1"
                                                                (rewrite
                                                                 "popDepth_mark")
                                                                (("1"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (rewrite
                                                               "popdepth_letApply")
                                                              (("2"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (rewrite
                                                         "vars_letApply")
                                                        (("2"
                                                          (rewrite
                                                           "vars_letApply")
                                                          (("2"
                                                            (rewrite
                                                             "vars_mark")
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("3"
                                                  (rewrite
                                                   "popdepth_letApply")
                                                  (("3"
                                                    (rewrite
                                                     "popdepth_letApply")
                                                    (("3"
                                                      (rewrite
                                                       "popDepth_mark")
                                                      (("3"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("4"
                                                  (rewrite
                                                   "pure_contextPure")
                                                  (("4"
                                                    (rewrite
                                                     "pure_letApply")
                                                    (("4"
                                                      (rewrite
                                                       "pure_mark")
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("5"
                                                  (use "mark_letApply")
                                                  (("5"
                                                    (ground)
                                                    (("1"
                                                      (typepred
                                                       "grS`redex")
                                                      (("1"
                                                        (typepred
                                                         "grS")
                                                        (("1"
                                                          (expand
                                                           "applyRedex?")
                                                          (("1"
                                                            (assert)
                                                            (("1"
                                                              (expand
                                                               "mark"
                                                               -6)
                                                              (("1"
                                                                (decompose-equality
                                                                 -6)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (typepred
                                                       "D`seq(fun)`body")
                                                      (("2"
                                                        (lazy-grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("6"
                                                  (skeep)
                                                  (("6"
                                                    (typepred "expr")
                                                    (("6"
                                                      (rewrite
                                                       "vars_letApply")
                                                      (("6"
                                                        (inst -6 "i")
                                                        (("6"
                                                          (ground)
                                                          (("6"
                                                            (typepred
                                                             "grS")
                                                            (("6"
                                                              (expand
                                                               "applyRedex?")
                                                              (("6"
                                                                (assert)
                                                                (("6"
                                                                  (rewrite
                                                                   "vars")
                                                                  (("6"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2" (propax) nil nil)
                                             ("3" (propax) nil nil))
                                            nil))
                                          nil)
                                         ("2" (propax) nil nil))
                                        nil))
                                      nil)
                                     ("2" (propax) nil nil))
                                    nil))
                                  nil)
                                 ("2" (propax) nil nil)
                                 ("3" (propax) nil nil))
                                nil))
                              nil)
                             ("2" (propax) nil nil))
                            nil))
                          nil)
                         ("2" (propax) nil nil))
                        nil))
                      nil)
                     ("2" (hide 2) (("2" (grind) nil nil)) nil))
                    nil)
                   ("2" (hide 2)
                    (("2" (typepred "expr")
                      (("2" (lazy-grind) nil nil)) nil))
                    nil))
                  nil)
                 ("2" (hide 2) (("2" (grind) nil nil)) nil))
                nil)
               ("2" (hide 2) (("2" (grind) nil nil)) nil))
              nil)
             ("2" (hide 2) (("2" (grind) nil nil)) nil))
            nil)
           ("2" (hide 2) (("2" (grind) nil nil)) nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (grind)
          (("2" (typepred "grS") (("2" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((goodrstate type-eq-decl nil refreduction nil)
    (rstate2estate const-decl "estate" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (refcount const-decl "nat" refreduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (applyRedex? const-decl "bool" IL nil)
    (goodstate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (applyReduce_TCC3 subtype-tcc nil reduction nil)
    (grS skolem-const-decl "{grS | applyRedex?(grS`redex)}"
     refreduction nil)
    (stack skolem-const-decl
     "{S: Stack | every(domainValue?(grS`domain))(S)}" refreduction
     nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (store skolem-const-decl "Store(grS`domain)" refreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (expr skolem-const-decl "{A |
        forall i: refs(A)(i) IMPLIES grS`domain(i)
    AND forall i: vars(A)(i) IMPLIES i + popDepth(A) < grS`stack`length
    AND popDepth(A) <= grS`stack`length AND contextPure?(A)
    AND mark(grS`contextvars)(A) = A
    AND forall i:
          i >= grS`stack`length OR
           vars(A)(i) OR
            grS`contextvars(i) OR
             NOT ref?(grS`stack`seq(grS`stack`length - 1 - i))}"
          refreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (mark_letApply formula-decl nil refreduction nil)
    (args adt-accessor-decl "[(application?) -> list[(variable?)]]"
          IExpression_adt nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (pure_contextPure formula-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (singleton const-decl "(singleton?)" sets nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (popDepth_mark formula-decl nil preprocess nil)
    (popdepth_letApply formula-decl nil reduction nil)
    (vars_mark formula-decl nil preprocess nil)
    (vars_letApply formula-decl nil reduction nil)
    (pure_letApply rec-application-judgement "(pure?)" reduction nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pure_letApply recursive-judgement-axiom nil reduction nil)
    (pure_mark formula-decl nil preprocess nil)
    (pure_refs formula-decl nil IL nil)
    (length def-decl "nat" list_props nil)
    (letApply def-decl "IExpression" reduction nil)
    (emptyset const-decl "set" sets nil) (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil reduction nil)
    (Defs type-eq-decl nil reduction nil)
    (Definition type-eq-decl nil refreduction nil)
    (Defs type-eq-decl nil refreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (applyReduce_TCC4 0
  (applyReduce_TCC4-1 nil 3676345135
   ("" (skeep*)
    (("" (expand "refcount")
      (("" (expand "refcountExpr")
        (("" (use "pure_letApply")
          (("1" (rewrite "pure_refs")
            (("1" (typepred "grS`count(x1)")
              (("1" (expand "refcount")
                (("1" (expand "refcountExpr")
                  (("1" (typepred "grS")
                    (("1" (forward-chain "pureApplyRedex")
                      (("1" (rewrite "pure_refs") nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (hide 2) (("2" (grind) nil nil)) nil)
           ("3" (hide 2) (("3" (rewrite "pure_mark") nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((refcount const-decl "nat" refreduction nil)
    (pure_letApply recursive-judgement-axiom nil reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (length def-decl "nat" list_props nil)
    (args skolem-const-decl "list[(variable?)]" refreduction nil)
    (arity skolem-const-decl "nat" refreduction nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil refreduction nil)
    (def skolem-const-decl "Definition" refreduction nil)
    (body skolem-const-decl
          "{A | pure?(A) AND (forall i: vars(A)(i) IMPLIES i < def`arity)}"
          refreduction nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (pureApplyRedex formula-decl nil IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (Store type-eq-decl nil reduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (letApply def-decl "IExpression" reduction nil)
    (pure_refs formula-decl nil IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pure_mark formula-decl nil preprocess nil)
    (refcountExpr const-decl "nat" refreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (ifReduce_TCC1 0
  (ifReduce_TCC1-1 nil 3683858380 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (goodrstate type-eq-decl nil refreduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (ifReduce_TCC2 0
  (ifReduce_TCC2-1 nil 3683858380
   ("" (skeep*)
    (("" (use "ifReduce_TCC2")
      (("" (inst - "rstate2estate(grS)" "stack")
        (("1" (ground)
          (("1" (inst?)
            (("1" (ground)
              (("1" (inst?)
                (("1" (ground)
                  (("1" (inst?)
                    (("1" (ground)
                      (("1" (inst?)
                        (("1" (ground) (("1" (inst?) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (typepred "expr")
                  (("2" (split)
                    (("1" (lazy-grind) nil nil)
                     ("2" (lazy-grind) nil nil)
                     ("3" (lazy-grind) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil)
             ("2" (grind) nil nil))
            nil)
           ("2" (grind) nil nil))
          nil)
         ("2" (typepred "stack")
          (("2" (expand "every") (("2" (lazy-grind) nil nil)) nil))
          nil)
         ("3" (typepred "grS") (("3" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((ifReduce_TCC2 subtype-tcc nil reduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (expr skolem-const-decl "{A |
        forall i: refs(A)(i) IMPLIES grS`domain(i)
    AND forall i: vars(A)(i) IMPLIES i + popDepth(A) < grS`stack`length
    AND popDepth(A) <= grS`stack`length AND contextPure?(A)
    AND mark(grS`contextvars)(A) = A
    AND forall i:
          i >= grS`stack`length OR
           vars(A)(i) OR
            grS`contextvars(i) OR
             NOT ref?(grS`stack`seq(grS`stack`length - 1 - i))}"
          refreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (store skolem-const-decl "Store(grS`domain)" refreduction nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (stack skolem-const-decl
     "{S: Stack | every(domainValue?(grS`domain))(S)}" refreduction
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (estate type-eq-decl nil reduction nil)
    (rstate2estate const-decl "estate" refreduction nil)
    (goodrstate type-eq-decl nil refreduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (grS skolem-const-decl "{grS | pureIftRedex?(grS`redex)}"
     refreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (ifReduce_TCC3 0
  (ifReduce_TCC3-1 nil 3683858380
   ("" (skeep*)
    (("" (typepred "expr")
      (("" (split)
        (("1" (skeep)
          (("1" (inst?)
            (("1" (ground)
              (("1" (typepred "grS") (("1" (grind) nil nil)) nil))
              nil))
            nil))
          nil)
         ("2" (typepred "grS")
          (("2" (skeep)
            (("2" (hide -3)
              (("2" (inst - "i")
                (("2" (ground)
                  (("1" (grind)
                    (("1" (typepred "i")
                      (("1" (rewrite "purePopDepth")
                        (("1" (assert) nil nil)) nil))
                      nil)
                     ("2" (grind :rewrites "purePopDepth") nil nil)
                     ("3" (typepred "grS")
                      (("3" (grind :rewrites "purePopDepth") nil nil))
                      nil)
                     ("4" (typepred "grS")
                      (("4" (case "pure?(elseexpr)")
                        (("1" (rewrite "purePopDepth")
                          (("1" (assert) nil nil)) nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil)
                     ("5" (rewrite "purePopDepth")
                      (("5" (assert) nil nil)) nil)
                     ("6" (rewrite "purePopDepth")
                      (("6" (assert) nil nil)) nil)
                     ("7" (rewrite "purePopDepth")
                      (("7" (assert) nil nil)) nil)
                     ("8" (rewrite "purePopDepth")
                      (("8" (assert) nil nil)) nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (typepred "grS")
          (("3" (expand "pureIftRedex?")
            (("3" (ground)
              (("3" (rewrite "purePopDepth") (("3" (grind) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("4" (typepred "grS")
          (("4" (assert)
            (("4" (expand "pureIftRedex?")
              (("4" (ground)
                (("4" (rewrite "pure_contextPure") nil nil)) nil))
              nil))
            nil))
          nil)
         ("5" (typepred "grS")
          (("5" (expand "pureIftRedex?")
            (("5" (ground)
              (("5" (expand "iftRedex?")
                (("5" (assert)
                  (("5" (expand "mark" -)
                    (("5" (decompose-equality -8)
                      (("5" (replace -18 +)
                        (("5" (replace -3 + :dir RL :hide? t)
                          (("5" (rewrite "mark_release_set")
                            (("1" (rewrite "mark_idem") nil nil)
                             ("2" (hide-all-but 1)
                              (("2"
                                (rewrite "vars_mark")
                                (("2" (grind-with-ext) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("6" (skeep)
          (("6" (inst -7 "i")
            (("6" (ground)
              (("6" (typepred "grS")
                (("6" (expand "pureIftRedex?")
                  (("6" (ground)
                    (("6" (expand "iftRedex?")
                      (("6" (assert)
                        (("6" (expand "mark")
                          (("6" (decompose-equality -10)
                            (("6" (replace -19)
                              (("6"
                                (replace -3 + :dir RL :hide? t)
                                (("6"
                                  (rewrite "vars_release_set")
                                  (("6"
                                    (rewrite "vars_mark")
                                    (("6"
                                      (hide-all-but (-6 -7 -17 3))
                                      (("6"
                                        (grind)
                                        (("6" (postpone) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pureIftRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (refcount const-decl "nat" refreduction nil)
    (Store type-eq-decl nil reduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (vars_release_set formula-decl nil preprocess nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (release_set def-decl "IExpression" preprocess nil)
    (finite_intersection1 application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (intersection const-decl "set" sets nil)
    (disjoint? const-decl "bool" sets nil)
    (vars_mark formula-decl nil preprocess nil)
    (mark_idem formula-decl nil preprocess nil)
    (mark_release_set formula-decl nil preprocess nil)
    (pure_contextPure formula-decl nil IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (pure? def-decl "bool" IL nil)
    (purePopDepth formula-decl nil IL nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (difference const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (iftRedex? const-decl "bool" IL nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (ifReduce_TCC4 0
  (ifReduce_TCC4-1 nil 3683858380
   ("" (skeep*)
    (("" (expand "refcount")
      (("" (expand "refcountExpr")
        (("" (typepred "grS")
          (("" (typepred "grS`count(x1)")
            (("" (grind :rewrites "pure_refs") nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((refcount const-decl "nat" refreduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (Store type-eq-decl nil reduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil) (pure_refs formula-decl nil IL nil)
    (sigma_nat application-judgement "nat" sigma "reals/")
    (get const-decl "(value?)" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (refcountStack const-decl "nat" refreduction nil)
    (refcountStore const-decl "nat" refreduction nil)
    (finite_enumeration const-decl "[below[card(X)] -> (X)]"
     finite_enumeration "sigma_set/")
    (bijective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (refcountArray const-decl "nat" refreduction nil)
    (count const-decl "nat" finseq_theorems nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (refcountExpr const-decl "nat" refreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (ifReduce_TCC5 0
  (ifReduce_TCC5-1 nil 3683858380
   ("" (skeep*)
    (("" (use "reduction.ifReduce_TCC4")
      (("" (inst - "rstate2estate(grS)" "stack")
        (("1" (split)
          (("1" (inst?)
            (("1" (split)
              (("1" (inst?)
                (("1" (split)
                  (("1" (inst?)
                    (("1" (split)
                      (("1" (inst - "thenexpr")
                        (("1" (split)
                          (("1" (inst?)
                            (("1" (split)
                              (("1"
                                (ground)
                                (("1" (lazy-grind) nil nil)
                                 ("2"
                                  (typepred "expr")
                                  (("2"
                                    (skeep)
                                    (("2"
                                      (inst -2 "i")
                                      (("2"
                                        (typepred "grS")
                                        (("2"
                                          (hide-all-but (-1 -3 -8 2))
                                          (("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("3" (lazy-grind) nil nil)
                                 ("4" (lazy-grind) nil nil)
                                 ("5"
                                  (typepred "grS")
                                  (("5"
                                    (typepred "expr")
                                    (("5"
                                      (hide -1 -2 -3 -4)
                                      (("5"
                                        (expand "pureIftRedex?")
                                        (("5"
                                          (ground)
                                          (("5"
                                            (expand "iftRedex?")
                                            (("5"
                                              (assert)
                                              (("5"
                                                (expand "mark" -)
                                                (("5"
                                                  (decompose-equality
                                                   -)
                                                  (("5"
                                                    (replace -16)
                                                    (("5"
                                                      (replace
                                                       -2
                                                       +
                                                       :dir
                                                       RL
                                                       :hide?
                                                       t)
                                                      (("5"
                                                        (expand
                                                         "mark"
                                                         +
                                                         1)
                                                        (("5"
                                                          (rewrite
                                                           "vars_release_set")
                                                          (("5"
                                                            (rewrite
                                                             "vars_mark")
                                                            (("5"
                                                              (case-replace
                                                               "markv(union(union(vars(thenexpr(expr)),
                                                                            difference(vars(elseexpr(expr)),
                                                                                       union
                                                                                       (vars(thenexpr(expr)),
                                                                                        grS`contextvars))),
                                                                      grS`contextvars))
                                                               (condition) = condition")
                                                              (("1"
                                                                (apply-extensionality)
                                                                (("1"
                                                                  (hide
                                                                   3)
                                                                  (("1"
                                                                    (rewrite
                                                                     "mark_release_set")
                                                                    (("1"
                                                                      (rewrite
                                                                       "mark_idem")
                                                                      nil
                                                                      nil)
                                                                     ("2"
                                                                      (hide-all-but
                                                                       1)
                                                                      (("2"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (replace
                                                                 -14)
                                                                (("2"
                                                                  (hide-all-but
                                                                   (-1
                                                                    1))
                                                                  (("2"
                                                                    (case-replace
                                                                     "union(vars(thenexpr(expr)),
                                                                  union(vars(elseexpr(expr)), grS`contextvars)) = union(union(vars(thenexpr(expr)),
                                                                        difference(vars(elseexpr(expr)),
                                                                                   union(vars(thenexpr(expr)),
                                                                                         grS`contextvars))),
                                                                  grS`contextvars)")
                                                                    (("2"
                                                                      (hide
                                                                       -1
                                                                       2)
                                                                      (("2"
                                                                        (grind-with-ext)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("6"
                                  (typepred "expr")
                                  (("6"
                                    (skeep)
                                    (("6"
                                      (inst -6 "i")
                                      (("6"
                                        (ground)
                                        (("6"
                                          (typepred "grS")
                                          (("6"
                                            (expand "pureIftRedex?")
                                            (("6"
                                              (ground)
                                              (("6"
                                                (expand "iftRedex?")
                                                (("6"
                                                  (assert)
                                                  (("6"
                                                    (expand "mark")
                                                    (("6"
                                                      (decompose-equality
                                                       -)
                                                      (("6"
                                                        (replace -21)
                                                        (("6"
                                                          (replace
                                                           -2
                                                           +
                                                           :dir
                                                           RL
                                                           :hide?
                                                           t)
                                                          (("6"
                                                            (expand
                                                             "vars"
                                                             +
                                                             1)
                                                            (("6"
                                                              (rewrite
                                                               "vars_release_set")
                                                              (("6"
                                                                (hide-all-but
                                                                 (-3
                                                                  -6
                                                                  3))
                                                                (("6"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (propax) nil nil)
                               ("3" (propax) nil nil))
                              nil))
                            nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil)
                       ("2" (propax) nil nil))
                      nil))
                    nil)
                   ("2" (hide 3) (("2" (grind) nil nil)) nil))
                  nil)
                 ("2" (hide 3) (("2" (grind) nil nil)) nil))
                nil)
               ("2" (hide 3) (("2" (grind) nil nil)) nil))
              nil)
             ("2" (hide 3) (("2" (grind) nil nil)) nil))
            nil)
           ("2" (hide 3) (("2" (grind) nil nil)) nil))
          nil)
         ("2" (hide 3) (("2" (grind) nil nil)) nil)
         ("3" (hide 3)
          (("3" (grind)
            (("1" (typepred "grS") (("1" (grind) nil nil)) nil)
             ("2" (typepred "grS") (("2" (grind) nil nil)) nil)
             ("3" (typepred "grS") (("3" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ifReduce_TCC4 subtype-tcc nil reduction nil)
    (difference const-decl "set" sets nil)
    (release_set def-decl "IExpression" preprocess nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (markv const-decl "(variable?)" preprocess nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (vars_release_set formula-decl nil preprocess nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (disjoint? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (finite_intersection1 application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (mark_idem formula-decl nil preprocess nil)
    (mark_release_set formula-decl nil preprocess nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (IExpression_release_extensionality formula-decl nil
     IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (vars_mark formula-decl nil preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (union const-decl "set" sets nil)
    (iftRedex? const-decl "bool" IL nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (get const-decl "(value?)" IL nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (expr skolem-const-decl "{A |
        forall i: refs(A)(i) IMPLIES grS`domain(i)
    AND forall i: vars(A)(i) IMPLIES i + popDepth(A) < grS`stack`length
    AND popDepth(A) <= grS`stack`length AND contextPure?(A)
    AND mark(grS`contextvars)(A) = A
    AND forall i:
          i >= grS`stack`length OR
           vars(A)(i) OR
            grS`contextvars(i) OR
             NOT ref?(grS`stack`seq(grS`stack`length - 1 - i))}"
          refreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (store skolem-const-decl "Store(grS`domain)" refreduction nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (stack skolem-const-decl
     "{S: Stack | every(domainValue?(grS`domain))(S)}" refreduction
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (estate type-eq-decl nil reduction nil)
    (rstate2estate const-decl "estate" refreduction nil)
    (goodrstate type-eq-decl nil refreduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (grS skolem-const-decl "{grS | pureIftRedex?(grS`redex)}"
     refreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (ifReduce_TCC6 0
  (ifReduce_TCC6-1 nil 3683858380
   ("" (skeep*)
    (("" (typepred "grS")
      (("" (expand "refcount")
        (("" (expand "refcountExpr")
          (("" (typepred "grS`count(x1)")
            (("" (grind :rewrites "pure_refs") nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((pureIftRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (refcount const-decl "nat" refreduction nil)
    (Store type-eq-decl nil reduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (refcountExpr const-decl "nat" refreduction nil)
    (pure_refs formula-decl nil IL nil)
    (sigma_nat application-judgement "nat" sigma "reals/")
    (pure? def-decl "bool" IL nil) (get const-decl "(value?)" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (refcountStack const-decl "nat" refreduction nil)
    (refcountStore const-decl "nat" refreduction nil)
    (finite_enumeration const-decl "[below[card(X)] -> (X)]"
     finite_enumeration "sigma_set/")
    (bijective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (refcountArray const-decl "nat" refreduction nil)
    (count const-decl "nat" finseq_theorems nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (ifReduce_TCC7 0
  (ifReduce_TCC7-1 nil 3696194804
   ("" (skeep* :preds? t)
    (("" (use "reduction.ifReduce_TCC4")
      (("" (inst - "rstate2estate(grS)" "stack")
        (("1" (split)
          (("1" (inst?)
            (("1" (split)
              (("1" (inst?)
                (("1" (split)
                  (("1" (inst?)
                    (("1" (split)
                      (("1" (inst - "thenexpr")
                        (("1" (split)
                          (("1" (inst?)
                            (("1" (split)
                              (("1"
                                (ground)
                                (("1"
                                  (lazy-grind :rewrites "purePopDepth")
                                  nil
                                  nil)
                                 ("2"
                                  (lazy-grind :rewrites "purePopDepth")
                                  nil
                                  nil)
                                 ("3"
                                  (grind
                                   :rewrites
                                   "purePopDepth"
                                   :if-match
                                   nil)
                                  nil
                                  nil)
                                 ("4"
                                  (expand "pureIftRedex?")
                                  (("4"
                                    (expand "iftRedex?")
                                    (("4"
                                      (ground)
                                      (("4"
                                        (expand "mark" -)
                                        (("4"
                                          (decompose-equality -)
                                          (("4"
                                            (replace -22)
                                            (("4"
                                              (replace -2 :dir RL)
                                              (("4"
                                                (rewrite
                                                 "mark_release_set")
                                                (("1"
                                                  (rewrite "mark_idem")
                                                  nil
                                                  nil)
                                                 ("2"
                                                  (hide-all-but 1)
                                                  (("2"
                                                    (grind
                                                     :rewrites
                                                     "vars_mark")
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("5"
                                  (skeep)
                                  (("5"
                                    (inst -12 "i")
                                    (("5"
                                      (ground)
                                      (("5"
                                        (expand "pureIftRedex?")
                                        (("5"
                                          (expand "iftRedex?")
                                          (("5"
                                            (ground)
                                            (("5"
                                              (expand "mark" -)
                                              (("5"
                                                (decompose-equality -)
                                                (("5"
                                                  (replace -23)
                                                  (("5"
                                                    (replace
                                                     -2
                                                     :dir
                                                     RL)
                                                    (("5"
                                                      (rewrite
                                                       "vars_release_set")
                                                      (("5"
                                                        (hide-all-but
                                                         (-1
                                                          -4
                                                          -22
                                                          2
                                                          3
                                                          5))
                                                        (("5"
                                                          (grind
                                                           :rewrites
                                                           "vars_mark")
                                                          (("5"
                                                            (replace
                                                             -1
                                                             :dir
                                                             RL)
                                                            (("5"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (propax) nil nil)
                               ("3" (propax) nil nil))
                              nil))
                            nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil)
                       ("2" (propax) nil nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (hide 5) (("2" (grind) nil nil)) nil))
                nil)
               ("2" (hide 5) (("2" (grind) nil nil)) nil))
              nil)
             ("2" (hide 5) (("2" (grind) nil nil)) nil))
            nil)
           ("2" (hide 5) (("2" (grind) nil nil)) nil))
          nil)
         ("2" (hide 5) (("2" (grind) nil nil)) nil)
         ("3" (hide 5) (("3" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((ifReduce_TCC4 subtype-tcc nil reduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_release_set formula-decl nil preprocess nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (difference const-decl "set" sets nil)
    (release_set def-decl "IExpression" preprocess nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (union const-decl "set" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_intersection1 application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (vars_mark formula-decl nil preprocess nil)
    (member const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (disjoint? const-decl "bool" sets nil)
    (mark_idem formula-decl nil preprocess nil)
    (mark_release_set formula-decl nil preprocess nil)
    (iftRedex? const-decl "bool" IL nil)
    (get const-decl "(value?)" IL nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (expr skolem-const-decl "{A |
        forall i: refs(A)(i) IMPLIES grS`domain(i)
    AND forall i: vars(A)(i) IMPLIES i + popDepth(A) < grS`stack`length
    AND popDepth(A) <= grS`stack`length AND contextPure?(A)
    AND mark(grS`contextvars)(A) = A
    AND forall i:
          i >= grS`stack`length OR
           vars(A)(i) OR
            grS`contextvars(i) OR
             NOT ref?(grS`stack`seq(grS`stack`length - 1 - i))}"
          refreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (store skolem-const-decl "Store(grS`domain)" refreduction nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (stack skolem-const-decl
     "{S: Stack | every(domainValue?(grS`domain))(S)}" refreduction
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (estate type-eq-decl nil reduction nil)
    (rstate2estate const-decl "estate" refreduction nil)
    (goodrstate type-eq-decl nil refreduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (grS skolem-const-decl "{grS | pureIftRedex?(grS`redex)}"
     refreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (ifReduce_TCC8 0
  (ifReduce_TCC8-1 nil 3696194804
   ("" (skeep* :preds? t)
    (("" (typepred "grS`count(x1)")
      (("" (expand "refcount")
        (("" (expand "pureIftRedex?")
          (("" (expand "iftRedex?")
            (("" (ground)
              (("" (expand "refcountExpr")
                (("" (rewrite "pure_refs")
                  (("1" (rewrite "pure_refs") nil nil)
                   ("2" (expand "pure?" +) (("2" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pureIftRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (refcount const-decl "nat" refreduction nil)
    (Store type-eq-decl nil reduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (pure_refs formula-decl nil IL nil) (pure? def-decl "bool" IL nil)
    (refcountExpr const-decl "nat" refreduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (lookupReduce_TCC1 0
  (lookupReduce_TCC1-1 nil 3693417317 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (goodrstate type-eq-decl nil refreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (injective? const-decl "bool" functions nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (lookupReduce_TCC2 0
  (lookupReduce_TCC2-1 nil 3693417317
   ("" (skeep)
    (("" (use "lookupReduce_TCC2")
      (("" (inst - "rstate2estate(grS)" "stack")
        (("1" (ground)
          (("1" (skeep*)
            (("1" (inst?)
              (("1" (ground)
                (("1" (inst?)
                  (("1" (ground)
                    (("1" (inst?)
                      (("1" (ground)
                        (("1" (inst?)
                          (("1" (ground) (("1" (inst?) nil nil)) nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil)
                       ("2" (typepred "grS")
                        (("2" (typepred "expr")
                          (("2" (lazy-grind) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil)
           ("2" (hide 2) (("2" (grind) nil nil)) nil))
          nil)
         ("2" (hide 2) (("2" (grind) nil nil)) nil)
         ("3" (hide 2)
          (("3" (grind)
            (("3" (typepred "grS") (("3" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((lookupReduce_TCC2 subtype-tcc nil reduction nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (store skolem-const-decl "Store(grS`domain)" refreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (expr skolem-const-decl "{A |
        forall i: refs(A)(i) IMPLIES grS`domain(i)
    AND forall i: vars(A)(i) IMPLIES i + popDepth(A) < grS`stack`length
    AND popDepth(A) <= grS`stack`length AND contextPure?(A)
    AND mark(grS`contextvars)(A) = A
    AND forall i:
          i >= grS`stack`length OR
           vars(A)(i) OR
            grS`contextvars(i) OR
             NOT ref?(grS`stack`seq(grS`stack`length - 1 - i))}"
          refreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (goodstate type-eq-decl nil reduction nil)
    (stack skolem-const-decl
     "{S: Stack | every(domainValue?(grS`domain))(S)}" refreduction
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (estate type-eq-decl nil reduction nil)
    (rstate2estate const-decl "estate" refreduction nil)
    (goodrstate type-eq-decl nil refreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (grS skolem-const-decl "{grS | lookupRedex?(grS`redex)}"
     refreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (lookupReduce_TCC3 0
  (lookupReduce_TCC3-1 nil 3693417317
   ("" (skeep*)
    (("" (use "lookupReduce_TCC3")
      (("" (inst - "rstate2estate(grS)" "stack")
        (("1" (ground)
          (("1" (inst?)
            (("1" (ground)
              (("1" (inst?)
                (("1" (ground)
                  (("1" (inst?)
                    (("1" (ground)
                      (("1" (inst?)
                        (("1" (ground)
                          (("1" (inst?)
                            (("1" (ground) (("1" (inst?) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil)
                     ("2" (typepred "expr")
                      (("2" (lazy-grind) nil nil)) nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (grind) nil nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil)
         ("2" (grind) nil nil)
         ("3" (typepred "grS") (("3" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((lookupReduce_TCC3 subtype-tcc nil reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (get const-decl "(value?)" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (expr skolem-const-decl "{A |
        forall i: refs(A)(i) IMPLIES grS`domain(i)
    AND forall i: vars(A)(i) IMPLIES i + popDepth(A) < grS`stack`length
    AND popDepth(A) <= grS`stack`length AND contextPure?(A)
    AND mark(grS`contextvars)(A) = A
    AND forall i:
          i >= grS`stack`length OR
           vars(A)(i) OR
            grS`contextvars(i) OR
             NOT ref?(grS`stack`seq(grS`stack`length - 1 - i))}"
          refreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (store skolem-const-decl "Store(grS`domain)" refreduction nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (stack skolem-const-decl
     "{S: Stack | every(domainValue?(grS`domain))(S)}" refreduction
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (estate type-eq-decl nil reduction nil)
    (rstate2estate const-decl "estate" refreduction nil)
    (goodrstate type-eq-decl nil refreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (grS skolem-const-decl "{grS | lookupRedex?(grS`redex)}"
     refreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (lookupReduce_TCC4 0
  (lookupReduce_TCC4-1 nil 3693417317 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (goodrstate type-eq-decl nil refreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (lookupReduce_TCC5 0
  (lookupReduce_TCC5-1 nil 3693417317 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (goodrstate type-eq-decl nil refreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (lookupReduce_TCC6 0
  (lookupReduce_TCC6-1 nil 3693417317
   ("" (skeep*)
    (("" (use "lookupReduce_TCC6")
      (("" (inst - "rstate2estate(grS)" "stack")
        (("1" (split)
          (("1" (inst?)
            (("1" (split)
              (("1" (inst?)
                (("1" (split)
                  (("1" (inst?)
                    (("1" (split)
                      (("1" (inst?)
                        (("1" (split)
                          (("1" (inst - "pos")
                            (("1" (split)
                              (("1"
                                (inst?)
                                (("1"
                                  (split)
                                  (("1"
                                    (inst?)
                                    (("1"
                                      (split)
                                      (("1" (lazy-grind) nil nil)
                                       ("2" (propax) nil nil)
                                       ("3" (propax) nil nil)
                                       ("4" (propax) nil nil)
                                       ("5" (propax) nil nil)
                                       ("6" (propax) nil nil)
                                       ("7" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("2" (propax) nil nil))
                                  nil))
                                nil)
                               ("2" (propax) nil nil))
                              nil))
                            nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil)
                       ("2" (hide 2) (("2" (grind) nil nil)) nil))
                      nil)
                     ("2" (hide 2) (("2" (grind) nil nil)) nil))
                    nil)
                   ("2" (hide 2) (("2" (grind) nil nil)) nil))
                  nil)
                 ("2" (hide 2) (("2" (grind) nil nil)) nil))
                nil)
               ("2" (hide 2) (("2" (grind) nil nil)) nil))
              nil))
            nil)
           ("2" (hide 2) (("2" (grind) nil nil)) nil))
          nil)
         ("2" (hide 2) (("2" (grind) nil nil)) nil)
         ("3" (hide 2)
          (("3" (typepred "grS") (("3" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((lookupReduce_TCC6 subtype-tcc nil reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (get const-decl "(value?)" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (expr skolem-const-decl "{A |
        forall i: refs(A)(i) IMPLIES grS`domain(i)
    AND forall i: vars(A)(i) IMPLIES i + popDepth(A) < grS`stack`length
    AND popDepth(A) <= grS`stack`length AND contextPure?(A)
    AND mark(grS`contextvars)(A) = A
    AND forall i:
          i >= grS`stack`length OR
           vars(A)(i) OR
            grS`contextvars(i) OR
             NOT ref?(grS`stack`seq(grS`stack`length - 1 - i))}"
          refreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (store skolem-const-decl "Store(grS`domain)" refreduction nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (stack skolem-const-decl
     "{S: Stack | every(domainValue?(grS`domain))(S)}" refreduction
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (estate type-eq-decl nil reduction nil)
    (rstate2estate const-decl "estate" refreduction nil)
    (goodrstate type-eq-decl nil refreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (grS skolem-const-decl "{grS | lookupRedex?(grS`redex)}"
     refreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (lookupReduce_TCC7 0
  (lookupReduce_TCC7-1 nil 3693417317
   ("" (skeep* :preds? t)
    (("" (inst -9 "index(avar)")
      (("" (ground) (("" (grind :if-match nil) nil nil)) nil)) nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil)
    (lookupRedex? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (get const-decl "(value?)" IL nil) (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (lookupReduce_TCC8 0
  (lookupReduce_TCC8-1 nil 3696570131 ("" (subtype-tcc) nil nil)
   ((get const-decl "(value?)" IL nil)
    (value? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (lookupReduce_TCC9 0
  (lookupReduce_TCC9-1 nil 3696570131
   ("" (skeep* :preds? t)
    (("" (use "reduction.lookupReduce_TCC6")
      (("" (inst - "rstate2estate(grS)" "stack")
        (("1" (split)
          (("1" (inst?)
            (("1" (split)
              (("1" (inst?)
                (("1" (split)
                  (("1" (inst?)
                    (("1" (split)
                      (("1" (inst?)
                        (("1" (split)
                          (("1" (inst - "pos")
                            (("1" (split)
                              (("1"
                                (inst?)
                                (("1"
                                  (split)
                                  (("1"
                                    (inst?)
                                    (("1"
                                      (ground)
                                      (("1" (lazy-grind) nil nil)
                                       ("2" (lazy-grind) nil nil)
                                       ("3" (lazy-grind) nil nil)
                                       ("4"
                                        (hide-all-but (-5 1))
                                        (("4" (grind) nil nil))
                                        nil)
                                       ("5"
                                        (skeep)
                                        (("5"
                                          (inst -18 "i")
                                          (("5"
                                            (ground)
                                            (("1"
                                              (hide-all-but
                                               (-1
                                                -2
                                                -12
                                                -13
                                                -20
                                                -22
                                                -26
                                                -27
                                                -29
                                                -31
                                                -34
                                                2))
                                              (("1" (grind) nil nil))
                                              nil)
                                             ("2"
                                              (lift-if)
                                              (("2" (ground) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (propax) nil nil))
                                  nil))
                                nil)
                               ("2" (propax) nil nil))
                              nil))
                            nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil)
                       ("2" (hide 3)
                        (("2" (grind :if-match nil) nil nil)) nil))
                      nil)
                     ("2" (hide 3) (("2" (lazy-grind) nil nil)) nil))
                    nil)
                   ("2" (hide 3) (("2" (grind :if-match nil) nil nil))
                    nil))
                  nil)
                 ("2" (hide 3) (("2" (lazy-grind) nil nil)) nil))
                nil)
               ("2" (hide 3) (("2" (grind :if-match nil) nil nil))
                nil))
              nil))
            nil)
           ("2" (hide 3) (("2" (grind :if-match nil) nil nil)) nil))
          nil)
         ("2" (hide 3) (("2" (grind :if-match nil) nil nil)) nil)
         ("3" (hide 3) (("3" (grind :if-match nil) nil nil)) nil))
        nil))
      nil))
    nil)
   ((lookupReduce_TCC6 subtype-tcc nil reduction nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (get const-decl "(value?)" IL nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (expr skolem-const-decl "{A |
        forall i: refs(A)(i) IMPLIES grS`domain(i)
    AND forall i: vars(A)(i) IMPLIES i + popDepth(A) < grS`stack`length
    AND popDepth(A) <= grS`stack`length AND contextPure?(A)
    AND mark(grS`contextvars)(A) = A
    AND forall i:
          i >= grS`stack`length OR
           vars(A)(i) OR
            grS`contextvars(i) OR
             NOT ref?(grS`stack`seq(grS`stack`length - 1 - i))}"
          refreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (store skolem-const-decl "Store(grS`domain)" refreduction nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (stack skolem-const-decl
     "{S: Stack | every(domainValue?(grS`domain))(S)}" refreduction
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (estate type-eq-decl nil reduction nil)
    (rstate2estate const-decl "estate" refreduction nil)
    (goodrstate type-eq-decl nil refreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (grS skolem-const-decl "{grS | lookupRedex?(grS`redex)}"
     refreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (lookupReduce_TCC10 0
  (lookupReduce_TCC10-1 nil 3696570131
   ("" (skeep* :preds? t) (("" (grind) nil nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (popDepth def-decl "nat" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil) (get const-decl "(value?)" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (lookupRedex? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (lookupReduce_TCC11 0
  (lookupReduce_TCC11-1 nil 3696570131
   ("" (skeep* :preds? t)
    (("" (ground)
      (("1" (typepred "grS`count(refindex(rval))")
        (("1" (expand "refcount")
          (("1" (lemma "refcountStore_ref")
            (("1"
              (inst - "grS" "avalindex" "refindex(rval)" "value(pval)")
              (("1" (ground)
                (("1" (apply-extensionality :hide? t) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (postpone) nil nil))
      nil))
    nil)
   ((get const-decl "(value?)" IL nil)
    (value? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (lookupReduce_TCC12 0
  (lookupReduce_TCC12-1 nil 3696570131 ("" (subtype-tcc) nil nil) nil
   nil))
 (lookupReduce_TCC13 0
  (lookupReduce_TCC13-1 nil 3696570131 ("" (subtype-tcc) nil nil)
   ((get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (lookupReduce_TCC14 0
  (lookupReduce_TCC14-1 nil 3696824033 ("" (subtype-tcc) nil nil)
   ((get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (lookupReduce_TCC15 0
  (lookupReduce_TCC15-1 nil 3696824033 ("" (subtype-tcc) nil nil)
   ((get const-decl "(value?)" IL nil)
    (value? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (lookupReduce_TCC16 0
  (lookupReduce_TCC16-1 nil 3696824033
   ("" (skeep* :preds? t)
    (("" (use "reduction.lookupReduce_TCC6")
      (("" (inst - "rstate2estate(grS)" "stack")
        (("1" (split)
          (("1" (inst?)
            (("1" (split)
              (("1" (inst?)
                (("1" (split)
                  (("1" (inst?)
                    (("1" (split)
                      (("1" (inst?)
                        (("1" (split)
                          (("1" (inst - "pos")
                            (("1" (split)
                              (("1"
                                (inst?)
                                (("1"
                                  (split)
                                  (("1"
                                    (inst?)
                                    (("1"
                                      (ground)
                                      (("1" (lazy-grind) nil nil)
                                       ("2" (lazy-grind) nil nil)
                                       ("3" (lazy-grind) nil nil)
                                       ("4"
                                        (hide-all-but (-5 1))
                                        (("4" (grind) nil nil))
                                        nil)
                                       ("5"
                                        (skeep)
                                        (("5"
                                          (inst -18 "i")
                                          (("5"
                                            (ground)
                                            (("1"
                                              (hide-all-but
                                               (-1
                                                -2
                                                -12
                                                -13
                                                -20
                                                -22
                                                -26
                                                -27
                                                -29
                                                -31
                                                -34
                                                2))
                                              (("1" (grind) nil nil))
                                              nil)
                                             ("2"
                                              (lift-if)
                                              (("2" (ground) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (propax) nil nil))
                                  nil))
                                nil)
                               ("2" (propax) nil nil))
                              nil))
                            nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil)
                       ("2" (hide 3)
                        (("2" (grind :if-match nil) nil nil)) nil))
                      nil)
                     ("2" (hide 3) (("2" (lazy-grind) nil nil)) nil))
                    nil)
                   ("2" (hide 3) (("2" (grind :if-match nil) nil nil))
                    nil))
                  nil)
                 ("2" (hide 3) (("2" (lazy-grind) nil nil)) nil))
                nil)
               ("2" (hide 3) (("2" (grind :if-match nil) nil nil))
                nil))
              nil))
            nil)
           ("2" (hide 3) (("2" (grind :if-match nil) nil nil)) nil))
          nil)
         ("2" (hide 3) (("2" (grind :if-match nil) nil nil)) nil)
         ("3" (hide 3) (("3" (grind :if-match nil) nil nil)) nil))
        nil))
      nil))
    nil)
   ((lookupReduce_TCC6 subtype-tcc nil reduction nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (store skolem-const-decl "Store(grS`domain)" refreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (expr skolem-const-decl "{A |
        forall i: refs(A)(i) IMPLIES grS`domain(i)
    AND forall i: vars(A)(i) IMPLIES i + popDepth(A) < grS`stack`length
    AND popDepth(A) <= grS`stack`length AND contextPure?(A)
    AND mark(grS`contextvars)(A) = A
    AND forall i:
          i >= grS`stack`length OR
           vars(A)(i) OR
            grS`contextvars(i) OR
             NOT ref?(grS`stack`seq(grS`stack`length - 1 - i))}"
          refreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (get const-decl "(value?)" IL nil)
    (injective? const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (goodstate type-eq-decl nil reduction nil)
    (stack skolem-const-decl
     "{S: Stack | every(domainValue?(grS`domain))(S)}" refreduction
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (estate type-eq-decl nil reduction nil)
    (rstate2estate const-decl "estate" refreduction nil)
    (goodrstate type-eq-decl nil refreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (grS skolem-const-decl "{grS | lookupRedex?(grS`redex)}"
     refreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (lookupReduce_TCC17 0
  (lookupReduce_TCC17-1 nil 3696824033
   ("" (skeep* :preds? t)
    (("" (ground)
      (("1" (typepred "grS`count(avalindex)")
        (("1" (expand "refcount")
          (("1" (expand "refcountStack")
            (("1" (use "count_elem[(IL.value?)]")
              (("1" (ground)
                (("1" (expand "get")
                  (("1" (inst + "stack`length - 1 - index(avar)")
                    (("1" (assert) nil nil)
                     ("2" (ground)
                      (("2" (use "lookupReduce_TCC14")
                        (("2" (ground)
                          (("2" (inst?)
                            (("2" (ground)
                              (("2"
                                (inst?)
                                (("2"
                                  (ground)
                                  (("2"
                                    (inst?)
                                    (("2"
                                      (ground)
                                      (("2"
                                        (inst?)
                                        (("2"
                                          (ground)
                                          (("2"
                                            (inst - "pos")
                                            (("2"
                                              (ground)
                                              (("2"
                                                (inst?)
                                                (("2"
                                                  (ground)
                                                  (("2"
                                                    (inst?)
                                                    (("2"
                                                      (ground)
                                                      (("2"
                                                        (inst?)
                                                        (("2"
                                                          (ground)
                                                          (("2"
                                                            (inst
                                                             -
                                                             "rval")
                                                            (("2"
                                                              (ground)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (typepred "grS`count(avalindex)")
        (("2" (expand "refcount")
          (("2" (expand "refcountStack")
            (("2" (rewrite "count_update")
              (("1" (lift-if)
                (("1" (ground)
                  (("1" (replace -3 :hide? t)
                    (("1" (hide-all-but (-17 1 3))
                      (("1" (expand "lookupRedex?")
                        (("1" (expand "refcountExpr")
                          (("1" (expand "refs")
                            (("1" (assert)
                              (("1"
                                (typepred "rval")
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (replace -1 :hide? t)
                    (("2" (hide-all-but (1 -24 -23))
                      (("2" (grind) nil nil)) nil))
                    nil)
                   ("3" (hide-all-but (1 -31 -25 -24))
                    (("3" (grind) nil nil)) nil))
                  nil))
                nil)
               ("2" (inst -10 "index(avar)")
                (("2" (ground)
                  (("2" (hide-all-but (-15 1)) (("2" (grind) nil nil))
                    nil))
                  nil))
                nil)
               ("3" (hide-all-but (1)) (("3" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count_elem formula-decl nil finseq_theorems nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (lookupReduce_TCC14 subtype-tcc nil refreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (avar skolem-const-decl "(variable?)" refreduction nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (stack skolem-const-decl
     "{S: Stack | every(domainValue?(grS`domain))(S)}" refreduction
     nil)
    (grS skolem-const-decl "{grS | lookupRedex?(grS`redex)}"
     refreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (refcountStack const-decl "nat" refreduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (goodrstate type-eq-decl nil refreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (count_update formula-decl nil finseq_theorems nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (refcountExpr const-decl "nat" refreduction nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (lookupReduce_TCC18 0
  (lookupReduce_TCC18-1 nil 3696824033 ("" (subtype-tcc) nil nil)
   ((get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (lookupReduce_TCC19 0
  (lookupReduce_TCC19-1 nil 3696824033
   ("" (skeep* :preds? t)
    (("" (use "reduction.lookupReduce_TCC6")
      (("" (inst - "rstate2estate(grS)" "stack")
        (("1" (split)
          (("1" (inst?)
            (("1" (split)
              (("1" (inst?)
                (("1" (split)
                  (("1" (inst?)
                    (("1" (split)
                      (("1" (inst?)
                        (("1" (split)
                          (("1" (inst - "pos")
                            (("1" (split)
                              (("1"
                                (inst?)
                                (("1"
                                  (split)
                                  (("1"
                                    (inst?)
                                    (("1"
                                      (ground)
                                      (("1" (lazy-grind) nil nil)
                                       ("2" (lazy-grind) nil nil)
                                       ("3" (lazy-grind) nil nil)
                                       ("4"
                                        (hide-all-but (-5 1))
                                        (("4" (grind) nil nil))
                                        nil)
                                       ("5"
                                        (skeep)
                                        (("5"
                                          (inst -18 "i")
                                          (("5"
                                            (ground)
                                            (("5"
                                              (hide-all-but
                                               (-1
                                                -2
                                                -18
                                                -20
                                                3
                                                5
                                                -25
                                                -26
                                                -31
                                                -34
                                                -27))
                                              (("5"
                                                (grind)
                                                (("1"
                                                  (decompose-equality
                                                   -4)
                                                  (("1"
                                                    (decompose-equality
                                                     -1)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (decompose-equality
                                                   -3)
                                                  (("2"
                                                    (decompose-equality
                                                     -1)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (propax) nil nil))
                                  nil))
                                nil)
                               ("2" (propax) nil nil))
                              nil))
                            nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil)
                       ("2" (hide 3)
                        (("2" (grind :if-match nil) nil nil)) nil))
                      nil)
                     ("2" (hide 3) (("2" (lazy-grind) nil nil)) nil))
                    nil)
                   ("2" (hide 3) (("2" (grind :if-match nil) nil nil))
                    nil))
                  nil)
                 ("2" (hide 3) (("2" (lazy-grind) nil nil)) nil))
                nil)
               ("2" (hide 3) (("2" (grind :if-match nil) nil nil))
                nil))
              nil))
            nil)
           ("2" (hide 3) (("2" (grind :if-match nil) nil nil)) nil))
          nil)
         ("2" (hide 4) (("2" (grind) nil nil)) nil)
         ("3" (hide 4) (("3" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((lookupReduce_TCC6 subtype-tcc nil reduction nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (store skolem-const-decl "Store(grS`domain)" refreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (expr skolem-const-decl "{A |
        forall i: refs(A)(i) IMPLIES grS`domain(i)
    AND forall i: vars(A)(i) IMPLIES i + popDepth(A) < grS`stack`length
    AND popDepth(A) <= grS`stack`length AND contextPure?(A)
    AND mark(grS`contextvars)(A) = A
    AND forall i:
          i >= grS`stack`length OR
           vars(A)(i) OR
            grS`contextvars(i) OR
             NOT ref?(grS`stack`seq(grS`stack`length - 1 - i))}"
          refreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (markv const-decl "(variable?)" preprocess nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (FALSE const-decl "bool" booleans nil)
    (position adt-accessor-decl "[(lookup?) -> (variable?)]"
      IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (TRUE const-decl "bool" booleans nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]"
     IExpression_adt nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (get const-decl "(value?)" IL nil)
    (injective? const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (goodstate type-eq-decl nil reduction nil)
    (stack skolem-const-decl
     "{S: Stack | every(domainValue?(grS`domain))(S)}" refreduction
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (estate type-eq-decl nil reduction nil)
    (rstate2estate const-decl "estate" refreduction nil)
    (goodrstate type-eq-decl nil refreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (grS skolem-const-decl "{grS | lookupRedex?(grS`redex)}"
     refreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (lookupReduce_TCC20 0
  (lookupReduce_TCC20-1 nil 3696824033 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (goodrstate type-eq-decl nil refreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (lookupReduce_TCC21 0
  (lookupReduce_TCC21-1 nil 3696824033
   ("" (skeep* :preds? t)
    (("" (ground)
      (("" (typepred "grS`count(refindex(rval))")
        (("" (expand "refcount")
          (("" (replace -1 :hide? t)
            (("" (hide-all-but (3 -15))
              (("" (assert) (("" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (refcountExpr const-decl "nat" refreduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (goodrstate type-eq-decl nil refreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (lookupReduce_TCC22 0
  (lookupReduce_TCC22-1 nil 3696824033 ("" (subtype-tcc) nil nil) nil
   nil))
 (lookupReduce_TCC23 0
  (lookupReduce_TCC23-1 nil 3696824033 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" refreduction nil)
    (rstate type-eq-decl nil refreduction nil)
    (goodrstate type-eq-decl nil refreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil)))

