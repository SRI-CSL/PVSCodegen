(preprocess
 (release_set_TCC1 0
  (release_set_TCC1-1 nil 3655095779
   ("" (grind :rewrites "card_remove") nil nil)
   ((ccard const-decl "nat" preprocess nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (injective? const-decl "bool" functions nil)
    (card_remove formula-decl nil finite_sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (release_set termination
    "release_set(IExpression_adt.release(IExpression_adt.variable(i, TRUE), A), Y)"
    "nil")))
 (release_set_TCC2 0
  (release_set_TCC2-1 nil 3655095779 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil))
   nil (release_set subtype "X" "(sets[nat].nonempty?)")))
 (vars_release_set 0
  (vars_release_set-1 nil 3656129143
   ("" (induct "X" :name "finite_set_induction")
    (("1" (grind-with-ext) nil nil)
     ("2" (grind :if-match nil)
      (("2" (expand "release_set" +)
        (("2" (lift-if)
          (("2" (ground)
            (("1" (inst?) nil nil)
             ("2" (inst? -5)
              (("2" (replace -5)
                (("2" (expand "vars" + 1)
                  (("2" (grind-with-ext) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((remove const-decl "set" sets nil)
    (/= const-decl "boolean" notequal nil)
    (nonempty? const-decl "bool" sets nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (TRUE const-decl "bool" booleans nil)
    (choose const-decl "(p)" sets nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (add const-decl "(nonempty?)" sets nil)
    (x!3 skolem-const-decl "nat" preprocess nil)
    (X!1 skolem-const-decl "finite_set[nat]" preprocess nil)
    (nonempty_finite_union1 application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_set_induction formula-decl nil finite_set_theorems nil)
    (union const-decl "set" sets nil)
    (release_set def-decl "IExpression" preprocess nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (refs_release_set 0
  (refs_release_set-1 nil 3693115772
   ("" (induct "X" :name "finite_set_induction")
    (("1" (grind) nil nil)
     ("2" (grind :if-match nil)
      (("1" (expand "release_set" -7)
        (("1" (ground) (("1" (inst? -7) (("1" (grind) nil nil)) nil))
          nil))
        nil)
       ("2" (expand "release_set" +)
        (("2" (ground)
          (("2" (inst? -6)
            (("2" (replace -6)
              (("2" (hide-all-but (-7 2))
                (("2" (grind)
                  (("2" (expand "refs" +) (("2" (postpone) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((remove const-decl "set" sets nil)
    (/= const-decl "boolean" notequal nil)
    (nonempty? const-decl "bool" sets nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (choose const-decl "(p)" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_set_induction formula-decl nil finite_set_theorems nil)
    (release_set def-decl "IExpression" preprocess nil)
    (refs def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (top_releases_TCC1 0
  (top_releases_TCC1-1 nil 3698775181 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (top_releases termination "top_releases(B)" "nil")))
 (releaset_set_top 0
  (releaset_set_top-1 nil 3698775280
   ("" (induct "X" :name "finite_set_induction")
    (("1" (grind)
      (("1" (grind)
        (("1" (use card_emptyset) (("1" (grind) nil nil)) nil)) nil))
      nil)
     ("2" (skeep*)
      (("2" (expand release_set 1)
        (("2" (assert)
          (("2" (lift-if)
            (("2" (split)
              (("1" (grind) nil nil)
               ("2" (ground)
                (("2"
                  (inst -2 "release(variable(choose(X_1), TRUE), A)")
                  (("2" (rewrite -2)
                    (("2" (expand top_releases 2 1)
                      (("2" (expand ccard)
                        (("2" (use card_remove) (("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nonempty? const-decl "bool" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (choose const-decl "(p)" sets nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (card_remove formula-decl nil finite_sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (card_emptyset formula-decl nil finite_sets nil)
    (finite_set_induction formula-decl nil finite_set_theorems nil)
    (ccard const-decl "nat" preprocess nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (release_set def-decl "IExpression" preprocess nil)
    (top_releases def-decl "nat" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (eq_release_set 0
  (eq_release_set-1 nil 3698774797
   ("" (skeep*)
    (("" (use releaset_set_top)
      (("" (rewrite -2)
        (("" (simplify)
          (("" (use empty_card) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((releaset_set_top formula-decl nil preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (ccard const-decl "nat" preprocess nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (empty_card formula-decl nil finite_sets nil))
   shostak))
 (markvar_TCC1 0
  (markvar_TCC1-1 nil 3655327556 ("" (subtype-tcc) nil nil) nil nil
   (markvar subtype "x" "(IExpression_adt.variable?)")))
 (markvar_TCC2 0
  (markvar_TCC2-1 nil 3698774796 ("" (subtype-tcc) nil nil) nil nil
   (markvar subtype "x WITH [`marked := TRUE]"
    "(IExpression_adt.variable?)")))
 (markvars_TCC1 0
  (markvars_TCC1-1 nil 3655327556 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (length def-decl "nat" list_props nil))
   nil
   (markvars subtype "list_adt[(IExpression_adt.variable?)].null"
    "{J | list_props[(IExpression_adt.variable?)].length(J) = list_props[(IExpression_adt.variable?)].length(L)}")))
 (markvars_TCC2 0
  (markvars_TCC2-1 nil 3655327556 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil)
    (injective? const-decl "bool" functions nil)
    (in_varlist const-decl "finite_set[nat]" IL nil))
   nil (markvars termination "markvars(X)(L1)" "nil")))
 (markvars_TCC3 0
  (markvars_TCC3-1 nil 3655523103 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (injective? const-decl "bool" functions nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (length def-decl "nat" list_props nil))
   nil
   (markvars subtype
    "list_adt[(IExpression_adt.variable?)].cons(unmarkvar(x), markvars(X)(L1))"
    "{J | list_props[(IExpression_adt.variable?)].length(J) = list_props[(IExpression_adt.variable?)].length(L)}")))
 (markvars_TCC4 0
  (markvars_TCC4-1 nil 3655523103 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil)
    (injective? const-decl "bool" functions nil)
    (in_varlist const-decl "finite_set[nat]" IL nil))
   nil (markvars termination "markvars(X)(L1)" "nil")))
 (markvars_TCC5 0
  (markvars_TCC5-1 nil 3655523103 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (injective? const-decl "bool" functions nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (markvar const-decl "(variable?)" preprocess nil)
    (length def-decl "nat" list_props nil))
   nil
   (markvars subtype
    "list_adt[(IExpression_adt.variable?)].cons(markvar(x), markvars(X)(L1))"
    "{J | list_props[(IExpression_adt.variable?)].length(J) = list_props[(IExpression_adt.variable?)].length(L)}")))
 (markvars_index_TCC1 0
  (markvars_index_TCC1-1 nil 3655520141 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil))
   nil
   (markvars_index subtype "i"
    "below[length[(IExpression_adt.variable?)](markvars(X)(L))]")))
 (markvars_index 0
  (markvars_index-1 nil 3655520143
   ("" (induct "L")
    (("1" (grind) nil nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (case "i = 0")
          (("1" (grind) nil nil)
           ("2" (inst - "X" "i - 1")
            (("1" (grind) nil nil)
             ("2" (grind)
              (("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2) (("3" (grind) nil nil)) nil))
    nil)
   ((injective? const-decl "bool" functions nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (markvar const-decl "(variable?)" preprocess nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (i skolem-const-decl "below(length(cons(cons1_var, cons2_var)))"
       preprocess nil)
    (cons2_var skolem-const-decl "list[(variable?)]" preprocess nil)
    (cons1_var skolem-const-decl "(variable?)" preprocess nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (list_induction formula-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (list type-decl nil list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil))
   shostak))
 (markvars_mark_TCC1 0
  (markvars_mark_TCC1-1 nil 3683255315 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (injective? const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (markvars_mark subtype "j"
    "below[length[(IExpression_adt.variable?)](markvars(X)(L))]")))
 (markvars_mark 0
  (markvars_mark-1 nil 3683246771
   ("" (induct "L")
    (("1" (grind) nil nil)
     ("2" (skeep*)
      (("2" (case "i = 0")
        (("1" (grind :if-match nil)
          (("1"
            (case "some(lambda (v: (variable?)):
                                        index(v) = index(cons1_var))
                                     (cons2_var)")
            (("1" (assert)
              (("1" (rewrite "some_nth")
                (("1" (skeep)
                  (("1" (inst - "X" "i!1")
                    (("1" (ground)
                      (("1" (skeep)
                        (("1" (inst + "j + 1") (("1" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (inst + 0)
              (("1" (grind) nil nil) ("2" (assert) nil nil)) nil))
            nil))
          nil)
         ("2" (inst - "X" "i - 1")
          (("1" (grind :if-match nil)
            (("1" (inst + "j!1 + 1") (("1" (grind) nil nil)) nil)) nil)
           ("2" (ground)
            (("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil)
     ("3" (hide 2) (("3" (grind) nil nil)) nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (cons1_var skolem-const-decl "(variable?)" preprocess nil)
    (i skolem-const-decl "below(length(cons(cons1_var, cons2_var)))"
       preprocess nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (markvar const-decl "(variable?)" preprocess nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (cons2_var skolem-const-decl "list[(variable?)]" preprocess nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (some adt-def-decl "boolean" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil))
   shostak))
 (markvars_markX 0
  (markvars_markX-1 nil 3693198805
   ("" (induct "L")
    (("1" (grind) nil nil)
     ("2" (skeep*)
      (("2" (expand "markvars")
        (("2" (lift-if)
          (("2" (ground)
            (("1" (case "j = 0")
              (("1" (grind) nil nil)
               ("2" (inst - "X" "j - 1")
                (("1" (grind) nil nil)
                 ("2" (grind)
                  (("2" (typepred "j") (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (case "j = 0")
              (("1" (grind) nil nil)
               ("2" (inst - "X" "j - 1")
                (("1" (grind) nil nil)
                 ("2" (typepred "j") (("2" (grind) nil nil)) nil))
                nil))
              nil)
             ("3" (case "j = 0")
              (("1" (grind) nil nil)
               ("2" (inst - "X" "j - 1")
                (("1" (grind) nil nil)
                 ("2" (typepred "j") (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2) (("3" (grind) nil nil)) nil))
    nil)
   ((some adt-def-decl "boolean" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (markvar const-decl "(variable?)" preprocess nil)
    (j skolem-const-decl "below(length(cons(cons1_var, cons2_var)))"
     preprocess nil)
    (cons2_var skolem-const-decl "list[(variable?)]" preprocess nil)
    (cons1_var skolem-const-decl "(variable?)" preprocess nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil))
   shostak))
 (markvars_mark_def 0
  (markvars_mark_def-1 nil 3706622718
   ("" (induct L)
    (("1" (grind) nil nil)
     ("2" (skeep* :preds? t)
      (("2" (expand markvars +)
        (("2" (expand nth +)
          (("2" (case-replace "j = 0")
            (("1" (assert)
              (("1" (lift-if)
                (("1" (split)
                  (("1" (flatten)
                    (("1" (iff)
                      (("1" (split)
                        (("1" (assert) (("1" (grind) nil nil)) nil)
                         ("2" (assert)
                          (("2" (split)
                            (("1" (flatten) (("1" (grind) nil nil))
                              nil)
                             ("2" (flatten)
                              (("2"
                                (expand in_varlist)
                                (("2"
                                  (rewrite some_nth)
                                  (("2"
                                    (skeep)
                                    (("2"
                                      (inst -1 "i+1")
                                      (("1" (grind) nil nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (assert)
                      (("2" (iff)
                        (("2" (split)
                          (("1" (flatten)
                            (("1" (skeep)
                              (("1"
                                (expand in_varlist)
                                (("1"
                                  (rewrite some_nth)
                                  (("1"
                                    (inst 3 "k-1")
                                    (("1" (grind) nil nil)
                                     ("2"
                                      (typepred k)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (assert)
              (("2" (inst -5 X "j-1")
                (("1" (replace -5)
                  (("1" (iff)
                    (("1" (split)
                      (("1" (flatten)
                        (("1" (assert)
                          (("1" (skeep)
                            (("1" (lift-if)
                              (("1"
                                (split)
                                (("1" (grind) nil nil)
                                 ("2"
                                  (flatten)
                                  (("2"
                                    (inst -2 "k-1")
                                    (("1" (grind) nil nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (assert)
                          (("2" (split)
                            (("1" (propax) nil nil)
                             ("2" (skeep)
                              (("2"
                                (inst -1 "k+1")
                                (("1" (assert) nil nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (grind) nil nil))
    nil)
   ((k skolem-const-decl "below(length(cons(cons1_var, cons2_var)))"
     preprocess nil)
    (k skolem-const-decl "below(length(cons2_var))" preprocess nil)
    (j skolem-const-decl "below(length(cons(cons1_var, cons2_var)))"
     preprocess nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (cons2_var skolem-const-decl "list[(variable?)]" preprocess nil)
    (i skolem-const-decl "below(length(cons2_var))" preprocess nil)
    (cons1_var skolem-const-decl "(variable?)" preprocess nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (markvar const-decl "(variable?)" preprocess nil)
    (k skolem-const-decl "below(length(cons(cons1_var, cons2_var)))"
     preprocess nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (injective? const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (list type-decl nil list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil))
   shostak))
 (markvars_idem 0
  (markvars_idem-1 nil 3655518488
   (""
    (induct-and-simplify "L" :rewrites ("some_nth" "markvars_index"))
    nil nil)
   ((markvars_index formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (markvar const-decl "(variable?)" preprocess nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (list_induction formula-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (markvars_varlist 0
  (markvars_varlist-1 nil 3699196365
   ("" (skeep*)
    (("" (expand in_varlist)
      (("" (apply-extensionality)
        (("" (delete 2)
          (("" (rewrite some_nth)
            (("" (rewrite some_nth)
              (("" (lemma markvars_index) (("" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((in_varlist const-decl "finite_set[nat]" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (markvars_index formula-decl nil preprocess nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (some adt-def-decl "boolean" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (length def-decl "nat" list_props nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (markvars_repeat 0
  (markvars_repeat-1 nil 3699195931
   ("" (induct L)
    (("1" (grind) nil nil)
     ("2" (skeep*)
      (("2" (expand markvars 1 (2 3))
        (("2" (expand markvars 1 (1 3))
          (("2" (lift-if)
            (("2" (expand markvar)
              (("2" (expand unmarkvar)
                (("2" (split)
                  (("1" (flatten)
                    (("1" (split 1)
                      (("1" (flatten)
                        (("1" (inst? -3)
                          (("1" (split -3)
                            (("1" (grind) nil nil)
                             ("2" (hide-all-but (1 -3))
                              (("2"
                                (skeep*)
                                (("2" (grind) nil nil))
                                nil))
                              nil)
                             ("3" (propax) nil nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (hide-all-but (-1 -4 1 2))
                          (("2" (rewrite markvars_varlist)
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (split 3)
                      (("1" (flatten)
                        (("1" (rewrite markvars_varlist)
                          (("1" (grind) nil nil)) nil))
                        nil)
                       ("2" (flatten)
                        (("2" (inst? -1) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((markvar const-decl "(variable?)" preprocess nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (markvars_varlist formula-decl nil preprocess nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (some adt-def-decl "boolean" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (markvars_bump 0
  (markvars_bump-1 nil 3699206885
   ("" (induct L)
    (("1" (grind) nil nil)
     ("2" (skeep*)
      (("2" (expand markvars 1 1)
        (("2" (expand map 1)
          (("2" (expand markvars 1 3)
            (("2" (lift-if)
              (("2" (lift-if)
                (("2" (lift-if)
                  (("2" (split 1)
                    (("1" (flatten)
                      (("1" (split 1)
                        (("1" (grind-with-ext) nil nil)
                         ("2" (flatten)
                          (("2" (delete -2 3)
                            (("2" (expand bump)
                              (("2"
                                (expand bumpn)
                                (("2"
                                  (expand in_varlist)
                                  (("2"
                                    (rewrite some_map)
                                    (("2"
                                      (expand o)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (split 3)
                        (("1" (flatten)
                          (("1" (delete 1 -2)
                            (("1" (expand bump)
                              (("1"
                                (expand bumpn)
                                (("1"
                                  (expand in_varlist)
                                  (("1"
                                    (rewrite some_map)
                                    (("1"
                                      (expand o)
                                      (("1" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind-with-ext) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((markvar const-decl "(variable?)" preprocess nil)
    (O const-decl "T3" function_props nil)
    (some_map formula-decl nil finseq_theorems nil)
    (TRUE const-decl "bool" booleans nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (IExpression_variable_extensionality formula-decl nil
     IExpression_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (FALSE const-decl "bool" booleans nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (list_induction formula-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil)
    (length def-decl "nat" list_props nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (markv_idem 0
  (markv_idem-1 nil 3699190320 ("" (grind) nil nil)
   ((markv const-decl "(variable?)" preprocess nil)) shostak))
 (mark_TCC1 0
  (mark_TCC1-1 nil 3655095779
   ("" (skeep)
    (("" (rewrite "every_nth")
      (("" (skeep)
        (("" (expand "<<")
          (("" (assert)
            (("" (rewrite "some_nth")
              (("" (inst + "i")
                (("1" (grind) nil nil)
                 ("2" (grind)
                  (("2" (typepred "i") (("2" (propax) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil nil (mark subtype "A" "(IExpression_adt.variable?)")))
 (mark_TCC2 0
  (mark_TCC2-1 nil 3655095779 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (injective? const-decl "bool" functions nil)
    (bump const-decl "finite_set[nat]" IL nil))
   nil
   (mark termination "mark(sets[nat].union(IL.drop(IL.vars(C)), X))(B)"
    "nil")))
 (mark_TCC3 0
  (mark_TCC3-1 nil 3655095779
   ("" (skeep :preds? t)
    (("" (grind :if-match nil)
      (("" (inst + "N!1" "(LAMBDA (i | i > 0 AND X(i-1)):  f!1(i-1))")
        (("1" (skeep)
          (("1" (forward-chain -2) (("1" (ground) nil nil)) nil)) nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (mark termination "mark(IL.bump(X))(C)" "nil")))
 (mark_TCC4 0
  (mark_TCC4-1 nil 3655095779 ("" (grind) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (mark termination "mark(IL.bump(X))(C)" "nil")))
 (mark_TCC5 0
  (mark_TCC5-1 nil 3655095779 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (injective? const-decl "bool" functions nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/"))
   nil (mark termination "mark(X)(B)" "nil")))
 (mark_TCC6 0
  (mark_TCC6-1 nil 3655095779 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (injective? const-decl "bool" functions nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/"))
   nil (mark termination "mark(X)(C)" "nil")))
 (mark_TCC7 0
  (mark_TCC7-1 nil 3655095779 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (mark termination "mark(IL.bump(X))(B)" "nil")))
 (vars_mark 0
  (vars_mark-1 nil 3656126421
   ("" (induct-and-simplify "B")
    (("1" (grind-with-ext) nil nil)
     ("2" (grind-with-ext :rewrites "markvars_index")
      (("1" (rewrite "some_nth")
        (("1" (rewrite "some_nth") (("1" (lazy-grind) nil nil)) nil))
        nil)
       ("2" (rewrite "some_nth")
        (("2" (rewrite "some_nth") (("2" (lazy-grind) nil nil)) nil))
        nil))
      nil)
     ("3" (grind) (("3" (apply-extensionality) nil nil)) nil)
     ("4" (grind)
      (("4" (rewrite "vars_release_set")
        (("4" (rewrite "vars_release_set")
          (("4" (replace -1 :hide? t)
            (("4" (replace -1 :hide? t)
              (("4" (apply-extensionality) (("4" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (grind) nil nil) ("6" (grind) nil nil) ("7" (grind) nil nil))
    nil)
   ((vars_release_set formula-decl nil preprocess nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (length def-decl "nat" list_props nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (markvars_index formula-decl nil preprocess nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (markv const-decl "(variable?)" preprocess nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (difference const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (nonempty? const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[T]" countability "sets_aux/")
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (IExpression_induction formula-decl nil IExpression_adt nil))
   shostak))
 (vars_mark_type 0
  (vars_mark_type-1 nil 3656867445 ("" (use "vars_mark") nil nil)
   ((vars_mark formula-decl nil preprocess nil)) nil
   (vars_mark_type subtype "mark(X)(B)"
    "{C | IL.vars(C) = IL.vars(B)}")))
 (mark_release_set 0
  (mark_release_set-1 nil 3656260905
   ("" (induct "Y" :name "finite_set_induction")
    (("1" (grind) nil nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (expand "release_set" +)
          (("2" (lift-if)
            (("2" (ground)
              (("2" (inst?)
                (("2" (ground)
                  (("1" (replace -1 :hide? t)
                    (("1" (rewrite "mark") (("1" (grind) nil nil))
                      nil))
                    nil)
                   ("2" (hide 3)
                    (("2" (expand "disjoint?")
                      (("2" (expand "empty?")
                        (("2" (lazy-grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (remove const-decl "set" sets nil)
    (/= const-decl "boolean" notequal nil)
    (markv const-decl "(variable?)" preprocess nil)
    (add const-decl "(nonempty?)" sets nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (nonempty? const-decl "bool" sets nil)
    (choose const-decl "(p)" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_intersection2 application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (finite_set_induction formula-decl nil finite_set_theorems nil)
    (release_set def-decl "IExpression" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (disjoint? const-decl "bool" sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (mark_idem 0
  (mark_idem-1 nil 3655518427
   ("" (induct "A")
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (skeep*)
      (("4" (expand mark 1) (("4" (rewrite markvars_idem) nil nil))
        nil))
      nil)
     ("5" (skeep*)
      (("5" (expand mark 1)
        (("5" (decompose-equality 1)
          (("1" (rewrite vars_mark)
            (("1" (expand vars 1 3)
              (("1" (rewrite vars_mark)
                (("1" (expand drop)
                  (("1" (expand add)
                    (("1" (expand member) (("1" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand vars 1 3)
            (("2" (expand add 1 1)
              (("2" (rewrite vars_mark)
                (("2" (simplify)
                  (("2" (lift-if)
                    (("2" (expand mark 1 4)
                      (("2" (expand markv 1)
                        (("2" (rewrite vars_mark)
                          (("2" (expand union)
                            (("2" (expand bump)
                              (("2"
                                (expand member)
                                (("2"
                                  (expand bumpn 1 4)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep*)
      (("6" (expand mark 1)
        (("6" (decompose-equality)
          (("1" (rewrite vars_release_set)
            (("1" (rewrite vars_release_set)
              (("1" (rewrite vars_mark)
                (("1" (rewrite vars_mark)
                  (("1"
                    (case-replace "union(union(vars(ift2_var),
                        difference(vars(ift3_var),
                                   union(vars(ift2_var), X))),
                  union(union(vars(ift3_var),
                              difference(vars(ift2_var),
                                         union(vars(ift3_var), X))),
                        X)) = union(vars(ift2_var), union(vars(ift3_var), X))")
                    (("1" (grind) nil nil)
                     ("2" (delete 2)
                      (("2" (expand union)
                        (("2" (expand difference)
                          (("2" (expand member)
                            (("2" (grind-with-ext) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2"
            (case-replace
             "difference(vars(release_set(mark(X)(ift3_var),
                                              difference
                                              (vars(ift2_var),
                                               union(vars(ift3_var), X)))),
                             union(vars(release_set
                                        (mark(X)(ift2_var),
                                         difference
                                         (vars(ift3_var),
                                          union(vars(ift2_var), X)))),
                                   X)) = emptyset")
            (("1" (simplify)
              (("1" (expand release_set 1 1)
                (("1" (expand empty?)
                  (("1" (expand emptyset 1)
                    (("1" (expand member 1)
                      (("1" (rewrite mark_release_set)
                        (("1" (rewrite -3) nil nil)
                         ("2" (expand disjoint?)
                          (("2" (expand empty?)
                            (("2" (expand intersection)
                              (("2"
                                (expand difference)
                                (("2"
                                  (rewrite vars_mark)
                                  (("2"
                                    (expand union)
                                    (("2"
                                      (expand member)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (delete 2)
              (("2" (rewrite vars_release_set)
                (("2" (rewrite vars_release_set)
                  (("2" (rewrite vars_mark)
                    (("2" (rewrite vars_mark)
                      (("2" (grind-with-ext) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3"
            (case-replace
             "difference(vars(release_set(mark(X)(ift2_var),
                                              difference
                                              (vars(ift3_var),
                                               union(vars(ift2_var), X)))),
                             union(vars(release_set
                                        (mark(X)(ift3_var),
                                         difference
                                         (vars(ift2_var),
                                          union(vars(ift3_var), X)))),
                                   X)) = emptyset")
            (("1" (rewrite mark_release_set)
              (("1" (rewrite -4) (("1" (grind) nil nil)) nil)
               ("2" (rewrite vars_mark) (("2" (grind) nil nil)) nil))
              nil)
             ("2" (delete 2)
              (("2" (rewrite vars_release_set)
                (("2" (rewrite vars_release_set)
                  (("2" (rewrite vars_mark)
                    (("2" (rewrite vars_mark)
                      (("2" (grind-with-ext) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)
     ("10" (grind) nil nil) ("11" (grind) nil nil)
     ("12" (grind) nil nil) ("13" (grind) nil nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (release_set def-decl "IExpression" preprocess nil)
    (difference const-decl "set" sets nil)
    (IExpression_ift_extensionality formula-decl nil IExpression_adt
     nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (vars_release_set formula-decl nil preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (empty? const-decl "bool" sets nil)
    (finite_intersection2 application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (disjoint? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (mark_release_set formula-decl nil preprocess nil)
    (emptyset const-decl "set" sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (union const-decl "set" sets nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (IExpression_letexpr_extensionality formula-decl nil
     IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (member const-decl "bool" sets nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (add const-decl "(nonempty?)" sets nil)
    (vars_mark formula-decl nil preprocess nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (markvars_idem formula-decl nil preprocess nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (markv const-decl "(variable?)" preprocess nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (mark_repeat 0
  (mark_repeat-1 nil 3699193091
   ("" (induct A)
    (("1" (skeep*)
      (("1" (expand mark 1 (2 3))
        (("1" (expand markv)
          (("1" (expand mark)
            (("1" (expand markv)
              (("1" (lift-if) (("1" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (skeep*)
      (("4" (expand mark 1)
        (("4" (decompose-equality 1)
          (("4" (use markvars_repeat) (("4" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("5" (skeep*)
      (("5" (expand mark 1)
        (("5" (rewrite vars_mark)
          (("5" (expand vars 1 3)
            (("5" (rewrite vars_mark)
              (("5" (decompose-equality)
                (("1" (rewrite -1)
                  (("1" (hide-all-but (-3 -4 1))
                    (("1" (skeep*)
                      (("1" (typepred i)
                        (("1" (expand union)
                          (("1" (expand drop)
                            (("1" (expand add)
                              (("1"
                                (expand member)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide-all-but (1 -3 -4))
                    (("2" (skeep*)
                      (("2" (typepred i)
                        (("2" (expand union)
                          (("2" (expand drop)
                            (("2" (expand add)
                              (("2"
                                (expand member)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (lift-if)
                  (("2" (lift-if)
                    (("2" (ground)
                      (("1" (rewrite -3)
                        (("1" (hide-all-but (-1 -4 -5 1))
                          (("1" (skeep*)
                            (("1" (typepred i)
                              (("1"
                                (expand bump)
                                (("1"
                                  (expand bumpn)
                                  (("1" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (skeep*)
                          (("2" (typepred i)
                            (("2" (hide-all-but (-1 -2 -5 -6 1))
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand mark 1 1)
                        (("2" (decompose-equality)
                          (("1" (expand markv)
                            (("1" (lift-if)
                              (("1"
                                (ground)
                                (("1"
                                  (hide-all-but (-1 -5 -6))
                                  (("1" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (rewrite -3)
                            (("1" (hide-all-but (-4 -5 1))
                              (("1"
                                (skeep*)
                                (("1"
                                  (typepred i)
                                  (("1" (grind) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide-all-but (1 -4 -5))
                              (("2"
                                (skeep*)
                                (("2"
                                  (typepred i)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep*)
      (("6" (expand mark 1)
        (("6" (decompose-equality)
          (("1" (rewrite vars_release_set)
            (("1" (rewrite vars_mark)
              (("1" (rewrite vars_release_set)
                (("1" (rewrite vars_mark)
                  (("1" (expand markv)
                    (("1" (lift-if)
                      (("1" (lift-if)
                        (("1" (lift-if)
                          (("1" (ground)
                            (("1" (delete -2 -3 -4)
                              (("1" (grind) nil nil)) nil)
                             ("2" (delete -2 -3 -4)
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (rewrite mark_release_set)
            (("1" (rewrite -2)
              (("1" (rewrite vars_release_set)
                (("1" (rewrite vars_release_set)
                  (("1" (rewrite vars_mark)
                    (("1" (rewrite vars_mark)
                      (("1" (expand difference)
                        (("1" (expand union)
                          (("1" (expand member)
                            (("1"
                              (case-replace "{x_1: nat |
                     (vars(ift3_var)(x_1) OR
                       vars(ift2_var)(x_1) AND
                        NOT (vars(ift3_var)(x_1) OR Y(x_1)))
                      AND
                      NOT ((vars(ift2_var)(x_1) OR
                             vars(ift3_var)(x_1) AND
                              NOT (vars(ift2_var)(x_1) OR Y(x_1)))
                            OR X(x_1))} = emptyset")
                              (("1"
                                (expand release_set 1 1)
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (delete 2)
                                (("2"
                                  (hide-all-but (1 -4 -5))
                                  (("2" (grind-with-ext) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide-all-but (1 -4 -5))
                (("2" (skeep*)
                  (("2" (inst -2 i)
                    (("2" (split -2)
                      (("1" (propax) nil nil) ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (delete 2)
              (("2" (expand disjoint?)
                (("2" (expand intersection)
                  (("2" (expand difference)
                    (("2" (expand union)
                      (("2" (expand member)
                        (("2" (expand empty?)
                          (("2" (skeep*)
                            (("2" (expand member)
                              (("2"
                                (hide-all-but (-1 -5 -6))
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (rewrite mark_release_set)
            (("1" (rewrite vars_release_set)
              (("1" (rewrite vars_release_set)
                (("1" (rewrite vars_mark)
                  (("1" (rewrite vars_mark)
                    (("1" (rewrite -3)
                      (("1"
                        (case-replace "difference(union(vars(ift2_var),
                                   difference(vars(ift3_var),
                                              union(vars(ift2_var), Y))),
                             union(union(vars(ift3_var),
                                         difference
                                         (vars(ift2_var),
                                          union(vars(ift3_var), Y))),
                                   X)) = emptyset")
                        (("1" (expand release_set 1 1)
                          (("1" (grind) nil nil)) nil)
                         ("2" (delete 2)
                          (("2" (hide-all-but (1 -4 -5))
                            (("2" (grind-with-ext) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (hide-all-but (1 -4 -5))
                        (("2" (skeep*)
                          (("2" (inst -2 i) (("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide-all-but (1 -4 -5))
              (("2" (rewrite vars_mark)
                (("2" (expand disjoint?)
                  (("2" (expand empty?)
                    (("2" (expand intersection)
                      (("2" (expand difference)
                        (("2" (expand union)
                          (("2" (expand member)
                            (("2" (skeep*)
                              (("2"
                                (ground)
                                (("2"
                                  (inst -3 x)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skeep*)
      (("7" (expand mark 1)
        (("7" (decompose-equality)
          (("1" (expand markv)
            (("1" (lift-if)
              (("1" (lift-if)
                (("1" (lift-if)
                  (("1" (lift-if)
                    (("1" (ground)
                      (("1" (hide-all-but (-1 -5 -6 1))
                        (("1" (grind) nil nil)) nil)
                       ("2" (hide-all-but (-1 -5 -6 2))
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand markv)
            (("2" (lift-if)
              (("2" (lift-if)
                (("2" (lift-if)
                  (("2" (lift-if)
                    (("2" (ground)
                      (("1" (hide-all-but (-1 -5 -6 1))
                        (("1" (grind) nil nil)) nil)
                       ("2" (hide-all-but (-1 -5 -6 2))
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (expand markv)
            (("3" (lift-if)
              (("3" (lift-if)
                (("3" (lift-if)
                  (("3" (ground)
                    (("1" (hide-all-but (-1 -5 -6 1))
                      (("1" (grind) nil nil)) nil)
                     ("2" (hide-all-but (-1 -5 -6 2))
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (skeep*)
      (("8" (expand mark 1)
        (("8" (decompose-equality)
          (("1" (expand markv)
            (("1" (lift-if)
              (("1" (lift-if)
                (("1" (lift-if)
                  (("1" (lift-if)
                    (("1" (ground)
                      (("1" (hide-all-but (-1 -4 -5 1))
                        (("1" (grind) nil nil)) nil)
                       ("2" (hide-all-but (-1 -4 -5 2))
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand markv)
            (("2" (lift-if)
              (("2" (lift-if)
                (("2" (lift-if)
                  (("2" (ground)
                    (("1" (hide-all-but (-1 -4 -5 1))
                      (("1" (grind) nil nil)) nil)
                     ("2" (hide-all-but (-1 -4 -5 2))
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (skeep*)
      (("11" (expand mark 1)
        (("11" (decompose-equality)
          (("11" (rewrite -1)
            (("1" (grind) nil nil)
             ("2" (delete 2) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("12" (grind) nil nil)
     ("13" (skeep*)
      (("13" (expand mark 1)
        (("13" (decompose-equality)
          (("1" (expand markv)
            (("1" (lift-if)
              (("1" (lift-if)
                (("1" (lift-if)
                  (("1" (ground)
                    (("1" (hide-all-but (-1 -4 -5 1))
                      (("1" (grind) nil nil)) nil)
                     ("2" (hide-all-but (-1 -4 -5 2))
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (rewrite -2) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((release1_var skolem-const-decl "(variable?)" preprocess nil)
    (X skolem-const-decl "finite_set[nat]" preprocess nil)
    (Y skolem-const-decl "finite_set[nat]" preprocess nil)
    (release2_var skolem-const-decl "IExpression" preprocess nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (IExpression_pop_extensionality formula-decl nil IExpression_adt
     nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (Y skolem-const-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (i!1 skolem-const-decl "(bump(Y))" preprocess nil)
    (i!1 skolem-const-decl "(bump(Y))" preprocess nil)
    (injective? const-decl "bool" functions nil)
    (X skolem-const-decl "finite_set[nat]" preprocess nil)
    (i!1 skolem-const-decl "(bump(X))" preprocess nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (IExpression_lookup_extensionality formula-decl nil IExpression_adt
     nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lookup1_var skolem-const-decl "(variable?)" preprocess nil)
    (X skolem-const-decl "finite_set[nat]" preprocess nil)
    (update adt-constructor-decl
     "[[(variable?), (variable?), (variable?)] -> (update?)]"
     IExpression_adt nil)
    (IExpression_update_extensionality formula-decl nil IExpression_adt
     nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (update1_var skolem-const-decl "(variable?)" preprocess nil)
    (X skolem-const-decl "finite_set[nat]" preprocess nil)
    (update2_var skolem-const-decl "(variable?)" preprocess nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (difference const-decl "set" sets nil)
    (release_set def-decl "IExpression" preprocess nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (IExpression_ift_extensionality formula-decl nil IExpression_adt
     nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (X skolem-const-decl "finite_set[nat]" preprocess nil)
    (ift1_var skolem-const-decl "(variable?)" preprocess nil)
    (vars_release_set formula-decl nil preprocess nil)
    (intersection const-decl "set" sets nil)
    (disjoint? const-decl "bool" sets nil)
    (finite_intersection2 application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (empty? const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (x!1 skolem-const-decl "nat" preprocess nil)
    (Y skolem-const-decl "finite_set[nat]" preprocess nil)
    (x!1 skolem-const-decl "nat" preprocess nil)
    (mark_release_set formula-decl nil preprocess nil)
    (x!1 skolem-const-decl "nat" preprocess nil)
    (x!1 skolem-const-decl "nat" preprocess nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (vars_mark formula-decl nil preprocess nil)
    (X skolem-const-decl "finite_set[nat]" preprocess nil)
    (i skolem-const-decl "(bump(Y))" preprocess nil)
    (Y skolem-const-decl "finite_set[nat]" preprocess nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IExpression_release_extensionality formula-decl nil
     IExpression_adt nil)
    (i skolem-const-decl "(bump(Y))" preprocess nil)
    (member const-decl "bool" sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression_letexpr_extensionality formula-decl nil
     IExpression_adt nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (union const-decl "set" sets nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil)
    (length def-decl "nat" list_props nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (IExpression_application_extensionality formula-decl nil
     IExpression_adt nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (markvars_repeat formula-decl nil preprocess nil)
    (emptyset const-decl "set" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (singleton const-decl "(singleton?)" sets nil)
    (Y skolem-const-decl "finite_set[nat]" preprocess nil)
    (variable1_var skolem-const-decl "nat" preprocess nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (refs_mark 0
  (refs_mark-1 nil 3693113889
   ("" (induct "A")
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (grind :rewrites "refs_release_set") nil nil)
     ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)
     ("10" (grind) nil nil) ("11" (grind) nil nil)
     ("12" (grind) nil nil) ("13" (grind) nil nil))
    nil)
   ((bumpn const-decl "finite_set[nat]" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (X!1 skolem-const-decl "finite_set[nat]" preprocess nil)
    (N!1 skolem-const-decl "nat" preprocess nil)
    (N!1 skolem-const-decl "nat" preprocess nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (refs_release_set formula-decl nil preprocess nil)
    (empty? const-decl "bool" sets nil)
    (difference const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (bump const-decl "finite_set[nat]" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (union const-decl "set" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (markv const-decl "(variable?)" preprocess nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (mark def-decl "IExpression" preprocess nil)
    (refs def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (popDepth_mark 0
  (popDepth_mark-1 nil 3693282152
   ("" (induct-and-simplify "A") nil nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (popDepth def-decl "nat" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (bump const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (difference const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil))
   shostak))
 (top_releases_mark 0
  (top_releases_mark-1 nil 3698777907
   ("" (induct-and-rewrite! "A") nil nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (top_releases def-decl "nat" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (markv const-decl "(variable?)" preprocess nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (difference const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (eq_mark_release_set 0
  (eq_mark_release_set-1 nil 3698777865
   ("" (skeep*)
    ((""
      (case "top_releases(release_set(mark(Y)(A), X)) = top_releases(A)")
      (("1" (rewrite "releaset_set_top")
        (("1" (rewrite "top_releases_mark")
          (("1" (use empty_card) (("1" (grind) nil nil)) nil)) nil))
        nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   ((mark def-decl "IExpression" preprocess nil)
    (release_set def-decl "IExpression" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (top_releases def-decl "nat" preprocess nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (top_releases_mark formula-decl nil preprocess nil)
    (ccard const-decl "nat" preprocess nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (empty_card formula-decl nil finite_sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (releaset_set_top formula-decl nil preprocess nil))
   shostak))
 (mvars_TCC1 0
  (mvars_TCC1-1 nil 3655508728 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (mvars termination "mvars(B)" "nil")))
 (mvars_TCC2 0
  (mvars_TCC10-1 nil 3683842373 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (mvars termination "mvars(y)" "nil")))
 (mvars_TCC3 0
  (mvars_TCC11-1 nil 3683842373 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (mvars termination "mvars(x)" "nil")))
 (mvars_TCC4 0
  (mvars_TCC2-1 nil 3655508728 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (mvars termination "mvars(C)" "nil")))
 (mvars_TCC5 0
  (mvars_TCC3-1 nil 3655508728 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (mvars termination "mvars(x)" "nil")))
 (mvars_TCC6 0
  (mvars_TCC4-1 nil 3655508728 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (mvars termination "mvars(B)" "nil")))
 (mvars_TCC7 0
  (mvars_TCC5-1 nil 3655508728 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (mvars termination "mvars(C)" "nil")))
 (mvars_TCC8 0
  (mvars_TCC6-1 nil 3655508728 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (mvars termination "mvars(x)" "nil")))
 (mvars_TCC9 0
  (mvars_TCC7-1 nil 3655508728 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (mvars termination "mvars(y)" "nil")))
 (mvars_TCC10 0
  (mvars_TCC8-1 nil 3655508728 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (mvars termination "mvars(z)" "nil")))
 (mvars_TCC11 0
  (mvars_TCC9-1 nil 3655508728 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (mvars termination "mvars(x)" "nil")))
 (unmarkvars_TCC1 0
  (unmarkvars_TCC1-1 nil 3655508728 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil (unmarkvars termination "unmarkvars(L1)" "nil")))
 (unmarkvars_length_TCC1 0
  (unmarkvars_length_TCC1-1 nil 3700592159
   ("" (skeep* :preds? t)
    (("" (typepred "v(L1)") (("" (grind) nil nil)) nil)) nil)
   ((length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil
   (unmarkvars_length_ subtype
    "list_adt[(IExpression_adt.variable?)].cons(unmarkvar(x), v(L1))"
    "{J | list_props[(IExpression_adt.variable?)].length(J) = list_props[(IExpression_adt.variable?)].length(L)}")))
 (unmark_TCC1 0
  (unmark_TCC1-1 nil 3655508728 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (unmark termination "unmark(C)" "nil")))
 (unmark_TCC2 0
  (unmark_TCC2-1 nil 3655508728 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (unmark termination "unmark(B)" "nil")))
 (unmark_TCC3 0
  (unmark_TCC3-1 nil 3683842373 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (unmark termination "unmark(C)" "nil")))
 (unmark_pure_TCC1 0
  (unmark_pure_TCC1-1 nil 3699881944
   ("" (recursive-judgement-tcc) nil nil)
   ((pure? def-decl "bool" IL nil)) nil
   (unmark_pure_ subtype "IExpression_adt.variable(j, FALSE)"
    "(IL.pure?)")))
 (unmark_pure_TCC2 0
  (unmark_pure_TCC10-1 nil 3699881944
   ("" (recursive-judgement-tcc) nil nil)
   ((pure? def-decl "bool" IL nil)) nil
   (unmark_pure_ subtype
    "IExpression_adt.lookup(unmarkvar(x), unmarkvar(y))"
    "(IL.pure?)")))
 (unmark_pure_TCC3 0
  (unmark_pure_TCC11-1 nil 3699881944
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil))
   nil (unmark_pure_ subtype "B" "{A | IL.pure?(A)}")))
 (unmark_pure_TCC4 0
  (unmark_pure_TCC12-1 nil 3699881944
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil))
   nil
   (unmark_pure_ subtype "IExpression_adt.pop(v(B))" "(IL.pure?)")))
 (unmark_pure_TCC5 0
  (unmark_pure_TCC13-1 nil 3699881944
   ("" (recursive-judgement-tcc) nil nil)
   ((pure? def-decl "bool" IL nil)) nil
   (unmark_pure_ subtype "B" "{A | IL.pure?(A)}")))
 (unmark_pure_TCC6 0
  (unmark_pure_TCC2-1 nil 3699881944
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil))
   nil
   (unmark_pure_ subtype
    "IExpression_adt.application(f, unmarkvars(args))" "(IL.pure?)")))
 (unmark_pure_TCC7 0
  (unmark_pure_TCC3-1 nil 3699881944
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil))
   nil (unmark_pure_ subtype "B" "{A | IL.pure?(A)}")))
 (unmark_pure_TCC8 0
  (unmark_pure_TCC4-1 nil 3699881944
   ("" (recursive-judgement-tcc) nil nil)
   ((unmarkvar const-decl "(variable?)" preprocess nil)
    (pure? def-decl "bool" IL nil))
   nil (unmark_pure_ subtype "C" "{A | IL.pure?(A)}")))
 (unmark_pure_TCC9 0
  (unmark_pure_TCC5-1 nil 3699881944
   ("" (recursive-judgement-tcc) nil nil)
   ((unmarkvar const-decl "(variable?)" preprocess nil)
    (pure? def-decl "bool" IL nil))
   nil
   (unmark_pure_ subtype "IExpression_adt.letexpr(v(B), v(C))"
    "(IL.pure?)")))
 (unmark_pure_TCC10 0
  (unmark_pure_TCC6-1 nil 3699881944
   ("" (recursive-judgement-tcc) nil nil)
   ((unmarkvar const-decl "(variable?)" preprocess nil)
    (pure? def-decl "bool" IL nil))
   nil (unmark_pure_ subtype "B" "{A | IL.pure?(A)}")))
 (unmark_pure_TCC11 0
  (unmark_pure_TCC7-1 nil 3699881944
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil))
   nil (unmark_pure_ subtype "C" "{A | IL.pure?(A)}")))
 (unmark_pure_TCC12 0
  (unmark_pure_TCC8-1 nil 3699881944
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil))
   nil
   (unmark_pure_ subtype
    "IExpression_adt.ift(unmarkvar(x), v(B), v(C))" "(IL.pure?)")))
 (unmark_pure_TCC13 0
  (unmark_pure_TCC9-1 nil 3699881944
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil))
   nil
   (unmark_pure_ subtype
    "IExpression_adt.update(unmarkvar(x), unmarkvar(y), unmarkvar(z))"
    "(IL.pure?)")))
 (unmark_contextPure_TCC1 0
  (unmark_contextPure_TCC1-1 nil 3699881944
   ("" (recursive-judgement-tcc) nil nil)
   ((contextPure? def-decl "bool" IL nil)) nil
   (unmark_contextPure_ subtype "IExpression_adt.variable(j, FALSE)"
    "(IL.contextPure?)")))
 (unmark_contextPure_TCC2 0
  (unmark_contextPure_TCC10-1 nil 3699881944
   ("" (recursive-judgement-tcc) nil nil)
   ((contextPure? def-decl "bool" IL nil)) nil
   (unmark_contextPure_ subtype
    "IExpression_adt.lookup(unmarkvar(x), unmarkvar(y))"
    "(IL.contextPure?)")))
 (unmark_contextPure_TCC3 0
  (unmark_contextPure_TCC11-1 nil 3699881944
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil))
   nil (unmark_contextPure_ subtype "B" "{A | IL.contextPure?(A)}")))
 (unmark_contextPure_TCC4 0
  (unmark_contextPure_TCC12-1 nil 3699881944
   ("" (skeep* :preds? t)
    (("" (rewrite pure_contextPure +) (("" (grind) nil nil)) nil)) nil)
   ((pure_contextPure formula-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil))
   nil
   (unmark_contextPure_ subtype "IExpression_adt.pop(v(B))"
    "(IL.contextPure?)")))
 (unmark_contextPure_TCC5 0
  (unmark_contextPure_TCC13-1 nil 3699881944
   ("" (skeep* :preds? t)
    (("" (expand contextPure? +)
      (("" (replace -2)
        (("" (simplify)
          (("" (rewrite unmark_pure) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((contextPure? def-decl "bool" IL nil)
    (pure? def-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (unmark_pure recursive-judgement-axiom nil preprocess nil))
   nil (unmark_contextPure_ subtype "B" "{A | IL.contextPure?(A)}")))
 (unmark_contextPure_TCC6 0
  (unmark_contextPure_TCC2-1 nil 3699881944
   ("" (skeep* :preds? t)
    (("" (rewrite pure_contextPure +) (("" (grind) nil nil)) nil)) nil)
   ((pure_contextPure formula-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil))
   nil
   (unmark_contextPure_ subtype
    "IExpression_adt.application(f, unmarkvars(args))"
    "(IL.contextPure?)")))
 (unmark_contextPure_TCC7 0
  (unmark_contextPure_TCC3-1 nil 3699881944
   ("" (skeep* :preds? t)
    (("" (rewrite pure_contextPure +) (("" (grind) nil nil)) nil)) nil)
   ((pure_contextPure formula-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil))
   nil (unmark_contextPure_ subtype "B" "{A | IL.contextPure?(A)}")))
 (unmark_contextPure_TCC8 0
  (unmark_contextPure_TCC4-1 nil 3699881944
   ("" (skeep* :preds? t)
    (("" (expand contextPure? +)
      (("" (replace -3)
        (("" (assert)
          (("" (rewrite unmark_pure)
            (("1" (rewrite unmark_pure) (("1" (grind) nil nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((contextPure? def-decl "bool" IL nil)
    (pure? def-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (unmark_pure recursive-judgement-axiom nil preprocess nil))
   nil (unmark_contextPure_ subtype "C" "{A | IL.contextPure?(A)}")))
 (unmark_contextPure_TCC9 0
  (unmark_contextPure_TCC5-1 nil 3699881944
   ("" (recursive-judgement-tcc) (("" (use unmark_pure) nil nil)) nil)
   ((unmarkvar const-decl "(variable?)" preprocess nil)
    (contextPure? def-decl "bool" IL nil))
   nil
   (unmark_contextPure_ subtype "IExpression_adt.letexpr(v(B), v(C))"
    "(IL.contextPure?)")))
 (unmark_contextPure_TCC10 0
  (unmark_contextPure_TCC6-1 nil 3699881944
   ("" (recursive-judgement-tcc)
    (("" (use pure_contextPure) (("" (grind) nil nil)) nil)) nil)
   ((unmarkvar const-decl "(variable?)" preprocess nil)
    (contextPure? def-decl "bool" IL nil))
   nil (unmark_contextPure_ subtype "B" "{A | IL.contextPure?(A)}")))
 (unmark_contextPure_TCC11 0
  (unmark_contextPure_TCC7-1 nil 3699881944
   ("" (recursive-judgement-tcc)
    (("" (use pure_contextPure) (("" (grind) nil nil)) nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil))
   nil (unmark_contextPure_ subtype "C" "{A | IL.contextPure?(A)}")))
 (unmark_contextPure_TCC12 0
  (unmark_contextPure_TCC8-1 nil 3699881944
   ("" (recursive-judgement-tcc)
    (("1" (use unmark_pure) nil nil) ("2" (use unmark_pure) nil nil))
    nil)
   ((contextPure? def-decl "bool" IL nil)) nil
   (unmark_contextPure_ subtype
    "IExpression_adt.ift(unmarkvar(x), v(B), v(C))"
    "(IL.contextPure?)")))
 (unmark_contextPure_TCC13 0
  (unmark_contextPure_TCC9-1 nil 3699881944
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil))
   nil
   (unmark_contextPure_ subtype
    "IExpression_adt.update(unmarkvar(x), unmarkvar(y), unmarkvar(z))"
    "(IL.contextPure?)")))
 (unmark_refs 0
  (unmark_refs-1 nil 3699882384
   ("" (induct A)
    (("1" (grind-with-ext) nil nil) ("2" (grind-with-ext) nil nil)
     ("3" (grind-with-ext) nil nil) ("4" (grind-with-ext) nil nil)
     ("5" (grind-with-ext) nil nil) ("6" (grind-with-ext) nil nil)
     ("7" (grind-with-ext) nil nil) ("8" (grind-with-ext) nil nil)
     ("9" (grind-with-ext) nil nil) ("10" (grind-with-ext) nil nil)
     ("11" (grind-with-ext) nil nil) ("12" (grind-with-ext) nil nil)
     ("13" (grind-with-ext) nil nil))
    nil)
   ((release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (update adt-constructor-decl
     "[[(variable?), (variable?), (variable?)] -> (update?)]"
     IExpression_adt nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (unmarkvars_length rec-application-judgement
     "{J | length(J) = length(L)}" preprocess nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (unmarkvars def-decl "list[(variable?)]" preprocess nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FALSE const-decl "bool" booleans nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (unmark def-decl "IExpression" preprocess nil)
    (refs def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (unmarkvars_markvars 0
  (unmarkvars_markvars-1 nil 3700834744
   ("" (induct L) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
   ((in_varlist const-decl "finite_set[nat]" IL nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (markvar const-decl "(variable?)" preprocess nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (unmarkvars_length rec-application-judgement
     "{J | length(J) = length(L)}" preprocess nil)
    (injective? const-decl "bool" functions nil)
    (list_induction formula-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil)
    (length def-decl "nat" list_props nil)
    (unmarkvars def-decl "list[(variable?)]" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (unmarkvars_nth_TCC1 0
  (unmarkvars_nth_TCC1-1 nil 3702820476 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (unmarkvars_length rec-application-judgement
     "{J | length(J) = length(L)}" preprocess nil))
   nil
   (unmarkvars_nth subtype "i"
    "below[length[(IExpression_adt.variable?)](unmarkvars(L))]")))
 (unmarkvars_nth 0
  (unmarkvars_nth-1 nil 3702820477
   ("" (induct L)
    (("1" (grind) nil nil)
     ("2" (skeep* :preds? t)
      (("2" (case-replace "i = 0")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil)
     ("3" (grind) nil nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (unmarkvars_length rec-application-judgement
     "{J | length(J) = length(L)}" preprocess nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (unmarkvars def-decl "list[(variable?)]" preprocess nil))
   shostak))
 (unmark_release_set 0
  (unmark_release_set-1 nil 3700834662
   ("" (induct X :name finite_set_induction)
    (("1" (grind) nil nil)
     ("2" (skeep*)
      (("2" (expand release_set 1)
        (("2" (assert) (("2" (lift-if) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (choose const-decl "(p)" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (remove const-decl "set" sets nil)
    (/= const-decl "boolean" notequal nil)
    (nonempty? const-decl "bool" sets nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_set_induction formula-decl nil finite_set_theorems nil)
    (release_set def-decl "IExpression" preprocess nil)
    (unmark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (unmark_mark 0
  (unmark_mark-1 nil 3700834299
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (skeep*)
      (("4" (expand mark 1)
        (("4" (expand unmark 1)
          (("4" (decompose-equality)
            (("4" (use unmarkvars_markvars) nil nil)) nil))
          nil))
        nil))
      nil)
     ("5" (grind) nil nil)
     ("6" (skeep*)
      (("6" (expand mark 1)
        (("6" (expand unmark 1)
          (("6" (decompose-equality)
            (("1" (grind-with-ext) nil nil)
             ("2" (use unmark_release_set) (("2" (grind) nil nil)) nil)
             ("3" (use unmark_release_set) (("3" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (grind-with-ext) nil nil) ("8" (grind-with-ext) nil nil)
     ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil))
    nil)
   ((IExpression_lookup_extensionality formula-decl nil IExpression_adt
     nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (add const-decl "(nonempty?)" sets nil)
    (IExpression_update_extensionality formula-decl nil IExpression_adt
     nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (update adt-constructor-decl
     "[[(variable?), (variable?), (variable?)] -> (update?)]"
     IExpression_adt nil)
    (unmark_release_set formula-decl nil preprocess nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (IExpression_variable_extensionality formula-decl nil
     IExpression_adt nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (FALSE const-decl "bool" booleans nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression_ift_extensionality formula-decl nil IExpression_adt
     nil)
    (difference const-decl "set" sets nil)
    (release_set def-decl "IExpression" preprocess nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (bump const-decl "finite_set[nat]" IL nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (N!1 skolem-const-decl "nat" preprocess nil)
    (X!1 skolem-const-decl "finite_set[nat]" preprocess nil)
    (union const-decl "set" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (unmarkvars_markvars formula-decl nil preprocess nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (IExpression_application_extensionality formula-decl nil
     IExpression_adt nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil)
    (length def-decl "nat" list_props nil)
    (unmarkvars def-decl "list[(variable?)]" preprocess nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (unmarkvars_length rec-application-judgement
     "{J | length(J) = length(L)}" preprocess nil)
    (markv const-decl "(variable?)" preprocess nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (mark def-decl "IExpression" preprocess nil)
    (unmark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (unmark_atom 0
  (unmark_atom-1 nil 3701451146 ("" (induct-and-simplify A) nil nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (atom? const-decl "bool" IL nil)
    (unmark def-decl "IExpression" preprocess nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil))
   nil (unmark_atom subtype "unmark(A)" "(IL.atom?)")))
 (unmark_value 0
  (unmark_value-1 nil 3706300454
   ("" (skeep* :preds? t) (("" (grind) nil nil)) nil)
   ((value? const-decl "bool" IL nil)
    (unmark def-decl "IExpression" preprocess nil))
   nil (unmark_value subtype "unmark(A)" "(IL.value?)")))
 (unmark_TCC4 0
  (unmark_TCC4-1 nil 3699881944 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IContext])" IL nil)) nil
   (unmark termination "unmark(K1)" "nil")))
 (unmark_TCC5 0
  (unmark_TCC5-1 nil 3699881944 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IContext])" IL nil)) nil
   (unmark termination "unmark(K1)" "nil")))
 (unmark_fill 0
  (unmark_fill-1 nil 3701524673 ("" (induct-and-simplify K) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (unmark def-decl "IExpression" preprocess nil)
    (fill def-decl "IExpression" IL nil)
    (unmark def-decl "IContext" preprocess nil)
    (IContext_induction formula-decl nil IL nil))
   shostak))
 (unmark_cpure_TCC1 0
  (unmark_cpure_TCC1-1 nil 3701526124
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil))
   nil (unmark_cpure_ subtype "K1" "(IL.cpure?)")))
 (unmark_cpure_TCC2 0
  (unmark_cpure_TCC2-1 nil 3701526124
   ("" (skeep* :preds? t)
    (("" (expand cpure? +)
      (("" (use unmark_pure) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((cpure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (B skolem-const-decl "IExpression" preprocess nil)
    (unmark_pure recursive-judgement-axiom nil preprocess nil))
   nil
   (unmark_cpure_ subtype "IL.letc(v(K1), unmark(B))" "(IL.cpure?)")))
 (unmark_cpure_TCC3 0
  (unmark_cpure_TCC3-1 nil 3701526124
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil))
   nil (unmark_cpure_ subtype "K1" "(IL.cpure?)")))
 (unmark_cpure_TCC4 0
  (unmark_cpure_TCC4-1 nil 3701526124
   ("" (recursive-judgement-tcc) nil nil)
   ((cpure? def-decl "bool" IL nil)) nil
   (unmark_cpure_ subtype "IL.popc(v(K1))" "(IL.cpure?)")))
 (unmark_cpure_TCC5 0
  (unmark_cpure_TCC5-1 nil 3701526124
   ("" (recursive-judgement-tcc) nil nil)
   ((cpure? def-decl "bool" IL nil)) nil
   (unmark_cpure_ subtype "IL.hole" "(IL.cpure?)")))
 (unmark_vars 0
  (unmark_vars-1 nil 3701526124
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (skeep)
      (("4" (skeep)
        (("4" (expand unmark -2)
          (("4" (expand vars (1 -2))
            (("4" (delete -1)
              (("4" (generalize application2_var L)
                (("4" (induct-and-simplify L) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (grind) nil nil) ("6" (grind) nil nil) ("7" (grind) nil nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil))
    nil)
   ((add const-decl "(nonempty?)" sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (unmarkvars_length rec-application-judgement
     "{J | length(J) = length(L)}" preprocess nil)
    (some adt-def-decl "boolean" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (unmarkvars def-decl "list[(variable?)]" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (unmark def-decl "IExpression" preprocess nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (unmark_vars_ctx 0
  (unmark_vars_ctx-1 nil 3701526296
   ("" (induct K)
    (("1" (grind) nil nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (expand unmark -2)
          (("2" (expand vars (1 -2))
            (("2" (lemma unmark_vars)
              (("2" (inst -1 letc2_var "i+1") (("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (grind) nil nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (unmark_vars formula-decl nil preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (union const-decl "set" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (emptyset const-decl "set" sets nil)
    (IContext_induction formula-decl nil IL nil)
    (unmark def-decl "IContext" preprocess nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   shostak))
 (unmark_popDepth 0
  (unmark_popDepth-1 nil 3701526394
   ("" (induct-and-simplify A) nil nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (popDepth def-decl "nat" IL nil)
    (unmark def-decl "IExpression" preprocess nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (unmarkvars_length rec-application-judgement
     "{J | length(J) = length(L)}" preprocess nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (unmark_popDepth_ctx 0
  (unmark_popDepth_ctx-1 nil 3701526403
   ("" (induct-and-simplify K) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (popDepth def-decl "nat" IL nil)
    (unmark def-decl "IContext" preprocess nil)
    (IContext_induction formula-decl nil IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (cvars_pure 0
  (cvars_pure-1 nil 3699648214
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil)
     ("5" (grind)
      (("5" (rewrite purePopDepth)
        (("5" (expand bumpn)
          (("5" (expand union)
            (("5" (expand member) (("5" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil)
     ("6" (grind) nil nil) ("7" (grind) nil nil) ("8" (grind) nil nil)
     ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (skeep* :preds? t)
      (("13" (expand cvars 1)
        (("13" (expand pure? -4)
          (("13" (rewrite purePopDepth) (("13" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((nonempty_singleton_finite application-judgement
     "non_empty_finite_set[T]" countability "sets_aux/")
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (bumpn const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (purePopDepth formula-decl nil IL nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (cvars_fill 0
  (cvars_fill-1 nil 3699294594
   ("" (induct "K")
    (("1" (grind) nil nil)
     ("2" (skeep*)
      (("2" (expand fill 1)
        (("2" (expand cvars 1)
          (("2" (expand union 1)
            (("2" (expand bumpn 1)
              (("2" (expand drop 1)
                (("2" (expand member 1)
                  (("2" (rewrite popdepth_fill)
                    (("2" (inst? -1)
                      (("2" (rewrite -1)
                        (("2" (expand bumpn 1) (("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skeep*) (("3" (grind) nil nil)) nil))
    nil)
   ((int_plus_int_is_int application-judgement "int" integers nil)
    (member const-decl "bool" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (popdepth_fill formula-decl nil IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (union const-decl "set" sets nil)
    (emptyset const-decl "set" sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IContext_induction formula-decl nil IL nil)
    (popDepth def-decl "nat" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (fill def-decl "IExpression" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   shostak))
 (cvars_vars 0
  (cvars_vars-1 nil 3700225808 ("" (induct-and-simplify A) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (singleton const-decl "(singleton?)" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[T]" countability "sets_aux/")
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/"))
   shostak))
 (cvars_vars_ctx 0
  (cvars_vars_ctx-1 nil 3700234765 ("" (induct-and-simplify K) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (IContext_induction formula-decl nil IL nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil))
   shostak))
 (cvars_release_set 0
  (cvars_release_set-1 nil 3703337145
   ("" (induct X :name finite_set_induction)
    (("1" (skeep)
      (("1" (decompose-equality) (("1" (grind) nil nil)) nil)) nil)
     ("2" (skeep*)
      (("2" (expand release_set +)
        (("2" (expand nonempty?)
          (("2" (assert)
            (("2" (inst?)
              (("2" (expand popDepth -)
                (("2" (expand cvars -1 2)
                  (("2" (grind-with-ext) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nonempty? const-decl "bool" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (choose const-decl "(p)" sets nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (add const-decl "(nonempty?)" sets nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (remove const-decl "set" sets nil)
    (/= const-decl "boolean" notequal nil)
    (nonempty_finite_union1 application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_set_induction formula-decl nil finite_set_theorems nil)
    (popDepth def-decl "nat" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (release_set def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (mark_fill 0
  (mark_fill-1 nil 3656268737
   ("" (induct "K")
    (("1" (grind)
      (("1"
        (apply (then (rewrite "union_commutative")
                (rewrite "union_empty") (rewrite "bumpn_zero")))
        nil nil)
       ("2"
        (apply (then (rewrite "union_commutative")
                (rewrite "union_empty") (rewrite "bumpn_zero")))
        nil nil)
       ("3"
        (apply (then (rewrite "union_commutative")
                (rewrite "union_empty") (rewrite "bumpn_zero")))
        nil nil))
      nil)
     ("2" (lazy-grind)
      (("1" (hide -)
        (("1" (rewrite "union_associative")
          (("1" (rewrite "bumpn_union") nil nil)) nil))
        nil)
       ("2" (hide -)
        (("2" (rewrite "union_associative")
          (("2" (rewrite "bumpn_union") nil nil)) nil))
        nil)
       ("3" (hide -)
        (("3" (rewrite "union_associative")
          (("3" (rewrite "bumpn_union") nil nil)) nil))
        nil)
       ("4" (lazy-grind :exclude "bump")
        (("4" (hide -)
          (("4" (rewrite "union_associative")
            (("4" (rewrite "bumpn_union") nil nil)) nil))
          nil))
        nil)
       ("5" (hide -)
        (("5" (rewrite "union_associative")
          (("5" (rewrite "bumpn_union") nil nil)) nil))
        nil)
       ("6" (hide -)
        (("6" (rewrite "union_associative")
          (("6" (rewrite "bumpn_union") nil nil)) nil))
        nil))
      nil)
     ("3" (lazy-grind :exclude "bump")
      (("1" (rewrite "bumpn_bump") nil nil)
       ("2" (lazy-grind :exclude "bump")
        (("2" (rewrite "bumpn_bump") nil nil)) nil)
       ("3" (lazy-grind :exclude "bump")
        (("3" (rewrite "bumpn_bump") nil nil)) nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (N!1 skolem-const-decl "nat" preprocess nil)
    (X!1 skolem-const-decl "finite_set[nat]" preprocess nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (bumpn_bump formula-decl nil IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (N!1 skolem-const-decl "nat" preprocess nil)
    (X!1 skolem-const-decl "finite_set[nat]" preprocess nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (N!1 skolem-const-decl "nat" preprocess nil)
    (union_associative formula-decl nil sets_lemmas nil)
    (bumpn_union formula-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (N!1 skolem-const-decl "nat" preprocess nil)
    (X!1 skolem-const-decl "finite_set[nat]" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (union_commutative formula-decl nil sets_lemmas nil)
    (bumpn_zero formula-decl nil IL nil)
    (union_empty formula-decl nil sets_lemmas nil)
    (IContext_induction formula-decl nil IL nil)
    (popDepth def-decl "nat" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (union const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (fill def-decl "IExpression" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/"))
   shostak))
 (arm_fill 0
  (arm_fill-1 nil 3701182175 ("" (induct-and-simplify K) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (fill def-decl "IExpression" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (armc? def-decl "bool" preprocess nil)
    (IContext_induction formula-decl nil IL nil))
   shostak))
 (wellformed_release_set 0
  (wellformed_release_set-1 nil 3656869616
   ("" (induct "X" :name "finite_set_induction")
    (("1" (grind) nil nil)
     ("2" (skeep*)
      (("2" (expand "release_set" +)
        (("2" (ground)
          (("2" (inst?)
            (("2" (ground)
              (("1" (grind) nil nil) ("2" (lazy-grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (remove const-decl "set" sets nil)
    (/= const-decl "boolean" notequal nil)
    (intersection2_preserves_bounded application-judgement
     "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], boolean](<=)))"
     countability "sets_aux/")
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (nonempty? const-decl "bool" sets nil)
    (choose const-decl "(p)" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_intersection2 application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (finite_set_induction formula-decl nil finite_set_theorems nil)
    (release_set def-decl "IExpression" preprocess nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (disjoint? const-decl "bool" sets nil)
    (wellformed? def-decl "bool" preprocess nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (wellformed_mark 0
  (wellformed_mark-1 nil 3656868911
   (""
    (induct-and-simplify "A" :rewrites
     ("vars_mark" "wellformed_release_set"))
    (("1" (rewrite "wellformed_release_set")
      (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil)
     ("2" (rewrite "wellformed_release_set")
      (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)
     ("3" (grind) nil nil))
    nil)
   ((markv const-decl "(variable?)" preprocess nil)
    (wellformed_release_set formula-decl nil preprocess nil)
    (finite_intersection2 application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (intersection const-decl "set" sets nil)
    (disjoint? const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (difference const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (vars_mark formula-decl nil preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (wellformed? def-decl "bool" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (IExpression_induction formula-decl nil IExpression_adt nil))
   shostak))
 (mvars_release_set 0
  (mvars_release_set-1 nil 3683210798
   ("" (induct "X" 1 "finite_set_induction")
    (("1" (grind) nil nil)
     ("2" (skeep*)
      (("2" (expand "release_set" +)
        (("2" (lift-if)
          (("2" (ground)
            (("1" (grind) nil nil)
             ("2" (inst?)
              (("2" (replace -2 :hide? t)
                (("2" (rewrite "mvars")
                  (("2" (iff +) (("2" (grind) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (choose const-decl "(p)" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (remove const-decl "set" sets nil)
    (/= const-decl "boolean" notequal nil)
    (nonempty? const-decl "bool" sets nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_set_induction formula-decl nil finite_set_theorems nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (release_set def-decl "IExpression" preprocess nil)
    (mvars def-decl "bool" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (mvars_mark 0
  (mvars_mark-1 nil 3683170978
   ("" (induct "A")
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (skeep*)
      (("4" (rewrite "mark")
        (("4" (rewrite "mvars")
          (("4" (rewrite "some_nth")
            (("4" (iff)
              (("4" (ground)
                (("1" (skeep)
                  (("1" (use "markvars_index")
                    (("1" (rewrite "vars")
                      (("1" (rewrite "in_varlist")
                        (("1" (rewrite "some_nth")
                          (("1" (inst?)
                            (("1" (rewrite "every_nth")
                              (("1"
                                (inst?)
                                (("1"
                                  (inst?)
                                  (("1"
                                    (inst - "i")
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (skeep)
                  (("2" (rewrite "every_nth")
                    (("2" (inst - "i_1")
                      (("2" (inst?)
                        (("2" (use "markvars_index")
                          (("2" (grind)
                            (("2"
                              (typepred "nth(application2_var, i_1)")
                              (("2"
                                (grind)
                                (("2"
                                  (grind)
                                  (("2"
                                    (use markvars_markX)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (rewrite "vars")
                  (("3" (expand "in_varlist")
                    (("3" (rewrite "some_nth")
                      (("3" (skeep)
                        (("3" (use "markvars_mark")
                          (("3" (grind :if-match nil)
                            (("3" (inst?)
                              (("3"
                                (apply-extensionality)
                                (("3" (use "markvars_index") nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep*)
      (("5" (rewrite "mark")
        (("5" (rewrite "mvars")
          (("5" (inst?)
            (("5" (inst?)
              (("5" (expand "vars" + 2)
                (("5" (rewrite "union" +)
                  (("5" (iff +)
                    (("5" (ground)
                      (("1" (grind) nil nil) ("2" (grind) nil nil)
                       ("3" (grind) nil nil) ("4" (grind) nil nil)
                       ("5" (grind) nil nil) ("6" (grind) nil nil)
                       ("7" (grind) nil nil) ("8" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep*)
      (("6" (rewrite "mark")
        (("6" (rewrite "mvars")
          (("6" (rewrite "mvars_release_set")
            (("6" (rewrite "mvars_release_set")
              (("6"
                (inst -
                 "union(vars(ift2_var), union(vars(ift3_var), X))" "i")
                (("6" (inst?)
                  (("6" (inst?)
                    (("6" (replace*)
                      (("6" (rewrite "mark")
                        (("6" (replace -1)
                          (("6" (hide -)
                            (("6" (iff)
                              (("6"
                                (ground)
                                (("1" (grind) nil nil)
                                 ("2" (grind) nil nil)
                                 ("3" (grind) nil nil)
                                 ("4" (grind) nil nil)
                                 ("5" (grind) nil nil)
                                 ("6" (grind) nil nil)
                                 ("7" (grind) nil nil)
                                 ("8" (grind) nil nil)
                                 ("9" (grind) nil nil)
                                 ("10" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skeep*)
      (("7" (rewrite "mark")
        (("7" (expand "mark" -)
          (("7" (rewrite "mvars" +)
            (("7" (inst?)
              (("7" (inst?) (("7" (inst?) (("7" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (skeep*)
      (("8" (rewrite "mark")
        (("8" (rewrite "mvars")
          (("8" (expand "mark")
            (("8" (inst?) (("8" (inst?) (("8" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (lazy-grind) nil nil) ("12" (grind) nil nil)
     ("13" (skeep*)
      (("13" (rewrite "mark")
        (("13" (rewrite "mvars")
          (("13" (inst - "emptyset" "i")
            (("13" (inst?) (("13" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((N!1 skolem-const-decl "nat" preprocess nil)
    (N!1 skolem-const-decl "nat" preprocess nil)
    (X!1 skolem-const-decl "finite_set[nat]" preprocess nil)
    (N!1 skolem-const-decl "nat" preprocess nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (nonempty? const-decl "bool" sets nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (update adt-constructor-decl
     "[[(variable?), (variable?), (variable?)] -> (update?)]"
     IExpression_adt nil)
    (difference const-decl "set" sets nil)
    (release_set def-decl "IExpression" preprocess nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (mvars_release_set formula-decl nil preprocess nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (union const-decl "set" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (member const-decl "bool" sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil)
    (length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (markvars_mark formula-decl nil preprocess nil)
    (IExpression_variable_extensionality formula-decl nil
     IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (markvars_markX formula-decl nil preprocess nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (every_nth formula-decl nil list_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[T]" countability "sets_aux/")
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (markvars_index formula-decl nil preprocess nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (emptyset const-decl "set" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (singleton const-decl "(singleton?)" sets nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (mark def-decl "IExpression" preprocess nil)
    (mvars def-decl "bool" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (pure_release_set 0
  (pure_release_set-1 nil 3693353022
   ("" (induct "X" :name "finite_set_induction")
    (("1" (grind) nil nil)
     ("2" (skeep*)
      (("2" (expand "release_set" +)
        (("2" (grind :if-match nil)
          (("1" (inst?) (("1" (grind) nil nil)) nil)
           ("2" (inst?) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((remove const-decl "set" sets nil)
    (/= const-decl "boolean" notequal nil)
    (nonempty? const-decl "bool" sets nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (choose const-decl "(p)" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_set_induction formula-decl nil finite_set_theorems nil)
    (release_set def-decl "IExpression" preprocess nil)
    (pure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (contextPure_release_set 0
  (contextPure_release_set-1 nil 3703339097
   ("" (induct X :name finite_set_induction)
    (("1" (grind) nil nil)
     ("2" (skeep* :preds? t)
      (("2" (expand nonempty?)
        (("2" (assert)
          (("2" (expand release_set +)
            (("2" (inst?) (("2" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (choose const-decl "(p)" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (injective? const-decl "bool" functions nil)
    (/= const-decl "boolean" notequal nil)
    (remove const-decl "set" sets nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (nonempty? const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_set_induction formula-decl nil finite_set_theorems nil)
    (release_set def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (popDepth_release_set 0
  (popDepth_release_set-1 nil 3703339151
   ("" (induct X :name finite_set_induction)
    (("1" (grind) nil nil)
     ("2" (skeep* :preds? t)
      (("2" (expand nonempty?)
        (("2" (assert)
          (("2" (expand release_set +)
            (("2" (inst?) (("2" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (choose const-decl "(p)" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (remove const-decl "set" sets nil)
    (/= const-decl "boolean" notequal nil)
    (injective? const-decl "bool" functions nil)
    (nonempty? const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_set_induction formula-decl nil finite_set_theorems nil)
    (release_set def-decl "IExpression" preprocess nil)
    (popDepth def-decl "nat" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (pure_mark 0
  (pure_mark-1 nil 3693352668
   ("" (induct-and-simplify "A" :rewrites "pure_release_set") nil nil)
   ((nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (pure_release_set formula-decl nil preprocess nil)
    (empty? const-decl "bool" sets nil)
    (difference const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (mark def-decl "IExpression" preprocess nil)
    (pure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (fill_mark_inj 0
  (fill_mark_inj-1 nil 3699721429
   ("" (induct "K")
    (("1" (grind) nil nil)
     ("2" (skeep*)
      (("2" (expand markc -2)
        (("2" (expand fill -2)
          (("2" (decompose-equality -2)
            (("2" (inst? -3)
              (("2" (ground)
                (("2" (expand markc 1)
                  (("2" (replace -4 :dir RL)
                    (("2" (replace -1 :dir RL) (("2" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skeep*)
      (("3" (expand markc -2)
        (("3" (expand fill -2)
          (("3" (inst? -1)
            (("3" (decompose-equality -2)
              (("3" (ground)
                (("3" (expand markc 1) (("3" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt
     nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (body adt-accessor-decl "[(letexpr?) -> IExpression]"
          IExpression_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext_induction formula-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (mark def-decl "IExpression" preprocess nil)
    (markc def-decl "IContext" preprocess nil)
    (fill def-decl "IExpression" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   shostak))
 (contextPure_mark 0
  (contextPure_mark-1 nil 3702755994
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil)
     ("5" (skeep* :preds? t)
      (("5" (expand mark +)
        (("5" (expand contextPure? +)
          (("5" (expand pure? 1 2)
            (("5" (rewrite pure_mark) (("5" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep* :preds? t)
      (("6" (expand mark +)
        (("6" (expand contextPure? +)
          (("6" (rewrite pure_release_set)
            (("6" (rewrite pure_release_set)
              (("6" (rewrite pure_mark)
                (("6" (rewrite pure_mark) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand mark +)
        (("7" (expand contextPure? +) (("7" (propax) nil nil)) nil))
        nil))
      nil)
     ("8" (skeep* :preds? t)
      (("8" (expand mark +)
        (("8" (expand contextPure? +) (("8" (propax) nil nil)) nil))
        nil))
      nil)
     ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil))
    nil)
   ((member const-decl "bool" sets nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (difference const-decl "set" sets nil)
    (pure_release_set formula-decl nil preprocess nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (bump const-decl "finite_set[nat]" IL nil)
    (pure_mark formula-decl nil preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (injective? const-decl "bool" functions nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil) (pure? def-decl "bool" IL nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (markv const-decl "(variable?)" preprocess nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (markc_popDepth 0
  (markc_popDepth-1 nil 3702817944
   ("" (induct K)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil))
    nil)
   ((bumpn const-decl "finite_set[nat]" IL nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (union const-decl "set" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (injective? const-decl "bool" functions nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (IContext_induction formula-decl nil IL nil)
    (markc def-decl "IContext" preprocess nil)
    (popDepth def-decl "nat" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   shostak))
 (cvars_mark 0
  (cvars_mark-1 nil 3702756177
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (skeep* :preds? t)
      (("4" (rewrite cvars_pure)
        (("1" (rewrite cvars_pure)
          (("1" (rewrite vars_mark) nil nil) ("2" (grind) nil nil))
          nil)
         ("2" (grind) nil nil))
        nil))
      nil)
     ("5" (skeep* :preds? t)
      (("5" (expand mark +)
        (("5" (expand cvars +)
          (("5" (rewrite -2)
            (("5" (expand vars 1 3)
              (("5" (rewrite vars_mark)
                (("5" (rewrite popDepth_mark)
                  (("5" (expand drop)
                    (("5" (expand add)
                      (("5" (expand member) (("5" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep* :preds? t)
      (("6"
        (case-replace
         "cvars(mark(X)(ift(ift1_var, ift2_var, ift3_var))) = vars(mark(X)(ift(ift1_var, ift2_var, ift3_var)))")
        (("1" (expand cvars +) (("1" (rewrite vars_mark) nil nil)) nil)
         ("2" (grind) nil nil))
        nil))
      nil)
     ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)
     ("10" (grind) nil nil) ("11" (grind) nil nil)
     ("12" (grind) nil nil)
     ("13" (skeep* :preds? t)
      (("13" (expand mark +)
        (("13" (expand cvars +)
          (("13" (rewrite popDepth_mark)
            (("13" (expand markv)
              (("13" (assert) (("13" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((X skolem-const-decl "finite_set[nat]" preprocess nil)
    (N!1 skolem-const-decl "nat" preprocess nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (injective? const-decl "bool" functions nil)
    (difference const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (popDepth_mark formula-decl nil preprocess nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (vars_mark formula-decl nil preprocess nil)
    (pure? def-decl "bool" IL nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (cvars_pure formula-decl nil preprocess nil)
    (markv const-decl "(variable?)" preprocess nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (cvars_mark_ctx 0
  (cvars_mark_ctx-1 nil 3702817591
   ("" (induct K)
    (("1" (grind) nil nil)
     ("2" (skeep* :preds? t)
      (("2" (expand markc +)
        (("2" (expand cvars +)
          (("2" (expand vars + 4)
            (("2" (expand add +)
              (("2" (expand drop +)
                (("2" (expand member +)
                  (("2" (rewrite vars_mark)
                    (("2" (rewrite markc_popDepth)
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (grind) nil nil))
    nil)
   ((bumpn const-decl "finite_set[nat]" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (union const-decl "set" sets nil)
    (markc_popDepth formula-decl nil preprocess nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (vars_mark formula-decl nil preprocess nil)
    (IExpression type-decl nil IExpression_adt nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (IContext_induction formula-decl nil IL nil)
    (markc def-decl "IContext" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   shostak))
 (unmark_cvars 0
  (unmark_cvars-1 nil 3702818019
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (skeep* :preds? t)
      (("4" (rewrite cvars_pure)
        (("1" (rewrite cvars_pure)
          (("1" (lemma unmark_vars)
            (("1" (inst? :where +) (("1" (assert) nil nil)) nil)) nil)
           ("2" (grind) nil nil))
          nil)
         ("2" (grind) nil nil))
        nil))
      nil)
     ("5" (skeep* :preds? t)
      (("5" (expand unmark -4)
        (("5" (expand cvars +)
          (("5" (expand cvars -4)
            (("5" (expand union)
              (("5" (expand bumpn)
                (("5" (expand drop)
                  (("5" (expand member)
                    (("5" (flatten)
                      (("5" (split)
                        (("1" (grind) nil nil)
                         ("2" (rewrite unmark_popDepth)
                          (("2" (lemma unmark_vars)
                            (("2" (inst? :where +)
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep* :preds? t)
      (("6"
        (case-replace
         "cvars(unmark(ift(ift1_var, ift2_var, ift3_var)))(i) = vars(unmark(ift(ift1_var, ift2_var, ift3_var)))(i)")
        (("1" (expand cvars +)
          (("1" (lemma unmark_vars)
            (("1" (inst? :where +) (("1" (assert) nil nil)) nil)) nil))
          nil)
         ("2" (expand unmark)
          (("2" (expand cvars) (("2" (propax) nil nil)) nil)) nil))
        nil))
      nil)
     ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)
     ("10" (grind) nil nil) ("11" (grind) nil nil)
     ("12" (grind) nil nil) ("13" (grind) nil nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (add const-decl "(nonempty?)" sets nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (union const-decl "set" sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (unmark_popDepth formula-decl nil preprocess nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (letexpr1_var skolem-const-decl "IExpression" preprocess nil)
    (i skolem-const-decl "nat" preprocess nil)
    (member const-decl "bool" sets nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (unmarkvars_length rec-application-judgement
     "{J | length(J) = length(L)}" preprocess nil)
    (unmark_vars formula-decl nil preprocess nil)
    (pure? def-decl "bool" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (cvars_pure formula-decl nil preprocess nil)
    (emptyset const-decl "set" sets nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (singleton const-decl "(singleton?)" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (unmark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (unmark_cvars_ctx 0
  (unmark_cvars_ctx-1 nil 3702818522
   ("" (induct K)
    (("1" (grind) nil nil)
     ("2" (skeep* :preds? t)
      (("2" (expand unmark -3)
        (("2" (expand cvars -3)
          (("2" (expand cvars 1)
            (("2" (expand union)
              (("2" (expand bumpn)
                (("2" (expand drop)
                  (("2" (expand member)
                    (("2" (flatten)
                      (("2" (split)
                        (("1" (grind) nil nil)
                         ("2" (rewrite unmark_popDepth_ctx)
                          (("2" (lemma unmark_vars)
                            (("2" (inst? :where +)
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (grind) nil nil))
    nil)
   ((union const-decl "set" sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (unmark_popDepth_ctx formula-decl nil preprocess nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (letc1_var skolem-const-decl "IContext" preprocess nil)
    (i skolem-const-decl "nat" preprocess nil)
    (IExpression type-decl nil IExpression_adt nil)
    (unmark_vars formula-decl nil preprocess nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (member const-decl "bool" sets nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (emptyset const-decl "set" sets nil)
    (IContext_induction formula-decl nil IL nil)
    (unmark def-decl "IContext" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   shostak))
 (unmark_unmarkvar 0
  (unmark_unmarkvar-1 nil 3702819577 ("" (grind-with-ext) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IExpression_variable_extensionality formula-decl nil
     IExpression_adt nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (FALSE const-decl "bool" booleans nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (unmark def-decl "IExpression" preprocess nil)
    (unmarkvar const-decl "(variable?)" preprocess nil))
   shostak)))

