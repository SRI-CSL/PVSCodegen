(iareduction
 (defs_subtype 0
  (defs_subtype-1 nil 3706540559
   ("" (skeep* :preds? t)
    (("" (typepred "x`seq(x1)`body")
      (("" (assert)
        (("" (skeep) (("" (inst?) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((Defs type-eq-decl nil iareduction nil)
    (Definition type-eq-decl nil iareduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (unmark_pure rec-application-judgement "(pure?)" preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil (defs_subtype subtype "x" "rreduction.Defs")))
 (iapply_nstack_TCC1 0
  (iapply_nstack_TCC1-1 nil 3706450317 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (Stack type-eq-decl nil IL nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil))
   nil
   (iapply_nstack subtype "(S, cnt)"
    "{((S1: Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(S1))), ((ncnt: [i: (dom) -> {j | j = rreduction.refcount(dom, str, S1, A)(i)}])) | S1`length = arity + S`length}")))
 (iapply_nstack_TCC2 0
  (iapply_nstack_TCC2-1 nil 3706450317
   ("" (skeep* :preds? t) (("" (grind) nil nil)) nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (some adt-def-decl "boolean" list_adt nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (value? const-decl "bool" IL nil)
    (every adt-def-decl "boolean" list_adt nil)
    (length def-decl "nat" list_props nil))
   nil
   (iapply_nstack subtype "args"
    "(cons?[(IExpression_adt.variable?)])")))
 (iapply_nstack_TCC3 0
  (iapply_nstack_TCC7-1 nil 3706450317 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack subtype
    "list_adt[(IExpression_adt.variable?)].cdr(args)"
    "{args_1: list[(IExpression_adt.variable?)] | list_props[(IExpression_adt.variable?)].length(args_1) = arity - 1 AND FORALL i: IL.in_varlist(args_1)(i) IMPLIES i < IL.push(u, S WITH [`seq(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil])`length}")))
 (iapply_nstack_TCC4 0
  (iapply_nstack_TCC4-1 nil 3706473878 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack subtype
    "y WITH [`index := IExpression_adt.index(y) + 1]"
    "(IExpression_adt.variable?)")))
 (iapply_nstack_TCC5 0
  (iapply_nstack_TCC5-1 nil 3706473878
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (rewrite map_length)
        (("1" (expand length 1 2)
          (("1" (lift-if)
            (("1" (split) (("1" (grind) nil nil) ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skeep)
        (("2" (expand in_varlist)
          (("2" (inst -8 "i-1")
            (("1" (rewrite some_map)
              (("1" (expand o)
                (("1" (rewrite some_nth)
                  (("1" (rewrite some_nth)
                    (("1" (split)
                      (("1" (grind) nil nil)
                       ("2" (skeep)
                        (("2" (inst 1 "i_1+1")
                          (("1" (grind) nil nil)
                           ("2" (expand length 1)
                            (("2" (lift-if) (("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (map_length formula-decl nil more_map_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (TRUE const-decl "bool" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (some_map formula-decl nil finseq_theorems nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (arity skolem-const-decl "nat" iareduction nil)
    (dom skolem-const-decl "finite_set[nat]" iareduction nil)
    (S skolem-const-decl "{S | every(domainValue?(dom))(S)}"
     iareduction nil)
    (args skolem-const-decl "{args: list[(variable?)] |
   length(args) = arity AND
    FORALL i: in_varlist(args)(i) IMPLIES i < S`length}" iareduction
          nil)
    (below type-eq-decl nil naturalnumbers nil)
    (i_1 skolem-const-decl "below(length(cdr[(variable?)](args)))"
     iareduction nil)
    (nth def-decl "T" list_props nil)
    (O const-decl "T3" function_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (i skolem-const-decl "nat" iareduction nil))
   nil
   (iapply_nstack subtype
    "list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA y: y WITH [`index := IExpression_adt.index(y) + 1])(list_adt[(IExpression_adt.variable?)].cdr(args))"
    "{L | list_props[(IExpression_adt.variable?)].length(L) = list_props[(IExpression_adt.variable?)].length(args) - 1 AND FORALL i: IL.in_varlist(L)(i) IMPLIES i < 1 + S`length}")))
 (iapply_nstack_TCC6 0
  (iapply_nstack_TCC3-1 nil 3706450317 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (Stack type-eq-decl nil IL nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil (iapply_nstack subtype "arity - 1" "nat")))
 (iapply_nstack_TCC7 0
  (iapply_nstack_TCC4-1 nil 3706450317
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (inst -10 "index(car(args))")
        (("1" (split)
          (("1" (grind) nil nil)
           ("2" (expand in_varlist)
            (("2" (rewrite some_nth)
              (("2" (inst 1 0)
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand in_varlist) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (args skolem-const-decl "{args: list[(variable?)] |
   length(args) = arity AND
    FORALL i: in_varlist(args)(i) IMPLIES i < S`length}" iareduction
          nil)
    (S skolem-const-decl "{S | every(domainValue?(dom))(S)}"
     iareduction nil)
    (dom skolem-const-decl "finite_set[nat]" iareduction nil)
    (arity skolem-const-decl "nat" iareduction nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil
   (iapply_nstack subtype
    "S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))"
    "below[S`length]")))
 (iapply_nstack_TCC8 0
  (iapply_nstack_TCC5-1 nil 3706450317 ("" (subtype-tcc) nil nil)
   ((value? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil (iapply_nstack subtype "IExpression_adt.nil" "(IL.value?)")))
 (iapply_nstack_TCC9 0
  (iapply_nstack_TCC9-1 nil 3706473878
   ("" (skeep* :preds? t)
    (("" (expand every)
      (("" (skeep)
        (("" (expand* push add)
          (("" (lift-if)
            (("" (split +)
              (("1" (flatten)
                (("1" (inst? -8)
                  (("1" (grind) nil nil)
                   ("2" (inst -10 "index(car(args))")
                    (("2" (split -10)
                      (("1" (grind) nil nil)
                       ("2" (expand in_varlist)
                        (("2" (rewrite some_nth)
                          (("2" (inst 1 0)
                            (("1" (grind) nil nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (split +)
                  (("1" (grind) nil nil)
                   ("2" (flatten) (("2" (inst -7 i) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (every const-decl "bool" finseq_theorems nil)
    (every adt-def-decl "boolean" list_adt nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (push const-decl "Stack" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (args skolem-const-decl "{args: list[(variable?)] |
   length(args) = arity AND
    FORALL i: in_varlist(args)(i) IMPLIES i < S`length}" iareduction
          nil)
    (< const-decl "bool" reals nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (arity skolem-const-decl "nat" iareduction nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (S skolem-const-decl "{S | every(domainValue?(dom))(S)}"
     iareduction nil)
    (dom skolem-const-decl "finite_set[nat]" iareduction nil)
    (domainValue? const-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (some adt-def-decl "boolean" list_adt nil)
    (injective? const-decl "bool" functions nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (nth def-decl "T" list_props nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil))
   nil
   (iapply_nstack subtype
    "IL.push(u, S WITH [`seq(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil])"
    "{S | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(S)}")))
 (iapply_nstack_TCC10 0
  (iapply_nstack_TCC10-1 nil 3706473878 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (Stack type-eq-decl nil IL nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (push const-decl "Stack" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack subtype "nargs"
    "{args_1: list[(IExpression_adt.variable?)] | list_props[(IExpression_adt.variable?)].length(args_1) = arity - 1 AND FORALL i: IL.in_varlist(args_1)(i) IMPLIES i < IL.push(u, S WITH [`seq(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil])`length}")))
 (iapply_nstack_TCC11 0
  (iapply_nstack_TCC11-1 nil 3706473878
   ("" (skeep* :preds? t)
    (("" (typepred "cnt(x1)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountStack)
            (("" (expand push)
              (("" (rewrite count_add)
                (("1" (rewrite count_update)
                  (("1" (grind) nil nil)
                   ("2" (inst -11 "index(car(args))")
                    (("2" (split -11)
                      (("1" (grind) nil nil)
                       ("2" (expand in_varlist)
                        (("2" (rewrite some_nth)
                          (("2" (inst 1 0) (("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (grind) nil nil))
                  nil)
                 ("2" (grind) nil nil)
                 ("3" (inst -11 "index(car(args))")
                  (("3" (split)
                    (("1" (grind) nil nil)
                     ("2" (expand in_varlist)
                      (("2" (rewrite some_nth)
                        (("2" (inst 1 0) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((every const-decl "bool" finseq_theorems nil)
    (refcount const-decl "nat" rreduction nil)
    (Stack type-eq-decl nil IL nil)
    (Store type-eq-decl nil reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (push const-decl "Stack" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (count_update formula-decl nil finseq_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (count const-decl "nat" finseq_theorems nil)
    (injective? const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (nth def-decl "T" list_props nil) (< const-decl "bool" reals nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (count_add formula-decl nil finseq_theorems nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (refcountStack const-decl "nat" rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack subtype "cnt"
    "[i: (dom) -> {j | j = rreduction.refcount(dom, str, IL.push(u, S WITH [`seq(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil]), A)(i)}]")))
 (iapply_nstack_TCC12 0
  (iapply_nstack_TCC12-1 nil 3706473878 ("" (termination-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack termination
    "iapply_nstack(arity - 1, dom, IL.push(u, S WITH [`seq(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil]), nargs, str, A, cnt)"
    "nil")))
 (iapply_nstack_TCC13 0
  (iapply_nstack_TCC13-1 nil 3706473878 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (Stack type-eq-decl nil IL nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (injective? const-decl "bool" functions nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (push const-decl "Stack" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack subtype
    "iapply_nstack(arity - 1, dom, IL.push(u, S WITH [`seq(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil]), nargs, str, A, cnt)"
    "{((S1: Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(S1))), ((ncnt: [i: (dom) -> {j | j = rreduction.refcount(dom, str, S1, A)(i)}])) | S1`length = arity + S`length}")))
 (iapply_nstack_TCC14 0
  (iapply_nstack_TCC11-1 nil 3706450317 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (Stack type-eq-decl nil IL nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil (iapply_nstack subtype "arity - 1" "nat")))
 (iapply_nstack_TCC15 0
  (iapply_nstack_TCC12-1 nil 3706450317
   ("" (skeep* :preds? t)
    (("" (expand every (3 -7))
      (("" (skeep :preds? t)
        (("" (expand push)
          (("" (expand add)
            (("" (lift-if)
              (("" (split)
                (("1" (flatten)
                  (("1" (inst -9 "S`length -1 - index(car(args))")
                    (("1" (grind) nil nil)
                     ("2" (inst -11 "index(car(args))")
                      (("2" (split -11)
                        (("1" (grind) nil nil)
                         ("2" (expand in_varlist)
                          (("2" (rewrite some_nth)
                            (("2" (inst 1 0)
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((every const-decl "bool" finseq_theorems nil)
    (push const-decl "Stack" IL nil)
    (u skolem-const-decl "(value?)" iareduction nil)
    (i skolem-const-decl "below(push(u, S)`length)" iareduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nth def-decl "T" list_props nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (below type-eq-decl nil naturalnumbers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (dom skolem-const-decl "finite_set[nat]" iareduction nil)
    (S skolem-const-decl "{S | every(domainValue?(dom))(S)}"
     iareduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (arity skolem-const-decl "nat" iareduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (args skolem-const-decl "{args: list[(variable?)] |
   length(args) = arity AND
    FORALL i: in_varlist(args)(i) IMPLIES i < S`length}" iareduction
          nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "finseq[T]" more_finseq nil))
   nil
   (iapply_nstack subtype "IL.push(u, S)"
    "{S | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(S)}")))
 (iapply_nstack_TCC16 0
  (iapply_nstack_TCC16-1 nil 3706451404 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (Stack type-eq-decl nil IL nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (push const-decl "Stack" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack subtype "nargs"
    "{args: list[(IExpression_adt.variable?)] | list_props[(IExpression_adt.variable?)].length(args) = arity - 1 AND FORALL i: IL.in_varlist(args)(i) IMPLIES i < IL.push(u, S)`length}")))
 (iapply_nstack_TCC17 0
  (iapply_nstack_TCC14-1 nil 3706450317
   ("" (skeep* :preds? t)
    (("" (expand every -7)
      (("" (inst -7 "S`length-1-index(car(args))")
        (("1" (grind) nil nil)
         ("2" (inst -9 "index(car(args))")
          (("2" (split -9)
            (("1" (grind) nil nil)
             ("2" (expand in_varlist)
              (("2" (rewrite some_nth)
                (("2" (inst 1 0)
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((every const-decl "bool" finseq_theorems nil)
    (nth def-decl "T" list_props nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (below type-eq-decl nil naturalnumbers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (dom skolem-const-decl "finite_set[nat]" iareduction nil)
    (S skolem-const-decl "{S | every(domainValue?(dom))(S)}"
     iareduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (arity skolem-const-decl "nat" iareduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (args skolem-const-decl "{args: list[(variable?)] |
   length(args) = arity AND
    FORALL i: in_varlist(args)(i) IMPLIES i < S`length}" iareduction
          nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil (iapply_nstack subtype "IExpression_adt.refindex(u)" "(dom)")))
 (iapply_nstack_TCC18 0
  (iapply_nstack_TCC15-1 nil 3706450317
   ("" (skeep* :preds? t)
    (("" (typepred "cnt(refindex(u))")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountStack)
            (("" (expand push)
              (("" (rewrite count_add) (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (every const-decl "bool" finseq_theorems nil)
    (refcount const-decl "nat" rreduction nil)
    (Stack type-eq-decl nil IL nil)
    (Store type-eq-decl nil reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (push const-decl "Stack" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (count_add formula-decl nil finseq_theorems nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refcountStack const-decl "nat" rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack subtype "cnt(IExpression_adt.refindex(u)) + 1"
    "{j | j = rreduction.refcount(dom, str, IL.push(u, S), A)(IExpression_adt.refindex(u))}")))
 (iapply_nstack_TCC19 0
  (iapply_nstack_TCC19-1 nil 3706451404 ("" (termination-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack termination
    "iapply_nstack(arity - 1, dom, IL.push(u, S), nargs, str, A, cnt WITH [(IExpression_adt.refindex(u)) := cnt(IExpression_adt.refindex(u)) + 1])"
    "nil")))
 (iapply_nstack_TCC20 0
  (iapply_nstack_TCC20-1 nil 3706451404 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (Stack type-eq-decl nil IL nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (injective? const-decl "bool" functions nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (push const-decl "Stack" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack subtype
    "iapply_nstack(arity - 1, dom, IL.push(u, S), nargs, str, A, cnt WITH [(IExpression_adt.refindex(u)) := cnt(IExpression_adt.refindex(u)) + 1])"
    "{((S1: Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(S1))), ((ncnt: [i: (dom) -> {j | j = rreduction.refcount(dom, str, S1, A)(i)}])) | S1`length = arity + S`length}")))
 (iapply_nstack_TCC21 0
  (iapply_nstack_TCC18-1 nil 3706450317 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (Stack type-eq-decl nil IL nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil (iapply_nstack subtype "arity - 1" "nat")))
 (iapply_nstack_TCC22 0
  (iapply_nstack_TCC19-1 nil 3706450317 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (args!1 skolem-const-decl "{args: list[(variable?)] |
   length(args) = arity!1 AND
    FORALL i: in_varlist(args)(i) IMPLIES i < S!1`length}" iareduction
     nil)
    (S!1 skolem-const-decl "{S | every(domainValue?(dom!1))(S)}"
     iareduction nil)
    (arity!1 skolem-const-decl "nat" iareduction nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (dom!1 skolem-const-decl "finite_set[nat]" iareduction nil)
    (injective? const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (push const-decl "Stack" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack subtype "IL.push(u, S)"
    "{S | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(S)}")))
 (iapply_nstack_TCC23 0
  (iapply_nstack_TCC23-1 nil 3706451404 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (Stack type-eq-decl nil IL nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (push const-decl "Stack" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack subtype "nargs"
    "{args: list[(IExpression_adt.variable?)] | list_props[(IExpression_adt.variable?)].length(args) = arity - 1 AND FORALL i: IL.in_varlist(args)(i) IMPLIES i < IL.push(u, S)`length}")))
 (iapply_nstack_TCC24 0
  (iapply_nstack_TCC22-1 nil 3706450317
   ("" (skeep* :preds? t)
    (("" (typepred "cnt(x1)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountStack)
            (("" (expand push)
              (("" (rewrite count_add) (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((every const-decl "bool" finseq_theorems nil)
    (refcount const-decl "nat" rreduction nil)
    (Stack type-eq-decl nil IL nil)
    (Store type-eq-decl nil reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (push const-decl "Stack" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (count_add formula-decl nil finseq_theorems nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (refcountStack const-decl "nat" rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack subtype "cnt"
    "[i: (dom) -> {j | j = rreduction.refcount(dom, str, IL.push(u, S), A)(i)}]")))
 (iapply_nstack_TCC25 0
  (iapply_nstack_TCC25-1 nil 3706451404 ("" (termination-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack termination
    "iapply_nstack(arity - 1, dom, IL.push(u, S), nargs, str, A, cnt)"
    "nil")))
 (iapply_nstack_TCC26 0
  (iapply_nstack_TCC26-1 nil 3706451404 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (Stack type-eq-decl nil IL nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (injective? const-decl "bool" functions nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (push const-decl "Stack" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack subtype
    "iapply_nstack(arity - 1, dom, IL.push(u, S), nargs, str, A, cnt)"
    "{((S1: Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(S1))), ((ncnt: [i: (dom) -> {j | j = rreduction.refcount(dom, str, S1, A)(i)}])) | S1`length = arity + S`length}")))
 (iapply_nstack_TCC27 0
  (iapply_nstack_TCC20-1 nil 3706450317
   ("" (skeep* :preds? t) (("" (grind) nil nil)) nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (some adt-def-decl "boolean" list_adt nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (length def-decl "nat" list_props nil)
    (every adt-def-decl "boolean" list_adt nil))
   nil
   (iapply_nstack subtype "args"
    "(cons?[(IExpression_adt.variable?)])")))
 (iapply_nstack_TCC28 0
  (iapply_nstack_TCC26-1 nil 3706450317
   ("" (skeep* :preds? t)
    (("" (inst -6 "index(car(args))")
      (("1" (split)
        (("1" (grind) nil nil)
         ("2" (expand in_varlist)
          (("2" (rewrite some_nth)
            (("1" (inst 1 0)
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   ((args skolem-const-decl "{args: list[(variable?)] |
   length(args) = arity AND
    FORALL i: in_varlist(args)(i) IMPLIES i < S`length}" iareduction
          nil)
    (S skolem-const-decl "{S | every(domainValue?(dom))(S)}"
     iareduction nil)
    (dom skolem-const-decl "finite_set[nat]" iareduction nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (arity skolem-const-decl "nat" iareduction nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (some adt-def-decl "boolean" list_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (injective? const-decl "bool" functions nil))
   nil
   (iapply_nstack subtype
    "S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))"
    "below[S`length]")))
 (iapply_nstack_ndr_TCC1 0
  (iapply_nstack_ndr_TCC1-1 nil 3706535555 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (Stack type-eq-decl nil IL nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack_ndr subtype "S`length - 1 - k"
    "below[iapply_nstack(arity, dom, S, args, str, A, cnt)`1`length]")))
 (iapply_nstack_ndr_TCC2 0
  (iapply_nstack_ndr_TCC2-1 nil 3706535555 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack_ndr subtype "S`length - 1 - k" "below[S`length]")))
 (iapply_nstack_ndr 0
  (iapply_nstack_ndr-1 nil 3706535556
   ("" (induct arity)
    (("1" (skeep* :preds? t)
      (("1" (expand iapply_nstack)
        (("1" (assert)
          (("1" (rewrite some_nth) (("1" (grind) nil nil)) nil)) nil))
        nil))
      nil)
     ("2" (skeep* :preds? t)
      (("2" (expand iapply_nstack -9)
        (("2" (lift-if)
          (("2" (split)
            (("1" (flatten)
              (("1" (split)
                (("1" (flatten)
                  (("1" (inst? -11)
                    (("1" (inst -11 "k+1")
                      (("1" (split)
                        (("1" (flatten)
                          (("1" (expand push)
                            (("1" (expand add)
                              (("1"
                                (case-replace "k = index(car(args))")
                                (("1" (assert) nil nil)
                                 ("2"
                                  (lift-if -1)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (expand some -)
                                      (("2"
                                        (lift-if)
                                        (("2"
                                          (split)
                                          (("1" (propax) nil nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (split)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil)
                                               ("2"
                                                (rewrite some_map)
                                                (("2"
                                                  (expand o)
                                                  (("2"
                                                    (propax)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand* push add) nil nil))
                        nil)
                       ("2" (expand* push add) (("2" (assert) nil nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil)
                     ("3" (inst -9 "index(car(args))")
                      (("3" (split)
                        (("1" (grind) nil nil)
                         ("2" (expand in_varlist)
                          (("2" (rewrite some_nth)
                            (("2" (inst 1 0) (("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (inst? -10)
                    (("1" (inst -10 "k+1")
                      (("1" (split)
                        (("1" (flatten)
                          (("1" (expand push -1)
                            (("1" (expand add -1)
                              (("1"
                                (assert)
                                (("1"
                                  (rewrite some_map)
                                  (("1"
                                    (expand some -)
                                    (("1"
                                      (lift-if)
                                      (("1"
                                        (split)
                                        (("1" (propax) nil nil)
                                         ("2"
                                          (assert)
                                          (("2"
                                            (expand o)
                                            (("2" (flatten) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand* push add) nil nil))
                        nil)
                       ("2" (expand* push add) (("2" (assert) nil nil))
                        nil))
                      nil)
                     ("2"
                      (typepred
                       "cnt(refindex(S`seq(S`length - 1 - index(car[(variable?)](args)))))")
                      (("1" (rewrite -1)
                        (("1" (expand refcount)
                          (("1" (expand refcountStack)
                            (("1" (expand push)
                              (("1"
                                (rewrite count_add)
                                (("1" (assert) nil nil)
                                 ("2"
                                  (skeep)
                                  (("2"
                                    (inst -9 "index(car(args))")
                                    (("2"
                                      (split)
                                      (("1" (grind) nil nil)
                                       ("2"
                                        (expand in_varlist)
                                        (("2"
                                          (rewrite some_nth)
                                          (("2"
                                            (inst 1 0)
                                            (("2" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (inst -8 "index(car(args))")
                        (("2" (split)
                          (("1" (grind) nil nil)
                           ("2" (expand in_varlist)
                            (("2" (rewrite some_nth)
                              (("2"
                                (inst 1 0)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("3" (inst -8 "index(car(args))")
                      (("3" (split)
                        (("1" (grind) nil nil)
                         ("2" (expand in_varlist)
                          (("2" (rewrite some_nth)
                            (("2" (inst 1 0) (("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (inst? -9)
                (("1" (inst -9 "k+1")
                  (("1" (split)
                    (("1" (flatten)
                      (("1" (expand push)
                        (("1" (expand add)
                          (("1" (assert)
                            (("1" (rewrite some_map)
                              (("1"
                                (expand o)
                                (("1"
                                  (expand some -)
                                  (("1"
                                    (lift-if)
                                    (("1"
                                      (split)
                                      (("1" (propax) nil nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand push)
                      (("2" (expand add) (("2" (propax) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (expand push)
                    (("2" (expand add) (("2" (assert) nil nil)) nil))
                    nil))
                  nil)
                 ("2" (inst -7 "index(car(args))")
                  (("2" (split)
                    (("1" (grind) nil nil)
                     ("2" (expand in_varlist)
                      (("2" (rewrite some_nth)
                        (("2" (inst 1 0) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2)
      (("3" (skeep* :preds? t)
        (("3"
          (typepred " iapply_nstack(arity, dom, S, args, str, A, cnt)")
          (("3" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (count_add formula-decl nil finseq_theorems nil)
    (refcountStack const-decl "nat" rreduction nil)
    (str skolem-const-decl "Store(dom)" iareduction nil)
    (A skolem-const-decl "IExpression" iareduction nil)
    (cnt skolem-const-decl
     "[i: (dom) -> {j | j = refcount(dom, str, S, A)(i)}]" iareduction
     nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (nth def-decl "T" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (k skolem-const-decl "below(S`length)" iareduction nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (O const-decl "T3" function_props nil)
    (some_map formula-decl nil finseq_theorems nil)
    (TRUE const-decl "bool" booleans nil)
    (push const-decl "Stack" IL nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (args skolem-const-decl "{args: list[(variable?)] |
   length(args) = 1 + j AND
    FORALL i: in_varlist(args)(i) IMPLIES i < S`length}" iareduction
          nil)
    (j skolem-const-decl "nat" iareduction nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (S skolem-const-decl "{S | every(domainValue?(dom))(S)}"
     iareduction nil)
    (dom skolem-const-decl "finite_set[nat]" iareduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (some adt-def-decl "boolean" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (iapply_nstack def-decl
     "{((S1: Stack | every(domainValue?(dom))(S1))),
 ((ncnt: [i: (dom) -> {j | j = refcount(dom, str, S1, A)(i)}])) |
   S1`length = S`length + arity}" iareduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (iapply_nstack_indices_TCC1 0
  (iapply_nstack_indices_TCC2-1 nil 3706557670
   ("" (subtype-tcc) nil nil) nil nil
   (iapply_nstack_indices subtype "k"
    "below[length[(IExpression_adt.variable?)](args)]")))
 (iapply_nstack_indices_TCC2 0
  (iapply_nstack_indices_TCC1-1 nil 3706557670
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (Stack type-eq-decl nil IL nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack_indices subtype "S`length + arity - 1 - k"
    "below[iapply_nstack(arity, dom, S, args, str, A, cnt)`1`length]")))
 (iapply_nstack_indices_TCC3 0
  (iapply_nstack_indices_TCC3-1 nil 3706559578
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (Stack type-eq-decl nil IL nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack_indices subtype "arity - 1 - k"
    "below[length[(IExpression_adt.variable?)](args)]")))
 (iapply_nstack_indices_TCC4 0
  (iapply_nstack_indices_TCC3-1 nil 3706558399
   ("" (skeep* :preds? t)
    (("" (inst -7 "index(nth[(variable?)](args, arity - 1 - k1))")
      (("1" (split)
        (("1" (grind) nil nil)
         ("2" (expand in_varlist)
          (("2" (rewrite some_nth) (("2" (grind) nil nil)) nil)) nil))
        nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (k1 skolem-const-decl "below(S`length + arity)" iareduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (arity skolem-const-decl "nat" iareduction nil)
    (S skolem-const-decl "{S | every(domainValue?(dom))(S)}"
     iareduction nil)
    (dom skolem-const-decl "finite_set[nat]" iareduction nil)
    (domainValue? const-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (length def-decl "nat" list_props nil)
    (nth def-decl "T" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (injective? const-decl "bool" functions nil))
   nil
   (iapply_nstack_indices subtype
    "S`length - 1 - IExpression_adt.index(list_props[(IExpression_adt.variable?)].nth(args, arity - 1 - k))"
    "below[S`length]")))
 (iapply_nstack_indices_TCC5 0
  (iapply_nstack_indices_TCC4-1 nil 3706557670
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (Stack type-eq-decl nil IL nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack_indices subtype "S`length - 1 - (k - arity)"
    "below[S`length]")))
 (iapply_nstack_indices 0
  (iapply_nstack_indices-1 nil 3706557671
   ("" (induct arity)
    (("1" (skeep* :preds? t)
      (("1" (expand iapply_nstack)
        (("1" (lift-if)
          (("1" (split)
            (("1" (flatten)
              (("1" (rewrite some_nth) (("1" (grind) nil nil)) nil))
              nil)
             ("2" (propax) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skeep* :preds? t)
      (("2" (expand iapply_nstack +)
        (("2" (case "index(car(args)) < S`length")
          (("1" (case "ref?(S`seq(S`length - 1 - index(car(args))))")
            (("1" (assert)
              (("1" (case "marked(car(args))")
                (("1" (assert)
                  (("1" (inst? -11)
                    (("1" (split -11)
                      (("1" (inst -1 k)
                        (("1" (expand push -1 2)
                          (("1" (expand add)
                            (("1" (rewrite -1)
                              (("1"
                                (case "k < j_1")
                                (("1"
                                  (assert)
                                  (("1"
                                    (expand* push add)
                                    (("1"
                                      (rewrite map_nth_rw)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (lift-if)
                                            (("1"
                                              (assert)
                                              (("1"
                                                (split)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (expand nth 1)
                                                    (("1"
                                                      (case-replace
                                                       "index(nth(cdr(args), -1-k+j_1)) = index(car(args))")
                                                      (("1"
                                                        (inst
                                                         -13
                                                         "j_1-k"
                                                         "0")
                                                        (("1"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (flatten)
                                                  (("2"
                                                    (expand nth 2 2)
                                                    (("2"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (expand length -9)
                                        (("2"
                                          (lift-if -9)
                                          (("2"
                                            (split -9)
                                            (("1" (grind) nil nil)
                                             ("2" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (assert)
                                  (("2"
                                    (case-replace "k = j_1")
                                    (("1"
                                      (assert)
                                      (("1"
                                        (expand* push add)
                                        (("1"
                                          (rewrite some_map)
                                          (("1"
                                            (expand o)
                                            (("1"
                                              (lift-if)
                                              (("1"
                                                (split)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (rewrite some_nth)
                                                    (("1"
                                                      (skeep)
                                                      (("1"
                                                        (inst
                                                         -14
                                                         "i+1"
                                                         "0")
                                                        (("1"
                                                          (grind)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (assert)
                                      (("2"
                                        (expand* push add)
                                        (("2"
                                          (assert)
                                          (("2"
                                            (rewrite some_map)
                                            (("2"
                                              (expand o)
                                              (("2"
                                                (lift-if)
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (split)
                                                    (("1"
                                                      (flatten)
                                                      (("1"
                                                        (lift-if)
                                                        (("1"
                                                          (split)
                                                          (("1"
                                                            (propax)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (flatten)
                                                            (("2"
                                                              (rewrite
                                                               some_nth)
                                                              (("2"
                                                                (inst
                                                                 1
                                                                 0)
                                                                (("2"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (flatten)
                                                      (("2"
                                                        (lift-if)
                                                        (("2"
                                                          (assert)
                                                          (("2"
                                                            (split)
                                                            (("1"
                                                              (flatten)
                                                              (("1"
                                                                (lift-if)
                                                                (("1"
                                                                  (split)
                                                                  (("1"
                                                                    (propax)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (expand
                                                                       some
                                                                       1)
                                                                      (("2"
                                                                        (lift-if)
                                                                        (("2"
                                                                          (split)
                                                                          (("1"
                                                                            (grind)
                                                                            nil
                                                                            nil)
                                                                           ("2"
                                                                            (grind)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (flatten)
                                                              (("2"
                                                                (lift-if)
                                                                (("2"
                                                                  (split
                                                                   2)
                                                                  (("1"
                                                                    (flatten)
                                                                    (("1"
                                                                      (assert)
                                                                      (("1"
                                                                        (expand
                                                                         some
                                                                         -)
                                                                        (("1"
                                                                          (lift-if
                                                                           -2)
                                                                          (("1"
                                                                            (split)
                                                                            (("1"
                                                                              (propax)
                                                                              nil
                                                                              nil)
                                                                             ("2"
                                                                              (grind)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (propax)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil)
                       ("2" (delete 2)
                        (("2" (skeep :preds? t)
                          (("2" (skeep :preds? t)
                            (("2" (inst -15 "j+1" "k!1+1")
                              (("1"
                                (rewrite map_nth_rw)
                                (("1"
                                  (rewrite map_nth_rw)
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (expand length -12)
                                    (("2"
                                      (lift-if)
                                      (("2"
                                        (split)
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (rewrite map_length)
                                          nil
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (rewrite map_length)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (rewrite map_length)
                                (("2"
                                  (expand length 1)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (assert)
                  (("2" (inst? -10)
                    (("1" (split -10)
                      (("1" (inst -1 k)
                        (("1" (expand push -1 2)
                          (("1" (expand add)
                            (("1" (rewrite -1)
                              (("1"
                                (case "k < j_1")
                                (("1"
                                  (assert)
                                  (("1"
                                    (expand* push add)
                                    (("1"
                                      (lift-if)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (split)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (rewrite map_nth_rw)
                                              (("1" (grind) nil nil)
                                               ("2"
                                                (expand length -9)
                                                (("2"
                                                  (lift-if)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (rewrite map_nth_rw)
                                              (("1"
                                                (assert)
                                                (("1" (grind) nil nil))
                                                nil)
                                               ("2"
                                                (expand length -8)
                                                (("2"
                                                  (lift-if)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (assert)
                                  (("2"
                                    (case "k = j_1")
                                    (("1"
                                      (assert)
                                      (("1"
                                        (expand* push add)
                                        (("1"
                                          (rewrite some_map)
                                          (("1"
                                            (expand o)
                                            (("1"
                                              (lift-if)
                                              (("1"
                                                (split)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (rewrite some_nth)
                                                    (("1"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (flatten)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (assert)
                                      (("2"
                                        (expand* push add)
                                        (("2"
                                          (rewrite some_map)
                                          (("2"
                                            (expand o)
                                            (("2"
                                              (lift-if)
                                              (("2"
                                                (split)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (lift-if)
                                                      (("1"
                                                        (split)
                                                        (("1"
                                                          (propax)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (flatten)
                                                          (("2"
                                                            (expand
                                                             some
                                                             1)
                                                            (("2"
                                                              (lift-if)
                                                              (("2"
                                                                (split)
                                                                (("1"
                                                                  (grind)
                                                                  nil
                                                                  nil)
                                                                 ("2"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (flatten)
                                                  (("2"
                                                    (lift-if)
                                                    (("2"
                                                      (split)
                                                      (("1"
                                                        (assert)
                                                        nil
                                                        nil)
                                                       ("2"
                                                        (assert)
                                                        (("2"
                                                          (split)
                                                          (("1"
                                                            (flatten)
                                                            (("1"
                                                              (expand
                                                               some
                                                               -2)
                                                              (("1"
                                                                (lift-if)
                                                                (("1"
                                                                  (split)
                                                                  (("1"
                                                                    (propax)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (propax)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil)
                       ("2" (hide 3)
                        (("2" (skeep* :preds? t)
                          (("2" (inst -14 "j+1" "k!1+1")
                            (("1" (rewrite map_nth_rw)
                              (("1"
                                (rewrite map_nth_rw)
                                (("1" (grind) nil nil)
                                 ("2" (rewrite map_length) nil nil))
                                nil)
                               ("2"
                                (rewrite map_length)
                                (("2" (grind) nil nil))
                                nil))
                              nil)
                             ("2" (expand length -11)
                              (("2"
                                (lift-if)
                                (("2"
                                  (rewrite map_length)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (delete 3)
                      (("2"
                        (typepred
                         "cnt(refindex(S`seq(S`length - 1 - index(car[(variable?)](args)))))")
                        (("2" (rewrite -1)
                          (("2" (expand refcount)
                            (("2" (expand refcountStack)
                              (("2"
                                (expand push)
                                (("2" (rewrite count_add) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (assert)
              (("2" (inst? -9)
                (("2" (split -9)
                  (("1" (inst -1 k)
                    (("1" (expand push -1 2)
                      (("1" (expand add)
                        (("1" (rewrite -1)
                          (("1" (case "k < j_1")
                            (("1" (assert)
                              (("1"
                                (expand* push add)
                                (("1"
                                  (rewrite map_nth_rw)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (expand nth 2 2)
                                      (("1" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (expand length -7)
                                    (("2"
                                      (lift-if -7)
                                      (("2"
                                        (split)
                                        (("1" (grind) nil nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (assert)
                              (("2"
                                (case-replace "k = j_1")
                                (("1"
                                  (assert)
                                  (("1"
                                    (expand push)
                                    (("1"
                                      (expand add)
                                      (("1" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (assert)
                                  (("2"
                                    (expand* push add)
                                    (("2"
                                      (lift-if)
                                      (("2"
                                        (split)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (assert)
                                            (("1"
                                              (rewrite some_map)
                                              (("1"
                                                (expand o)
                                                (("1"
                                                  (expand some 1)
                                                  (("1"
                                                    (lift-if)
                                                    (("1"
                                                      (split)
                                                      (("1"
                                                        (grind)
                                                        nil
                                                        nil)
                                                       ("2"
                                                        (flatten)
                                                        (("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (flatten)
                                          (("2"
                                            (split)
                                            (("1" (grind) nil nil)
                                             ("2"
                                              (rewrite some_map)
                                              (("2"
                                                (expand o)
                                                (("2"
                                                  (lift-if 2)
                                                  (("2"
                                                    (split)
                                                    (("1"
                                                      (flatten)
                                                      (("1"
                                                        (expand some -)
                                                        (("1"
                                                          (lift-if -2)
                                                          (("1"
                                                            (split)
                                                            (("1"
                                                              (propax)
                                                              nil
                                                              nil)
                                                             ("2"
                                                              (flatten)
                                                              (("2"
                                                                (split)
                                                                (("1"
                                                                  (grind)
                                                                  nil
                                                                  nil)
                                                                 ("2"
                                                                  (propax)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil)
                   ("2" (assert)
                    (("2" (delete 3)
                      (("2" (skeep* :preds? t)
                        (("2" (inst -13 "j+1" "k!1+1")
                          (("1" (rewrite map_nth_rw)
                            (("1" (rewrite map_nth_rw)
                              (("1" (grind) nil nil)
                               ("2" (rewrite map_length) nil nil))
                              nil)
                             ("2" (rewrite map_length)
                              (("2" (assert) nil nil)) nil))
                            nil)
                           ("2" (rewrite map_length)
                            (("2" (expand length -10)
                              (("2"
                                (lift-if)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (grind) nil nil))
            nil)
           ("2" (delete 2)
            (("2" (inst -6 "index(car(args))")
              (("2" (split)
                (("1" (propax) nil nil)
                 ("2" (expand in_varlist)
                  (("2" (rewrite some_nth)
                    (("2" (inst 1 0) (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (delete 2) (("3" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("3" (delete 2) (("3" (grind) nil nil)) nil)
     ("4" (delete 2) (("4" (grind) nil nil)) nil)
     ("5" (delete 2)
      (("5" (skeep* :preds? t)
        (("5" (inst -7 "index(nth(args,arity-1-k1))")
          (("1" (split)
            (("1" (grind) nil nil)
             ("2" (expand in_varlist)
              (("2" (rewrite some_nth) (("2" (grind) nil nil)) nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("6" (delete 2) (("6" (grind) nil nil)) nil)
     ("7" (delete 2) (("7" (grind) nil nil)) nil))
    nil)
   ((k1 skolem-const-decl "below(S`length + arity)" iareduction nil)
    (arity skolem-const-decl "nat" iareduction nil)
    (S skolem-const-decl "{S | every(domainValue?(dom))(S)}"
     iareduction nil)
    (dom skolem-const-decl "finite_set[nat]" iareduction nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (j skolem-const-decl
     "below(length(map(LAMBDA y: y WITH [`index := 1 + index(y)])(cdr(args))))"
     iareduction nil)
    (refcountStack const-decl "nat" rreduction nil)
    (count_add formula-decl nil finseq_theorems nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (j skolem-const-decl
     "below(length(map(LAMBDA y: y WITH [`index := 1 + index(y)])(cdr(args))))"
     iareduction nil)
    (str skolem-const-decl "Store(dom)" iareduction nil)
    (A skolem-const-decl "IExpression" iareduction nil)
    (cnt skolem-const-decl
     "[i: (dom) -> {j | j = refcount(dom, str, S, A)(i)}]" iareduction
     nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (some_map formula-decl nil finseq_theorems nil)
    (i skolem-const-decl "below(length(cdr(args)))" iareduction nil)
    (O const-decl "T3" function_props nil)
    (TRUE const-decl "bool" booleans nil)
    (map_nth_rw formula-decl nil more_map_props nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (args skolem-const-decl "{args: list[(variable?)] |
   length(args) = 1 + j_1 AND
    FORALL i: in_varlist(args)(i) IMPLIES i < S`length}" iareduction
          nil)
    (k skolem-const-decl "below(1 + S`length + j_1)" iareduction nil)
    (j_1 skolem-const-decl "nat" iareduction nil)
    (S skolem-const-decl "{S | every(domainValue?(dom))(S)}"
     iareduction nil)
    (dom skolem-const-decl "finite_set[nat]" iareduction nil)
    (j skolem-const-decl
     "below(length(map(LAMBDA y: y WITH [`index := 1 + index(y)])(cdr(args))))"
     iareduction nil)
    (map_length formula-decl nil more_map_props nil)
    (k!1 skolem-const-decl "below(j)" iareduction nil)
    (push const-decl "Stack" IL nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (pred type-eq-decl nil defined_types nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (some adt-def-decl "boolean" list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (nth def-decl "T" list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (iapply_nstack def-decl
     "{((S1: Stack | every(domainValue?(dom))(S1))),
 ((ncnt: [i: (dom) -> {j | j = refcount(dom, str, S1, A)(i)}])) |
   S1`length = S`length + arity}" iareduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (npops_TCC1 0
  (npops_TCC1-1 nil 3706450317 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil (npops subtype "n - 1" "nat")))
 (npops_TCC2 0
  (npops_TCC2-1 nil 3706450317 ("" (termination-tcc) nil nil) nil nil
   (npops termination "npops(n - 1, A)" "nil")))
 (npops_popDepth 0
  (npops_popDepth-1 nil 3706452489 ("" (induct-and-simplify n) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (popDepth def-decl "nat" IL nil)
    (npops def-decl "IExpression" iareduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (npops_refs 0
  (npops_refs-1 nil 3706452519 ("" (induct-and-simplify n) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (refs def-decl "bool" IL nil)
    (npops def-decl "IExpression" iareduction nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (npops_contextPure 0
  (npops_contextPure-1 nil 3706452524
   ("" (induct-and-simplify n) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (npops def-decl "IExpression" iareduction nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (npops_vars 0
  (npops_vars-1 nil 3706452530 ("" (induct-and-simplify n) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (npops def-decl "IExpression" iareduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (drop const-decl "finite_set[nat]" IL nil))
   shostak))
 (npops_cvars 0
  (npops_cvars-1 nil 3706452736 ("" (induct-and-simplify n) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (npops def-decl "IExpression" iareduction nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (npops_mark 0
  (npops_mark-1 nil 3706452610
   ("" (induct n)
    (("1" (skeep* :preds? t)
      (("1" (case-replace "bumpn(X, 0) = X")
        (("1" (grind) nil nil)
         ("2" (expand bumpn) (("2" (grind-with-ext) nil nil)) nil))
        nil))
      nil)
     ("2" (skeep* :preds? t)
      (("2" (expand npops +)
        (("2" (expand mark 1 1)
          (("2" (inst?)
            (("2" (rewrite -3)
              (("2" (decompose-equality)
                (("2"
                  (case-replace "bumpn(bump(X), j) = bumpn(X, 1 + j)")
                  (("2" (decompose-equality) (("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression_pop_extensionality formula-decl nil IExpression_adt
     nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (npops def-decl "IExpression" iareduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (iapplyReduce_TCC1 0
  (iapplyReduce_TCC1-1 nil 3706450317 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (iapplyReduce subtype "grS`redex"
    "(IExpression_adt.application?)")))
 (iapplyReduce_TCC2 0
  (iapplyReduce_TCC2-1 nil 3706450317
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (grind) nil nil)
       ("2" (skeep)
        (("2" (typepred "grS`redex")
          (("2" (inst -2 i)
            (("2" (split) (("1" (grind) nil nil) ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (applyRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (iapplyReduce subtype "IExpression_adt.args(grS`redex)"
    "{args: list[(IExpression_adt.variable?)] | list_props[(IExpression_adt.variable?)].length(args) = def`arity AND FORALL i: IL.in_varlist(args)(i) IMPLIES i < grS`stack`length}")))
 (iapplyReduce_TCC3 0
  (iapplyReduce_TCC3-1 nil 3706450317
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (skeep)
        (("1" (rewrite npops_refs)
          (("1" (rewrite refs_mark)
            (("1" (use pure_refs) (("1" (grind) nil nil)) nil)) nil))
          nil))
        nil)
       ("2" (skeep*)
        (("2" (rewrite npops_vars)
          (("2" (rewrite vars_mark)
            (("2" (typepred "def`body") (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil)
       ("3"
        (typepred
         "iapply_nstack(def`arity, grS`domain, grS`stack, args(grS`redex),
                     grS`store, grS`redex, grS`count)")
        (("3" (skeep*)
          (("3" (rewrite npops_popDepth)
            (("3" (rewrite purePopDepth)
              (("1" (typepred "grS`redex")
                (("1" (inst -3 i) (("1" (grind) nil nil)) nil)) nil)
               ("2" (use pure_mark)
                (("2" (typepred "def`body") (("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("4"
        (typepred
         "iapply_nstack(def`arity, grS`domain, grS`stack, args(grS`redex),
                     grS`store, grS`redex, grS`count)")
        (("4" (rewrite npops_popDepth)
          (("4" (rewrite purePopDepth)
            (("1" (typepred "grS`redex") (("1" (grind) nil nil)) nil)
             ("2" (use pure_mark)
              (("2" (typepred "def`body") (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("5" (rewrite npops_contextPure)
        (("5" (use pure_contextPure)
          (("5" (use pure_mark)
            (("5" (typepred "def`body") (("5" (grind) nil nil)) nil))
            nil))
          nil))
        nil)
       ("6" (rewrite npops_mark)
        (("6"
          (case-replace "mark(bumpn(cvars(grS`context), def`arity))
                (mark(emptyset[nat])(def`body)) = mark(emptyset[nat])(def`body)")
          (("6" (hide 2)
            (("6" (use mark_repeat)
              (("6" (split)
                (("1" (propax) nil nil)
                 ("2" (skeep* :preds? t)
                  (("2" (typepred "def`body") (("2" (grind) nil nil))
                    nil))
                  nil)
                 ("3" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (npops_refs formula-decl nil iareduction nil)
    (IExpression type-decl nil IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil iareduction nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (pure_refs formula-decl nil IL nil)
    (refs_mark formula-decl nil preprocess nil)
    (npops_vars formula-decl nil iareduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil nat_types nil)
    (Defs type-eq-decl nil iareduction nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (unmark_pure rec-application-judgement "(pure?)" preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark formula-decl nil preprocess nil)
    (purePopDepth formula-decl nil IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pure_mark formula-decl nil preprocess nil)
    (npops_popDepth formula-decl nil iareduction nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (length def-decl "nat" list_props nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (iapply_nstack def-decl
     "{((S1: Stack | every(domainValue?(dom))(S1))),
 ((ncnt: [i: (dom) -> {j | j = refcount(dom, str, S1, A)(i)}])) |
   S1`length = S`length + arity}" iareduction nil)
    (args adt-accessor-decl "[(application?) -> list[(variable?)]]"
          IExpression_adt nil)
    (pure_contextPure formula-decl nil IL nil)
    (npops_contextPure formula-decl nil iareduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (mark_repeat formula-decl nil preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nstack skolem-const-decl
     "{S1 | every(domainValue?(grS`domain))(S1)}" iareduction nil)
    (grS skolem-const-decl "{grS | applyRedex?(grS`redex)}" iareduction
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (npops_mark formula-decl nil iareduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (iapplyReduce subtype
    "npops(def`arity, preprocess.mark(sets[nat].emptyset)(def`body))"
    "{A |      (FORALL i: IL.refs(rreduction.A)(rreduction.i) IMPLIES grS`domain(rreduction.i)) AND (FORALL i: IL.vars(rreduction.A)(rreduction.i) IMPLIES rreduction.i + IL.popDepth(rreduction.A) < nstack`length) AND (FORALL i: IL.vars(grS`context)(rreduction.i) IMPLIES rreduction.i + IL.popDepth(rreduction.A) + IL.popDepth(grS`context) < nstack`length) AND (IL.popDepth(rreduction.A) + IL.popDepth(grS`context) <= nstack`length) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(grS`context))(rreduction.A) = rreduction.A)}")))
 (iapplyReduce_TCC4 0
  (iapplyReduce_TCC4-1 nil 3706457843
   ("" (skeep* :preds? t)
    (("" (typepred "ncount(x1)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountExpr)
            (("" (rewrite npops_refs)
              (("" (rewrite pure_refs)
                (("1" (rewrite pure_refs)
                  (("1" (rewrite pure_mark) nil nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((applyRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Definition type-eq-decl nil iareduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (pure? def-decl "bool" IL nil)
    (npops_refs formula-decl nil iareduction nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (pure_mark formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pure_refs formula-decl nil IL nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (iapplyReduce subtype "ncount"
    "[i: (grS`domain) -> {j | j = rreduction.refcount(grS`domain, grS`store, nstack, npops(def`arity, preprocess.mark(sets[nat].emptyset)(def`body)))(i)}]")))
 (iapplyReduce_ndr 0
  (iapplyReduce_ndr-4 nil 3706537281
   ("" (skeep* :preds? t)
    (("" (expand noDanglingRefs?)
      (("" (skeep* :preds? t)
        (("" (expand iapplyReduce)
          (("" (lift-if)
            (("" (split)
              (("1" (flatten)
                (("1" (assert)
                  (("1" (case "i>=length(args(grS`redex))")
                    (("1" (inst -5 "i-length(args(grS`redex))")
                      (("1"
                        (typepred
                         "iapply_nstack(D`seq(fun(grS`redex))`arity, grS`domain,
                                                grS`stack, args(grS`redex), grS`store,
                                                grS`redex, grS`count)")
                        (("1" (replace -1)
                          (("1" (use iapply_nstack_ndr)
                            (("1" (split)
                              (("1"
                                (flatten)
                                (("1"
                                  (assert)
                                  (("1"
                                    (case
                                     "NOT cvars(grS`context)(i-length(args(grS`redex)))")
                                    (("1"
                                      (expand applyRedex?)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (typepred "grS`redex")
                                          (("1"
                                            (expand mark -6)
                                            (("1"
                                              (decompose-equality -6)
                                              (("1"
                                                (split -13)
                                                (("1"
                                                  (expand cvars -1)
                                                  (("1"
                                                    (expand vars -1)
                                                    (("1"
                                                      (expand
                                                       in_varlist
                                                       -1)
                                                      (("1"
                                                        (rewrite
                                                         some_nth
                                                         -1)
                                                        (("1"
                                                          (skeep)
                                                          (("1"
                                                            (use
                                                             markvars_mark)
                                                            (("1"
                                                              (split)
                                                              (("1"
                                                                (grind)
                                                                nil
                                                                nil)
                                                               ("2"
                                                                (skeep)
                                                                (("2"
                                                                  (replace
                                                                   -4)
                                                                  (("2"
                                                                    (rewrite
                                                                     some_nth
                                                                     +)
                                                                    (("2"
                                                                      (inst
                                                                       2
                                                                       j)
                                                                      (("2"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (rewrite npops_popDepth)
                                      (("2"
                                        (rewrite purePopDepth 4)
                                        (("1"
                                          (expand bumpn)
                                          (("1" (assert) nil nil))
                                          nil)
                                         ("2"
                                          (rewrite pure_mark)
                                          nil
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (assert) nil nil))
                              nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil)
                     ("2" (rewrite npops_cvars)
                      (("2" (rewrite cvars_mark)
                        (("2" (typepred "D`seq(fun(grS`redex))`body")
                          (("2" (rewrite cvars_pure +)
                            (("2" (assert)
                              (("2"
                                (inst -2 i)
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (assert)
                (("2" (flatten)
                  (("2" (assert)
                    (("2" (replace 1)
                      (("2" (inst?)
                        (("2" (split -)
                          (("1" (propax) nil nil)
                           ("2" (propax) nil nil)
                           ("3" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (iapplyReduce const-decl "rstate" iareduction nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (npops_cvars formula-decl nil iareduction nil)
    (unmark_pure rec-application-judgement "(pure?)" preprocess nil)
    (cvars_pure formula-decl nil preprocess nil)
    (cvars_mark formula-decl nil preprocess nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (D skolem-const-decl "Defs" iareduction nil)
    (grS skolem-const-decl
     "{grS | noDanglingRefs?(grS) AND applyRedex?(grS`redex)}"
     iareduction nil)
    (i skolem-const-decl "below(iapplyReduce(D)(grS)`stack`length)"
       iareduction nil)
    (npops_popDepth formula-decl nil iareduction nil)
    (pure_mark formula-decl nil preprocess nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (purePopDepth formula-decl nil IL nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (markvars_mark formula-decl nil preprocess nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (iapply_nstack_ndr formula-decl nil iareduction nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (iapply_nstack def-decl
     "{((S1: Stack | every(domainValue?(dom))(S1))),
 ((ncnt: [i: (dom) -> {j | j = refcount(dom, str, S1, A)(i)}])) |
   S1`length = S`length + arity}" iareduction nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil iareduction nil)
    (Defs type-eq-decl nil iareduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (length def-decl "nat" list_props nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (args adt-accessor-decl "[(application?) -> list[(variable?)]]"
          IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (iapplyReduce_ndr subtype "iapplyReduce(D)(grS)"
    "(rreduction.noDanglingRefs?)"))
  (iapplyReduce_ndr-3 nil 3706537205
   ("" (skeep* :preds? t)
    (("" (expand noDanglingRefs?)
      (("" (skeep* :preds? t)
        (("" (expand iapplyReduce)
          (("" (lift-if)
            (("" (split)
              (("1" (flatten)
                (("1" (assert)
                  (("1" (case "i>=length(args(grS`redex))")
                    (("1" (inst -4 "i-length(args(grS`redex))")
                      (("1"
                        (typepred
                         "iapply_nstack(D`seq(fun(grS`redex))`arity, grS`domain,
                                          grS`stack, args(grS`redex), grS`store,
                                          grS`redex, grS`count)")
                        (("1" (replace -1)
                          (("1" (use iapply_nstack_ndr)
                            (("1" (split)
                              (("1"
                                (flatten)
                                (("1"
                                  (assert)
                                  (("1"
                                    (case
                                     "NOT cvars(grS`context)(i-length(args(grS`redex)))")
                                    (("1"
                                      (expand applyRedex?)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (expand cvars -1)
                                          (("1"
                                            (expand vars -1)
                                            (("1"
                                              (postpone)
                                              nil)))))))))
                                     ("2"
                                      (rewrite npops_popDepth)
                                      (("2"
                                        (rewrite purePopDepth 4)
                                        (("1"
                                          (expand bumpn)
                                          (("1"
                                            (assert)
                                            (("1"
                                              (split)
                                              (("1" (assert) nil)
                                               ("2"
                                                (assert)
                                                (("2"
                                                  (rewrite
                                                   purePopDepth
                                                   -1)
                                                  (("1" (assert) nil)
                                                   ("2"
                                                    (grind)
                                                    nil)))))))))))
                                         ("2"
                                          (rewrite pure_mark)
                                          nil)))))))))))
                               ("2" (assert) nil)))
                             ("2" (assert)
                              (("2"
                                (rewrite npops_cvars)
                                (("2"
                                  (rewrite cvars_mark)
                                  (("2"
                                    (typepred
                                     "D`seq(fun(grS`redex))`body")
                                    (("2"
                                      (inst -2 i)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (rewrite cvars_pure 3)
                                          nil)))))))))))))))))))))
                     ("2" (rewrite npops_cvars)
                      (("2" (rewrite cvars_mark)
                        (("2" (typepred "D`seq(fun(grS`redex))`body")
                          (("2" (rewrite cvars_pure)
                            (("2" (inst -2 i)
                              (("2" (assert) nil)))))))))))))))))
               ("2" (assert)
                (("2" (flatten)
                  (("2" (assert)
                    (("2" (replace 1)
                      (("2" (inst?)
                        (("2" (split -)
                          (("1" (propax) nil) ("2" (propax) nil)
                           ("3" (propax) nil))))))))))))))))))))))))
    nil)
   nil nil
   (iapplyReduce_ndr subtype "iapplyReduce(D)(grS)"
    "(rreduction.noDanglingRefs?)"))
  (iapplyReduce_ndr-2 nil 3706537060
   ("" (skeep* :preds? t)
    (("" (expand noDanglingRefs?)
      (("" (skeep* :preds? t)
        (("" (expand iapplyReduce)
          (("" (lift-if)
            (("" (split)
              (("1" (flatten)
                (("1" (assert)
                  (("1" (inst -4 "i-length(args(grS`redex))")
                    (("1"
                      (typepred
                       "iapply_nstack(D`seq(fun(grS`redex))`arity, grS`domain,
                                    grS`stack, args(grS`redex), grS`store,
                                    grS`redex, grS`count)")
                      (("1" (replace -1)
                        (("1" (use iapply_nstack_ndr)
                          (("1" (split)
                            (("1" (flatten)
                              (("1"
                                (assert)
                                (("1"
                                  (case
                                   "NOT cvars(grS`context)(i-length(args(grS`redex)))")
                                  (("1"
                                    (expand applyRedex?)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (expand cvars -1)
                                        (("1"
                                          (expand vars -1)
                                          (("1" (postpone) nil)))))))))
                                   ("2"
                                    (rewrite npops_popDepth)
                                    (("2"
                                      (rewrite purePopDepth 4)
                                      (("1"
                                        (expand bumpn)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (split)
                                            (("1" (assert) nil)
                                             ("2"
                                              (assert)
                                              (("2"
                                                (rewrite
                                                 purePopDepth
                                                 -1)
                                                (("1" (assert) nil)
                                                 ("2"
                                                  (grind)
                                                  nil)))))))))))
                                       ("2"
                                        (rewrite pure_mark)
                                        nil)))))))))))
                             ("2" (assert) nil)))
                           ("2" (assert)
                            (("2" (rewrite npops_cvars)
                              (("2"
                                (rewrite cvars_mark)
                                (("2"
                                  (typepred
                                   "D`seq(fun(grS`redex))`body")
                                  (("2"
                                    (inst -2 i)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (rewrite cvars_pure 3)
                                        nil)))))))))))))))))))
                     ("2" (rewrite npops_cvars)
                      (("2" (rewrite cvars_mark)
                        (("2" (typepred "D`seq(fun(grS`redex))`body")
                          (("2" (rewrite cvars_pure)
                            (("2" (inst -2 i)
                              (("2" (assert) nil)))))))))))))))))
               ("2" (assert)
                (("2" (flatten)
                  (("2" (assert)
                    (("2" (replace 1)
                      (("2" (inst?)
                        (("2" (split -)
                          (("1" (propax) nil) ("2" (propax) nil)
                           ("3" (propax) nil))))))))))))))))))))))))
    nil)
   nil nil
   (iapplyReduce_ndr subtype "iapplyReduce(D)(grS)"
    "(rreduction.noDanglingRefs?)"))
  (iapplyReduce_ndr-1 nil 3706456701
   ("" (skeep* :preds? t)
    (("" (expand noDanglingRefs?)
      (("" (skeep* :preds? t)
        (("" (expand iapplyReduce)
          (("" (lift-if)
            (("" (split)
              (("1" (flatten)
                (("1" (assert)
                  (("1" (inst -4 "i-length(args(grS`redex))")
                    (("1"
                      (typepred
                       "iapply_nstack(D`seq(fun(grS`redex))`arity, grS`domain,
                              grS`stack, args(grS`redex), grS`store,
                              grS`redex, grS`count)")
                      (("1" (replace -1)
                        (("1" (use iapply_nstack_ndr)
                          (("1" (split)
                            (("1" (flatten)
                              (("1"
                                (assert)
                                (("1"
                                  (split)
                                  (("1"
                                    (expand applyRedex?)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (expand cvars -1)
                                        (("1"
                                          (expand vars -1)
                                          (("1" (postpone) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (rewrite npops_popDepth)
                                    (("2"
                                      (rewrite purePopDepth 4)
                                      (("1"
                                        (expand bumpn)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (split)
                                            (("1" (assert) nil nil)
                                             ("2"
                                              (assert)
                                              (("2"
                                                (rewrite
                                                 purePopDepth
                                                 -1)
                                                (("1" (assert) nil nil)
                                                 ("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (rewrite pure_mark)
                                        nil
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (assert) nil nil))
                            nil)
                           ("2" (assert)
                            (("2" (rewrite npops_cvars)
                              (("2"
                                (rewrite cvars_mark)
                                (("2"
                                  (typepred
                                   "D`seq(fun(grS`redex))`body")
                                  (("2"
                                    (inst -2 i)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (rewrite cvars_pure 3)
                                        nil
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (rewrite npops_cvars)
                      (("2" (rewrite cvars_mark)
                        (("2" (typepred "D`seq(fun(grS`redex))`body")
                          (("2" (rewrite cvars_pure)
                            (("2" (inst -2 i) (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (assert)
                (("2" (flatten)
                  (("2" (assert)
                    (("2" (replace 1)
                      (("2" (inst?)
                        (("2" (split -)
                          (("1" (propax) nil nil)
                           ("2" (propax) nil nil)
                           ("3" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil nil
   (iapplyReduce_ndr subtype "iapplyReduce(D)(grS)"
    "(rreduction.noDanglingRefs?)")))
 (iareduce_TCC1 0
  (iareduce_TCC1-1 nil 3706456701
   ("" (skeep* :preds? t)
    (("" (lemma make_redex_ndr)
      (("" (inst?) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((make_redex_ndr judgement-tcc nil rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (t skolem-const-decl "rtopstate" iareduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (iareduce subtype "rreduction.make_redex(t)"
    "(rreduction.noDanglingRefs?)")))
 (iareduce_TCC2 0
  (iareduce_TCC2-1 nil 3706456701 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (iareduce subtype "nS"
    "{grS | IExpression_adt.variable?(rreduction.grS`redex)}")))
 (iareduce_TCC3 0
  (iareduce_TCC3-1 nil 3706456701
   ("" (skeep* :preds? t)
    (("" (expand* to_topstate make_redex) (("" (grind) nil nil)) nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (value? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil))
   nil (iareduce subtype "D" "Defs")))
 (iareduce_TCC4 0
  (iareduce_TCC6-1 nil 3706456701 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (iareduce subtype "nS" "{grS | IL.applyRedex?(grS`redex)}")))
 (iareduce_TCC5 0
  (iareduce_TCC7-1 nil 3706533808 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (iareduce subtype "nS"
    "{grS | IL.pureIftRedex?(rreduction.grS`redex)}")))
 (iareduce_TCC6 0
  (iareduce_TCC9-1 nil 3706533808 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (iareduce subtype "nS"
    "{grS | IL.updateRedex?(rreduction.grS`redex) AND rreduction.noDanglingRefs?(rreduction.grS)}")))
 (iareduce_TCC7 0
  (iareduce_TCC11-1 nil 3706533808 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (iareduce subtype "nS"
    "{grS | IL.lookupRedex?(rreduction.grS`redex)}")))
 (iareduce_TCC8 0
  (iareduce_TCC13-1 nil 3706533808 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (iareduce subtype "nS"
    "{grS | IL.newintRedex?(rreduction.grS`redex)}")))
 (iareduce_TCC9 0
  (iareduce_TCC15-1 nil 3706533808 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (iareduce subtype "nS"
    "{grS | IL.newrefRedex?(rreduction.grS`redex)}")))
 (iareduce_TCC10 0
  (iareduce_TCC17-1 nil 3706533808 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (iareduce subtype "nS"
    "{grS | IL.popRedex?(rreduction.grS`redex) AND rreduction.noDanglingRefs?(rreduction.grS)}")))
 (iareduce_TCC11 0
  (iareduce_TCC19-1 nil 3706533808
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (grind) nil nil)
       ("2" (typepred "make_redex(t)") (("2" (grind) nil nil)) nil)
       ("3" (propax) nil nil))
      nil))
    nil)
   ((buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (value? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pureRedex? const-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (iareduce subtype "nS"
    "{grS | IL.pureReleaseRedex?(rreduction.grS`redex) AND rreduction.noDanglingRefs?(rreduction.grS)}")))
 (iareduce_ndr 0
  (iareduce_ndr-1 nil 3706456701
   ("" (skeep* :preds? t)
    (("" (expand iareduce)
      (("" (split)
        (("1" (flatten) (("1" (assert) nil nil)) nil)
         ("2" (flatten)
          (("2" (name-replace nS "make_redex(to_topstate(grS))")
            (("1" (case "noDanglingRefs?(nS)")
              (("1" (split)
                (("1" (flatten)
                  (("1" (assert)
                    (("1" (use variableReduce_ndr) nil nil)) nil))
                  nil)
                 ("2" (flatten)
                  (("2" (split)
                    (("1" (flatten)
                      (("1" (use letReduce_ndr)
                        (("1" (assert) nil nil)) nil))
                      nil)
                     ("2" (flatten)
                      (("2" (split)
                        (("1" (flatten)
                          (("1" (use iapplyReduce_ndr)
                            (("1" (assert) nil nil)) nil))
                          nil)
                         ("2" (flatten)
                          (("2" (split)
                            (("1" (flatten)
                              (("1"
                                (use ifReduce_ndr)
                                (("1" (assert) nil nil))
                                nil))
                              nil)
                             ("2" (flatten)
                              (("2"
                                (split)
                                (("1"
                                  (flatten)
                                  (("1" (assert) nil nil))
                                  nil)
                                 ("2"
                                  (flatten)
                                  (("2"
                                    (split)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (use lookupReduce_ndr)
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (split)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (use newintReduce_ndr)
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (flatten)
                                          (("2"
                                            (split)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (use newrefReduce_ndr)
                                                (("1"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (split)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (use popReduce_ndr)
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (flatten)
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (use
                                                       releaseReduce_ndr)
                                                      (("2"
                                                        (typepred nS)
                                                        (("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand nS)
                (("2" (lemma make_redex_ndr)
                  (("2" (inst?)
                    (("2" (split)
                      (("1" (propax) nil nil)
                       ("2" (expand to_topstate)
                        (("2" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (split)
              (("1" (propax) nil nil)
               ("2" (expand to_topstate) (("2" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (iareduce const-decl "rstate" iareduction nil)
    (releaseReduce_ndr judgement-tcc nil rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (releaseReduce const-decl "rstate" rreduction nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (releaseRedex? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (popRedex? const-decl "bool" IL nil)
    (popReduce_ndr judgement-tcc nil rreduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newrefReduce_ndr judgement-tcc nil rreduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (newintReduce_ndr judgement-tcc nil rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (lookupReduce_ndr judgement-tcc nil rreduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (ifReduce_ndr judgement-tcc nil rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (iapplyReduce_ndr judgement-tcc nil iareduction nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (nS skolem-const-decl "{rS | pureRedex?(rS`redex)}" iareduction
     nil)
    (letReduce_ndr judgement-tcc nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil iareduction nil)
    (Defs type-eq-decl nil iareduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (variableReduce_ndr judgement-tcc nil rreduction nil)
    (make_redex_ndr judgement-tcc nil rreduction nil)
    (grS skolem-const-decl "{grS | noDanglingRefs?(grS)}" iareduction
     nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureRedex? const-decl "bool" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil))
   nil
   (iareduce_ndr subtype "iareduce(D)(grS)"
    "(rreduction.noDanglingRefs?)")))
 (iapply_nstack_iterm_TCC1 0
  (iapply_nstack_iterm_TCC1-1 nil 3706461701
   ("" (skeep* :preds? t) (("" (grind) nil nil)) nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (some adt-def-decl "boolean" list_adt nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (value? const-decl "bool" IL nil)
    (every adt-def-decl "boolean" list_adt nil)
    (length def-decl "nat" list_props nil))
   nil
   (iapply_nstack_iterm subtype "args"
    "(cons?[(IExpression_adt.variable?)])")))
 (iapply_nstack_iterm_TCC2 0
  (iapply_nstack_iterm_TCC2-1 nil 3706461701 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack_iterm subtype "y" "(IExpression_adt.variable?)")))
 (iapply_nstack_iterm_TCC3 0
  (iapply_nstack_iterm_TCC3-1 nil 3706461701 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack_iterm subtype
    "y WITH [`index := IExpression_adt.index(y) + 1]"
    "(IExpression_adt.variable?)")))
 (iapply_nstack_iterm_TCC4 0
  (iapply_nstack_iterm_TCC4-1 nil 3706468809
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (rewrite map_length)
        (("1" (expand length 1 2)
          (("1" (lift-if)
            (("1" (split) (("1" (grind) nil nil) ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skeep)
        (("2" (inst -8 "i-1")
          (("1" (expand in_varlist)
            (("1" (rewrite some_map)
              (("1" (expand o)
                (("1" (rewrite some_nth)
                  (("1" (rewrite some_nth)
                    (("1" (skeep)
                      (("1" (split)
                        (("1" (grind) nil nil)
                         ("2" (inst 1 "i_1+1")
                          (("1" (grind) nil nil)
                           ("2" (expand length 1)
                            (("2" (lift-if)
                              (("2"
                                (split)
                                (("1" (grind) nil nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((injective? const-decl "bool" functions nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (map_length formula-decl nil more_map_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (TRUE const-decl "bool" booleans nil)
    (i skolem-const-decl "nat" iareduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (some_map formula-decl nil finseq_theorems nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (k skolem-const-decl "nat" iareduction nil)
    (dom skolem-const-decl "finite_set[nat]" iareduction nil)
    (S skolem-const-decl "{S | every(domainValue?(dom))(S)}"
     iareduction nil)
    (args skolem-const-decl "{args: list[(variable?)] |
   k <= 2 * length(args) AND
    FORALL i: in_varlist(args)(i) IMPLIES i < S`length}" iareduction
          nil)
    (below type-eq-decl nil naturalnumbers nil)
    (i_1 skolem-const-decl "below(length(cdr[(variable?)](args)))"
     iareduction nil)
    (nth def-decl "T" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (O const-decl "T3" function_props nil))
   nil
   (iapply_nstack_iterm subtype
    "list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA y: y WITH [(IExpression_adt.index) := IExpression_adt.index(y) + 1])(list_adt[(IExpression_adt.variable?)].cdr(args))"
    "{L | list_props[(IExpression_adt.variable?)].length(L) = list_props[(IExpression_adt.variable?)].length(args) - 1 AND FORALL i: IL.in_varlist(L)(i) IMPLIES i < 1 + S`length}")))
 (iapply_nstack_iterm_TCC5 0
  (iapply_nstack_iterm_TCC5-1 nil 3706461701
   ("" (skeep* :preds? t)
    (("" (inst -10 "index(car(args))")
      (("" (split)
        (("1" (grind) nil nil)
         ("2" (expand in_varlist)
          (("2" (rewrite some_nth)
            (("2" (inst 1 0)
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (k skolem-const-decl "nat" iareduction nil)
    (dom skolem-const-decl "finite_set[nat]" iareduction nil)
    (S skolem-const-decl "{S | every(domainValue?(dom))(S)}"
     iareduction nil)
    (args skolem-const-decl "{args: list[(variable?)] |
   k <= 2 * length(args) AND
    FORALL i: in_varlist(args)(i) IMPLIES i < S`length}" iareduction
          nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (injective? const-decl "bool" functions nil))
   nil
   (iapply_nstack_iterm subtype
    "S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))"
    "below[S`length]")))
 (iapply_nstack_iterm_TCC6 0
  (iapply_nstack_iterm_TCC6-1 nil 3706461701 ("" (subtype-tcc) nil nil)
   ((value? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack_iterm subtype "IExpression_adt.nil" "(IL.value?)")))
 (iapply_nstack_iterm_TCC7 0
  (iapply_nstack_iterm_TCC7-1 nil 3706469505 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (args!1 skolem-const-decl "{args: list[(variable?)] |
   k!1 <= 2 * length(args) AND
    FORALL i: in_varlist(args)(i) IMPLIES i < S!1`length}" iareduction
     nil)
    (S!1 skolem-const-decl "{S | every(domainValue?(dom!1))(S)}"
     iareduction nil)
    (k!1 skolem-const-decl "nat" iareduction nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (dom!1 skolem-const-decl "finite_set[nat]" iareduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (injective? const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (below type-eq-decl nil naturalnumbers nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack_iterm subtype
    "S WITH [`seq(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil]"
    "{S1 | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(S1)}")))
 (iapply_nstack_iterm_TCC8 0
  (iapply_nstack_iterm_TCC8-1 nil 3706466448
   ("" (skeep* :preds? t)
    (("" (case "domainValue?(dom)(u)")
      (("1" (expand every)
        (("1" (skeep :preds? t)
          (("1" (expand* push add)
            (("1" (lift-if)
              (("1" (split +)
                (("1" (grind) nil nil)
                 ("2" (flatten) (("2" (inst? -3) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand every)
        (("2" (inst? -8)
          (("1" (assert) nil nil)
           ("2" (inst -10 "index(car(args))")
            (("2" (split)
              (("1" (grind) nil nil)
               ("2" (expand in_varlist)
                (("2" (rewrite some_nth)
                  (("2" (inst 1 0)
                    (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil naturalnumbers nil)
    (push const-decl "Stack" IL nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (every const-decl "bool" finseq_theorems nil)
    (every adt-def-decl "boolean" list_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (args skolem-const-decl "{args: list[(variable?)] |
   k <= 2 * length(args) AND
    FORALL i: in_varlist(args)(i) IMPLIES i < S`length}" iareduction
          nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (k skolem-const-decl "nat" iareduction nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (S skolem-const-decl "{S | every(domainValue?(dom))(S)}"
     iareduction nil)
    (dom skolem-const-decl "finite_set[nat]" iareduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (nth def-decl "T" list_props nil))
   nil
   (iapply_nstack_iterm subtype "IL.push(u, nstack1)"
    "{S1 | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(S1)}")))
 (iapply_nstack_iterm_TCC9 0
  (iapply_nstack_iterm_TCC8-1 nil 3706461701
   ("" (skeep* :preds? t)
    (("" (expand every -9)
      (("" (inst? -9)
        (("1" (grind) nil nil)
         ("2" (inst -11 "index(car(args))")
          (("2" (split)
            (("1" (grind) nil nil)
             ("2" (expand in_varlist)
              (("2" (rewrite some_nth)
                (("2" (inst 1 0)
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((every const-decl "bool" finseq_theorems nil)
    (nth def-decl "T" list_props nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (push const-decl "Stack" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (dom skolem-const-decl "finite_set[nat]" iareduction nil)
    (S skolem-const-decl "{S | every(domainValue?(dom))(S)}"
     iareduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (k skolem-const-decl "nat" iareduction nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (args skolem-const-decl "{args: list[(variable?)] |
   k <= 2 * length(args) AND
    FORALL i: in_varlist(args)(i) IMPLIES i < S`length}" iareduction
          nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (iapply_nstack_iterm subtype "IExpression_adt.refindex(u)"
    "(dom)")))
 (iapply_nstack_iterm_TCC10 0
  (iapply_nstack_iterm_TCC9-1 nil 3706461701 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (Stack type-eq-decl nil IL nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (injective? const-decl "bool" functions nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (push const-decl "Stack" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil (iapply_nstack_iterm subtype "k - 2" "nat")))
 (iapply_nstack_iterm_TCC11 0
  (iapply_nstack_iterm_TCC11-1 nil 3706466448
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (Stack type-eq-decl nil IL nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (push const-decl "Stack" IL nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack_iterm subtype "nargs"
    "{args: list[(IExpression_adt.variable?)] | k - 2 <= 2 * list_props[(IExpression_adt.variable?)].length(args) AND FORALL i: IL.in_varlist(args)(i) IMPLIES i < nstack`length}")))
 (iapply_nstack_iterm_TCC12 0
  (iapply_nstack_iterm_TCC11-1 nil 3706461701
   ("" (termination-tcc) nil nil)
   ((add const-decl "finseq[T]" more_finseq nil)
    (push const-decl "Stack" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack_iterm termination
    "iapply_nstack_iterm(k - 2, dom, nstack, nargs, A, ncnt)" "nil")))
 (iapply_nstack_iterm_TCC13 0
  (iapply_nstack_iterm_TCC12-1 nil 3706461701
   ("" (skeep* :preds? t) (("" (grind) nil nil)) nil)
   ((mult_divides2 application-judgement "(divides(m))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (some adt-def-decl "boolean" list_adt nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (length def-decl "nat" list_props nil)
    (every adt-def-decl "boolean" list_adt nil))
   nil
   (iapply_nstack_iterm subtype "args"
    "(cons?[(IExpression_adt.variable?)])")))
 (iapply_nstack_iterm_TCC14 0
  (iapply_nstack_iterm_TCC13-1 nil 3706461701
   ("" (skeep* :preds? t)
    (("" (inst -6 "index(car(args))")
      (("1" (split)
        (("1" (grind) nil nil)
         ("2" (expand in_varlist)
          (("2" (rewrite some_nth)
            (("1" (inst 1 0)
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   ((args skolem-const-decl "{args: list[(variable?)] |
   k <= 2 * length(args) AND
    FORALL i: in_varlist(args)(i) IMPLIES i < S`length}" iareduction
          nil)
    (S skolem-const-decl "{S | every(domainValue?(dom))(S)}"
     iareduction nil)
    (dom skolem-const-decl "finite_set[nat]" iareduction nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (k skolem-const-decl "nat" iareduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (some adt-def-decl "boolean" list_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (injective? const-decl "bool" functions nil))
   nil
   (iapply_nstack_iterm subtype
    "S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))"
    "below[S`length]")))
 (state_matches?_TCC1 0
  (state_matches?_TCC1-1 nil 3706456701 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (state_matches? subtype "rS2`store" "reduction.Store(rS1`domain)")))
 (apply_iterm_match_TCC1 0
  (apply_iterm_match_TCC1-1 nil 3706462664 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (Stack type-eq-decl nil IL nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (injective? const-decl "bool" functions nil))
   nil (apply_iterm_match subtype "str" "reduction.Store(rS`domain)")))
 (apply_iterm_match_TCC2 0
  (apply_iterm_match_TCC2-1 nil 3706462664 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (Stack type-eq-decl nil IL nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (in_varlist const-decl "finite_set[nat]" IL nil))
   nil
   (apply_iterm_match subtype "L"
    "{args: list[(IExpression_adt.variable?)] | 2 * k <= list_props[(IExpression_adt.variable?)].length(args) AND FORALL i: IL.in_varlist(args)(i) IMPLIES i < S`length}")))
 (applyReduce_match_rec_TCC1 0
  (applyReduce_match_rec_TCC1-1 nil 3706461701
   ("" (subtype-tcc) nil nil) nil nil
   (applyReduce_match_rec subtype "grS`redex"
    "(IExpression_adt.application?)")))
 (applyReduce_match_rec_TCC2 0
  (applyReduce_match_rec_TCC2-1 nil 3706462664
   ("" (subtype-tcc) nil nil)
   ((apply_iterm_match const-decl "bool" iareduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (applyReduce_match_rec subtype "k + 1"
    "upto(2 * list_props[(IExpression_adt.variable?)].length(L))")))
 (applyReduce_match_rec_TCC3 0
  (applyReduce_match_rec_TCC3-1 nil 3706533808
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (Stack type-eq-decl nil IL nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil) (refs def-decl "bool" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (apply_iterm_match const-decl "bool" iareduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (applyReduce_match_rec subtype "rS"
    "{grS | rreduction.noDanglingRefs?(rreduction.grS)}")))
 (applyReduce_match_rec 0
  (applyReduce_match_rec-3 "" 3706618046
   ("" (measure-induct+ "k" ("k"))
    (("1" (name-replace "k" "x!1")
      (("1" (case-replace "k = 0")
        (("1" (hide -2)
          (("1" (skeep* :preds? t)
            (("1" (expand apply_iterm_match)
              (("1" (flatten)
                (("1" (expand iapply_nstack_iterm)
                  (("1" (expand rreduction.letApply -)
                    (("1" (rewrite map_length)
                      (("1"
                        (case-replace "length(cdr(L)) = length(L) - 1")
                        (("1"
                          (name-replace "B"
                           "rreduction.letApply(length(L) - 1,
                                                      map(LAMBDA
                                                          x:
                                                          x WITH [`index := 1 + index(x)])
                                                         (cdr(L)),
                                                      A)")
                          (("1" (case "vars(B)(0)")
                            (("1" (assert)
                              (("1"
                                (case-replace
                                 "fill(K, letexpr(car(L), B)) = fill(compose(K, letc(hole, B)), car(L))")
                                (("1"
                                  (expand reduce)
                                  (("1"
                                    (case
                                     "value?(to_topstate(rS)`redex)")
                                    (("1"
                                      (hide 2)
                                      (("1"
                                        (expand to_topstate)
                                        (("1"
                                          (replace -18)
                                          (("1"
                                            (use not_value_redex_fill)
                                            (("1" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (assert)
                                      (("2"
                                        (lift-if)
                                        (("2"
                                          (expand make_redex)
                                          (("2"
                                            (expand to_topstate)
                                            (("2"
                                              (replace -17)
                                              (("2"
                                                (rewrite
                                                 buildRedex_fill)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (expand
                                                     variableReduce)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (expand get)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (split)
                                                            (("1"
                                                              (lift-if)
                                                              (("1"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (lift-if)
                                                              (("2"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil)
                                                             ("3"
                                                              (rewrite
                                                               context_composition)
                                                              (("1"
                                                                (grind)
                                                                nil
                                                                nil)
                                                               ("2"
                                                                (inst
                                                                 -9
                                                                 "index(car(L))")
                                                                (("2"
                                                                  (split)
                                                                  (("1"
                                                                    (grind)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (expand
                                                                     in_varlist)
                                                                    (("2"
                                                                      (rewrite
                                                                       some_nth)
                                                                      (("2"
                                                                        (inst
                                                                         1
                                                                         0)
                                                                        (("2"
                                                                          (grind)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (hide 4)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (rewrite context_composition)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (delete 3)
                              (("2"
                                (expand B)
                                (("2"
                                  (rewrite vars_letApply)
                                  (("2"
                                    (flatten)
                                    (("2"
                                      (inst -8 "length(L) - 1")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (rewrite map_length) nil nil))
                          nil)
                         ("2" (expand length 1 2)
                          (("2" (lift-if)
                            (("2" (split 1)
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("3" (grind) nil nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (case-replace "k = 1")
          (("1" (hide -2)
            (("1" (skeep* :preds? t)
              (("1" (expand apply_iterm_match)
                (("1" (expand iapply_nstack_iterm)
                  (("1" (assert)
                    (("1" (expand iapply_nstack_iterm)
                      (("1"
                        (name-replace B "rreduction.letApply
                                                  (length(map(LAMBDA
                                                              y:
                                                              y WITH [`index := 1 + index(y)])
                                                             (cdr(L))),
                                                   map(LAMBDA y: y WITH [`index := 1 + index(y)])
                                                      (cdr(L)),
                                                   A)")
                        (("1"
                          (with-labels (flatten)
                           ((err dom stom stam cnt rdx)))
                          (("1" (replace stam :dir RL)
                            (("1" (replace cnt :dir RL)
                              (("1"
                                (expand reduce)
                                (("1"
                                  (lift-if)
                                  (("1"
                                    (case
                                     "value?(to_topstate(rS)`redex)")
                                    (("1"
                                      (hide 3)
                                      (("1"
                                        (expand to_topstate)
                                        (("1"
                                          (replace rdx)
                                          (("1"
                                            (lemma
                                             not_value_redex_fill)
                                            (("1"
                                              (inst? :where -2)
                                              (("1" (grind) nil nil)
                                               ("2"
                                                (inst
                                                 -7
                                                 "index(car(L))")
                                                (("2"
                                                  (split)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (expand in_varlist)
                                                    (("2"
                                                      (rewrite
                                                       some_nth)
                                                      (("2"
                                                        (inst 1 0)
                                                        (("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (assert)
                                      (("2"
                                        (expand to_topstate)
                                        (("2"
                                          (expand make_redex)
                                          (("2"
                                            (replace rdx)
                                            (("2"
                                              (rewrite buildRedex_fill)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (case
                                                   "pureLetRedex?(letexpr(S`seq(S`length - 1 - index(car(L))), B))")
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (expand
                                                       letReduce)
                                                      (("1"
                                                        (propax)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (hide 5)
                                                    (("2"
                                                      (expand
                                                       pureLetRedex?)
                                                      (("2"
                                                        (expand
                                                         letRedex?)
                                                        (("2"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("3"
                                                    (hide 5)
                                                    (("3"
                                                      (assert)
                                                      (("3"
                                                        (inst
                                                         -6
                                                         "index(car(L))")
                                                        (("3"
                                                          (split)
                                                          (("1"
                                                            (grind)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (expand
                                                             in_varlist)
                                                            (("2"
                                                              (rewrite
                                                               some_nth)
                                                              (("2"
                                                                (inst
                                                                 1
                                                                 0)
                                                                (("2"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (hide 5)
                                                (("2"
                                                  (expand redex?)
                                                  (("2"
                                                    (expand letRedex?)
                                                    (("2"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("3"
                                                (hide 5)
                                                (("3"
                                                  (inst
                                                   -6
                                                   "index(car(L))")
                                                  (("3"
                                                    (split)
                                                    (("1"
                                                      (grind)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (expand
                                                       in_varlist)
                                                      (("2"
                                                        (rewrite
                                                         some_nth)
                                                        (("2"
                                                          (inst 1 0)
                                                          (("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (inst -1 "k-2")
            (("1"
              (with-labels (skeep* :preds? t)
               ((apure domf sdom varl kbnd vari avar ndr k0 k1 hrec
                 apph obj)))
              (("1" (expand apply_iterm_match)
                (("1" (expand iapply_nstack_iterm +)
                  (("1" (assert)
                    (("1" (inst? hrec)
                      (("1" (inst hrec "compose(K, popc(hole))" "str")
                        (("1" (split)
                          (("1" (flatten)
                            (("1" (assert)
                              (("1"
                                (split)
                                (("1" (propax) nil nil)
                                 ("2" (propax) nil nil)
                                 ("3"
                                  (rewrite context_composition)
                                  (("1"
                                    (expand fill hrec 3)
                                    (("1"
                                      (expand fill hrec 3)
                                      (("1" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (delete obj)
                                    (("2"
                                      (flatten)
                                      (("2"
                                        (expand every sdom)
                                        (("2"
                                          (inst
                                           sdom
                                           "S`length - 1 - index(car(L))")
                                          (("1"
                                            (expand domainValue?)
                                            (("1" (assert) nil nil))
                                            nil)
                                           ("2"
                                            (inst vari "index(car(L))")
                                            (("2"
                                              (split)
                                              (("1" (grind) nil nil)
                                               ("2"
                                                (expand in_varlist)
                                                (("2"
                                                  (rewrite some_nth)
                                                  (("2"
                                                    (inst 1 0)
                                                    (("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("3"
                                    (delete obj)
                                    (("3"
                                      (inst vari "index(car(L))")
                                      (("3"
                                        (split)
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (expand in_varlist)
                                          (("2"
                                            (rewrite some_nth)
                                            (("2"
                                              (inst 1 0)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("4"
                                    (delete obj)
                                    (("4" (grind) nil nil))
                                    nil)
                                   ("5"
                                    (delete obj)
                                    (("5"
                                      (inst vari "index(car(L))")
                                      (("5"
                                        (split)
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (expand in_varlist)
                                          (("2"
                                            (rewrite some_nth)
                                            (("2"
                                              (inst 1 0)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("6"
                                    (delete obj)
                                    (("6"
                                      (inst vari "index(car(L))")
                                      (("6"
                                        (split)
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (expand in_varlist)
                                          (("2"
                                            (rewrite some_nth)
                                            (("2"
                                              (inst 1 0)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (delete obj) (("2" (grind) nil nil))
                            nil)
                           ("3" (delete obj) (("3" (grind) nil nil))
                            nil)
                           ("4" (delete obj) (("4" (grind) nil nil))
                            nil)
                           ("5" (delete obj)
                            (("5" (flatten)
                              (("5"
                                (expand iapply_nstack_iterm apph)
                                (("5" (propax) nil nil))
                                nil))
                              nil))
                            nil)
                           ("6" (delete obj)
                            (("6" (flatten)
                              (("6"
                                (expand iapply_nstack_iterm apph)
                                (("6" (propax) nil nil))
                                nil))
                              nil))
                            nil)
                           ("7" (delete obj)
                            (("7" (flatten)
                              (("7"
                                (expand iapply_nstack_iterm apph)
                                (("7"
                                  (rewrite context_composition)
                                  (("1"
                                    (expand fill hrec 3)
                                    (("1"
                                      (expand fill hrec 3)
                                      (("1" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (delete hrec)
                                    (("2"
                                      (flatten)
                                      (("2"
                                        (expand every sdom)
                                        (("2"
                                          (inst
                                           sdom
                                           "S`length - 1 - index(car(L))")
                                          (("1" (grind) nil nil)
                                           ("2"
                                            (inst vari "index(car(L))")
                                            (("2"
                                              (split)
                                              (("1" (grind) nil nil)
                                               ("2"
                                                (expand in_varlist)
                                                (("2"
                                                  (rewrite some_nth)
                                                  (("2"
                                                    (inst 1 0)
                                                    (("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("3"
                                    (delete hrec)
                                    (("3"
                                      (inst vari "index(car(L))")
                                      (("3"
                                        (split)
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (expand in_varlist)
                                          (("2"
                                            (rewrite some_nth)
                                            (("2"
                                              (inst 1 0)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("4"
                                    (delete hrec)
                                    (("4" (grind) nil nil))
                                    nil)
                                   ("5"
                                    (delete hrec)
                                    (("5"
                                      (inst vari "index(car(L))")
                                      (("5"
                                        (split)
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (expand in_varlist)
                                          (("2"
                                            (rewrite some_nth)
                                            (("2"
                                              (inst 1 0)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("6"
                                    (delete hrec)
                                    (("6"
                                      (inst vari "index(car(L))")
                                      (("6"
                                        (split)
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (expand in_varlist)
                                          (("2"
                                            (rewrite some_nth)
                                            (("2"
                                              (inst 1 0)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (delete obj)
                        (("2" (flatten)
                          (("2" (expand every sdom)
                            (("2"
                              (inst sdom
                               "S`length - 1 - index(car(L))")
                              (("1" (grind) nil nil)
                               ("2"
                                (inst vari "index(car(L))")
                                (("2"
                                  (split)
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (expand in_varlist)
                                    (("2"
                                      (rewrite some_nth)
                                      (("2"
                                        (inst 1 0)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (delete obj)
                        (("3" (inst vari "index(car(L))")
                          (("3" (split)
                            (("1" (grind) nil nil)
                             ("2" (expand in_varlist)
                              (("2"
                                (rewrite some_nth)
                                (("2"
                                  (inst 1 0)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("4" (delete obj) (("4" (grind) nil nil)) nil)
                       ("5" (delete obj)
                        (("5" (split)
                          (("1" (rewrite map_length)
                            (("1" (expand length kbnd)
                              (("1"
                                (lift-if kbnd)
                                (("1"
                                  (split kbnd)
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (expand k)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (skeep* :preds? t)
                            (("2" (expand push)
                              (("2"
                                (expand add)
                                (("2"
                                  (assert)
                                  (("2"
                                    (expand in_varlist)
                                    (("2"
                                      (rewrite some_map)
                                      (("2"
                                        (expand o)
                                        (("2"
                                          (inst vari "i-1")
                                          (("2"
                                            (split vari)
                                            (("1" (grind) nil nil)
                                             ("2"
                                              (expand some vari)
                                              (("2"
                                                (lift-if)
                                                (("2"
                                                  (split)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (rewrite
                                                       some_nth)
                                                      (("2"
                                                        (rewrite
                                                         some_nth)
                                                        (("2"
                                                          (skeep)
                                                          (("2"
                                                            (inst?)
                                                            (("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("3" (skeep* :preds? t)
                            (("3" (rewrite map_length)
                              (("3"
                                (inst avar i)
                                (("3"
                                  (split)
                                  (("1" (propax) nil nil)
                                   ("2"
                                    (expand length avar)
                                    (("2"
                                      (lift-if)
                                      (("2"
                                        (split)
                                        (("1" (grind) nil nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("6" (delete obj)
                        (("6" (expand push)
                          (("6" (expand every +)
                            (("6" (skeep :preds? t)
                              (("6"
                                (expand add)
                                (("6"
                                  (lift-if)
                                  (("6"
                                    (split)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (lift-if)
                                          (("1"
                                            (split)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (expand every)
                                                (("1"
                                                  (inst?)
                                                  (("1"
                                                    (inst
                                                     vari
                                                     "index(car(L))")
                                                    (("1"
                                                      (split)
                                                      (("1"
                                                        (grind)
                                                        nil
                                                        nil)
                                                       ("2"
                                                        (expand
                                                         in_varlist)
                                                        (("2"
                                                          (rewrite
                                                           some_nth)
                                                          (("2"
                                                            (inst 1 0)
                                                            (("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (split)
                                                (("1" (grind) nil nil)
                                                 ("2"
                                                  (flatten)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (lift-if)
                                        (("2"
                                          (split 2)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (expand every sdom)
                                              (("1"
                                                (inst?)
                                                (("1"
                                                  (inst
                                                   vari
                                                   "index(car(L))")
                                                  (("1"
                                                    (split vari)
                                                    (("1"
                                                      (grind)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (expand
                                                       in_varlist)
                                                      (("2"
                                                        (rewrite
                                                         some_nth)
                                                        (("2"
                                                          (inst 1 0)
                                                          (("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("7" (delete obj) (("7" (grind) nil nil)) nil)
                       ("8" (delete obj)
                        (("8" (inst vari "index(car(L))")
                          (("8" (split)
                            (("1" (grind) nil nil)
                             ("2" (expand in_varlist)
                              (("2"
                                (rewrite some_nth)
                                (("2"
                                  (inst 1 0)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("9" (delete obj) (("9" (grind) nil nil)) nil)
                       ("10" (delete obj) (("10" (grind) nil nil)) nil)
                       ("11" (delete obj)
                        (("11" (inst vari "index(car(L))")
                          (("1" (split vari)
                            (("1" (grind) nil nil)
                             ("2" (expand in_varlist)
                              (("2"
                                (rewrite some_nth)
                                (("1"
                                  (inst 1 0)
                                  (("1" (grind) nil nil))
                                  nil)
                                 ("2"
                                  (skeep)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil)
                       ("12" (delete obj) (("12" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (expand apply_iterm_match) (("2" (assert) nil nil)) nil)
     ("3" (expand apply_iterm_match) (("3" (assert) nil nil)) nil))
    nil)
   nil shostak)
  (applyReduce_match_rec-2 nil 3706470408
   ("" (measure-induct+ "k" ("k"))
    (("1" (name-replace "k" "x!1")
      (("1" (case-replace "k = 0")
        (("1" (hide -2)
          (("1" (skeep* :preds? t)
            (("1" (expand apply_iterm_match)
              (("1" (flatten)
                (("1" (expand iapply_nstack_iterm)
                  (("1" (expand rreduction.letApply -)
                    (("1" (rewrite map_length)
                      (("1"
                        (case-replace "length(cdr(L)) = length(L) - 1")
                        (("1"
                          (name-replace "B"
                           "rreduction.letApply(length(L) - 1,
                                                      map(LAMBDA
                                                          x:
                                                          x WITH [`index := 1 + index(x)])
                                                         (cdr(L)),
                                                      A)")
                          (("1" (case "vars(B)(0)")
                            (("1" (assert)
                              (("1"
                                (case-replace
                                 "fill(K, letexpr(car(L), B)) = fill(compose(K, letc(hole, B)), car(L))")
                                (("1"
                                  (expand reduce)
                                  (("1"
                                    (case
                                     "value?(to_topstate(rS)`redex)")
                                    (("1"
                                      (hide 2)
                                      (("1"
                                        (expand to_topstate)
                                        (("1"
                                          (replace -18)
                                          (("1"
                                            (use not_value_redex_fill)
                                            (("1" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (assert)
                                      (("2"
                                        (lift-if)
                                        (("2"
                                          (expand make_redex)
                                          (("2"
                                            (expand to_topstate)
                                            (("2"
                                              (replace -17)
                                              (("2"
                                                (rewrite
                                                 buildRedex_fill)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (expand
                                                     variableReduce)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (expand get)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (split)
                                                            (("1"
                                                              (lift-if)
                                                              (("1"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (lift-if)
                                                              (("2"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil)
                                                             ("3"
                                                              (rewrite
                                                               context_composition)
                                                              (("1"
                                                                (grind)
                                                                nil
                                                                nil)
                                                               ("2"
                                                                (inst
                                                                 -9
                                                                 "index(car(L))")
                                                                (("2"
                                                                  (split)
                                                                  (("1"
                                                                    (grind)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (expand
                                                                     in_varlist)
                                                                    (("2"
                                                                      (rewrite
                                                                       some_nth)
                                                                      (("2"
                                                                        (inst
                                                                         1
                                                                         0)
                                                                        (("2"
                                                                          (grind)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (hide 4)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (rewrite context_composition)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (delete 3)
                              (("2"
                                (expand B)
                                (("2"
                                  (rewrite vars_letApply)
                                  (("2"
                                    (flatten)
                                    (("2"
                                      (inst -8 "length(L) - 1")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (rewrite map_length) nil nil))
                          nil)
                         ("2" (expand length 1 2)
                          (("2" (lift-if)
                            (("2" (split 1)
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("3" (grind) nil nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (case-replace "k = 1")
          (("1" (hide -2)
            (("1" (skeep* :preds? t)
              (("1" (expand apply_iterm_match)
                (("1" (expand iapply_nstack_iterm)
                  (("1" (assert)
                    (("1" (expand iapply_nstack_iterm)
                      (("1"
                        (name-replace B "rreduction.letApply
                                                  (length(map(LAMBDA
                                                              y:
                                                              y WITH [`index := 1 + index(y)])
                                                             (cdr(L))),
                                                   map(LAMBDA y: y WITH [`index := 1 + index(y)])
                                                      (cdr(L)),
                                                   A)")
                        (("1"
                          (with-labels (flatten)
                           ((err dom stom stam cnt rdx)))
                          (("1" (replace stam :dir RL)
                            (("1" (replace cnt :dir RL)
                              (("1"
                                (expand reduce)
                                (("1"
                                  (lift-if)
                                  (("1"
                                    (case
                                     "value?(to_topstate(rS)`redex)")
                                    (("1"
                                      (hide 3)
                                      (("1"
                                        (expand to_topstate)
                                        (("1"
                                          (replace rdx)
                                          (("1"
                                            (lemma
                                             not_value_redex_fill)
                                            (("1"
                                              (inst? :where -2)
                                              (("1" (grind) nil nil)
                                               ("2"
                                                (inst
                                                 -7
                                                 "index(car(L))")
                                                (("2"
                                                  (split)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (expand in_varlist)
                                                    (("2"
                                                      (rewrite
                                                       some_nth)
                                                      (("2"
                                                        (inst 1 0)
                                                        (("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (assert)
                                      (("2"
                                        (expand to_topstate)
                                        (("2"
                                          (expand make_redex)
                                          (("2"
                                            (replace rdx)
                                            (("2"
                                              (rewrite buildRedex_fill)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (case
                                                   "pureLetRedex?(letexpr(S`seq(S`length - 1 - index(car(L))), B))")
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (expand
                                                       letReduce)
                                                      (("1"
                                                        (propax)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (hide 5)
                                                    (("2"
                                                      (expand
                                                       pureLetRedex?)
                                                      (("2"
                                                        (expand
                                                         letRedex?)
                                                        (("2"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("3"
                                                    (hide 5)
                                                    (("3"
                                                      (assert)
                                                      (("3"
                                                        (inst
                                                         -6
                                                         "index(car(L))")
                                                        (("3"
                                                          (split)
                                                          (("1"
                                                            (grind)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (expand
                                                             in_varlist)
                                                            (("2"
                                                              (rewrite
                                                               some_nth)
                                                              (("2"
                                                                (inst
                                                                 1
                                                                 0)
                                                                (("2"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (hide 5)
                                                (("2"
                                                  (expand redex?)
                                                  (("2"
                                                    (expand letRedex?)
                                                    (("2"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("3"
                                                (hide 5)
                                                (("3"
                                                  (inst
                                                   -6
                                                   "index(car(L))")
                                                  (("3"
                                                    (split)
                                                    (("1"
                                                      (grind)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (expand
                                                       in_varlist)
                                                      (("2"
                                                        (rewrite
                                                         some_nth)
                                                        (("2"
                                                          (inst 1 0)
                                                          (("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (inst -1 "k-2")
            (("1"
              (with-labels (skeep* :preds? t)
               ((apure domf sdom varl kbnd vari avar ndr k0 k1 hrec
                 apph obj)))
              (("1" (expand apply_iterm_match)
                (("1" (expand iapply_nstack_iterm +)
                  (("1" (assert)
                    (("1" (inst? hrec)
                      (("1" (inst hrec "compose(K, popc(hole))" "str")
                        (("1" (split)
                          (("1" (flatten)
                            (("1" (assert)
                              (("1"
                                (split)
                                (("1" (propax) nil nil)
                                 ("2" (propax) nil nil)
                                 ("3"
                                  (rewrite context_composition)
                                  (("1"
                                    (expand fill hrec 3)
                                    (("1"
                                      (expand fill hrec 3)
                                      (("1" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (delete obj)
                                    (("2"
                                      (flatten)
                                      (("2"
                                        (expand every sdom)
                                        (("2"
                                          (inst
                                           sdom
                                           "S`length - 1 - index(car(L))")
                                          (("1"
                                            (expand domainValue?)
                                            (("1" (assert) nil nil))
                                            nil)
                                           ("2"
                                            (inst vari "index(car(L))")
                                            (("2"
                                              (split)
                                              (("1" (grind) nil nil)
                                               ("2"
                                                (expand in_varlist)
                                                (("2"
                                                  (rewrite some_nth)
                                                  (("2"
                                                    (inst 1 0)
                                                    (("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("3"
                                    (delete obj)
                                    (("3"
                                      (inst vari "index(car(L))")
                                      (("3"
                                        (split)
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (expand in_varlist)
                                          (("2"
                                            (rewrite some_nth)
                                            (("2"
                                              (inst 1 0)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("4"
                                    (delete obj)
                                    (("4" (grind) nil nil))
                                    nil)
                                   ("5"
                                    (delete obj)
                                    (("5"
                                      (inst vari "index(car(L))")
                                      (("5"
                                        (split)
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (expand in_varlist)
                                          (("2"
                                            (rewrite some_nth)
                                            (("2"
                                              (inst 1 0)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("6"
                                    (delete obj)
                                    (("6"
                                      (inst vari "index(car(L))")
                                      (("6"
                                        (split)
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (expand in_varlist)
                                          (("2"
                                            (rewrite some_nth)
                                            (("2"
                                              (inst 1 0)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (delete obj) (("2" (grind) nil nil))
                            nil)
                           ("3" (delete obj) (("3" (grind) nil nil))
                            nil)
                           ("4" (delete obj) (("4" (grind) nil nil))
                            nil)
                           ("5" (delete obj)
                            (("5" (flatten)
                              (("5"
                                (expand iapply_nstack_iterm apph)
                                (("5" (propax) nil nil))
                                nil))
                              nil))
                            nil)
                           ("6" (delete obj)
                            (("6" (flatten)
                              (("6"
                                (expand iapply_nstack_iterm apph)
                                (("6" (propax) nil nil))
                                nil))
                              nil))
                            nil)
                           ("7" (delete obj)
                            (("7" (flatten)
                              (("7"
                                (expand iapply_nstack_iterm apph)
                                (("7"
                                  (rewrite context_composition)
                                  (("1"
                                    (expand fill hrec 3)
                                    (("1"
                                      (expand fill hrec 3)
                                      (("1" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (delete hrec)
                                    (("2"
                                      (flatten)
                                      (("2"
                                        (expand every sdom)
                                        (("2"
                                          (inst
                                           sdom
                                           "S`length - 1 - index(car(L))")
                                          (("1" (grind) nil nil)
                                           ("2"
                                            (inst vari "index(car(L))")
                                            (("2"
                                              (split)
                                              (("1" (grind) nil nil)
                                               ("2"
                                                (expand in_varlist)
                                                (("2"
                                                  (rewrite some_nth)
                                                  (("2"
                                                    (inst 1 0)
                                                    (("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("3"
                                    (delete hrec)
                                    (("3"
                                      (inst vari "index(car(L))")
                                      (("3"
                                        (split)
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (expand in_varlist)
                                          (("2"
                                            (rewrite some_nth)
                                            (("2"
                                              (inst 1 0)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("4"
                                    (delete hrec)
                                    (("4" (grind) nil nil))
                                    nil)
                                   ("5"
                                    (delete hrec)
                                    (("5"
                                      (inst vari "index(car(L))")
                                      (("5"
                                        (split)
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (expand in_varlist)
                                          (("2"
                                            (rewrite some_nth)
                                            (("2"
                                              (inst 1 0)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("6"
                                    (delete hrec)
                                    (("6"
                                      (inst vari "index(car(L))")
                                      (("6"
                                        (split)
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (expand in_varlist)
                                          (("2"
                                            (rewrite some_nth)
                                            (("2"
                                              (inst 1 0)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (delete obj)
                        (("2" (flatten)
                          (("2" (expand every sdom)
                            (("2"
                              (inst sdom
                               "S`length - 1 - index(car(L))")
                              (("1" (grind) nil nil)
                               ("2"
                                (inst vari "index(car(L))")
                                (("2"
                                  (split)
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (expand in_varlist)
                                    (("2"
                                      (rewrite some_nth)
                                      (("2"
                                        (inst 1 0)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (delete obj)
                        (("3" (inst vari "index(car(L))")
                          (("3" (split)
                            (("1" (grind) nil nil)
                             ("2" (expand in_varlist)
                              (("2"
                                (rewrite some_nth)
                                (("2"
                                  (inst 1 0)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("4" (delete obj) (("4" (grind) nil nil)) nil)
                       ("5" (delete obj)
                        (("5" (split)
                          (("1" (rewrite map_length)
                            (("1" (expand length kbnd)
                              (("1"
                                (lift-if kbnd)
                                (("1"
                                  (split kbnd)
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (expand k)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (skeep* :preds? t)
                            (("2" (expand push)
                              (("2"
                                (expand add)
                                (("2"
                                  (assert)
                                  (("2"
                                    (expand in_varlist)
                                    (("2"
                                      (rewrite some_map)
                                      (("2"
                                        (expand o)
                                        (("2"
                                          (inst vari "i-1")
                                          (("2"
                                            (split vari)
                                            (("1" (grind) nil nil)
                                             ("2"
                                              (expand some vari)
                                              (("2"
                                                (lift-if)
                                                (("2"
                                                  (split)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (rewrite
                                                       some_nth)
                                                      (("2"
                                                        (rewrite
                                                         some_nth)
                                                        (("2"
                                                          (skeep)
                                                          (("2"
                                                            (inst?)
                                                            (("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("3" (skeep* :preds? t)
                            (("3" (rewrite map_length)
                              (("3"
                                (inst avar i)
                                (("3"
                                  (split)
                                  (("1" (propax) nil nil)
                                   ("2"
                                    (expand length avar)
                                    (("2"
                                      (lift-if)
                                      (("2"
                                        (split)
                                        (("1" (grind) nil nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("6" (delete obj)
                        (("6" (expand push)
                          (("6" (expand every +)
                            (("6" (skeep :preds? t)
                              (("6"
                                (expand add)
                                (("6"
                                  (lift-if)
                                  (("6"
                                    (split)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (lift-if)
                                          (("1"
                                            (split)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (expand every)
                                                (("1"
                                                  (inst?)
                                                  (("1"
                                                    (inst
                                                     vari
                                                     "index(car(L))")
                                                    (("1"
                                                      (split)
                                                      (("1"
                                                        (grind)
                                                        nil
                                                        nil)
                                                       ("2"
                                                        (expand
                                                         in_varlist)
                                                        (("2"
                                                          (rewrite
                                                           some_nth)
                                                          (("2"
                                                            (inst 1 0)
                                                            (("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (split)
                                                (("1" (grind) nil nil)
                                                 ("2"
                                                  (flatten)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (lift-if)
                                        (("2"
                                          (split 2)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (expand every sdom)
                                              (("1"
                                                (inst?)
                                                (("1"
                                                  (inst
                                                   vari
                                                   "index(car(L))")
                                                  (("1"
                                                    (split vari)
                                                    (("1"
                                                      (grind)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (expand
                                                       in_varlist)
                                                      (("2"
                                                        (rewrite
                                                         some_nth)
                                                        (("2"
                                                          (inst 1 0)
                                                          (("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("7" (delete obj) (("7" (grind) nil nil)) nil)
                       ("8" (delete obj)
                        (("8" (inst vari "index(car(L))")
                          (("8" (split)
                            (("1" (grind) nil nil)
                             ("2" (expand in_varlist)
                              (("2"
                                (rewrite some_nth)
                                (("2"
                                  (inst 1 0)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("9" (delete obj) (("9" (grind) nil nil)) nil)
                       ("10" (delete obj) (("10" (grind) nil nil)) nil)
                       ("11" (delete obj)
                        (("11" (inst vari "index(car(L))")
                          (("1" (split vari)
                            (("1" (grind) nil nil)
                             ("2" (expand in_varlist)
                              (("2"
                                (rewrite some_nth)
                                (("1"
                                  (inst 1 0)
                                  (("1" (grind) nil nil))
                                  nil)
                                 ("2"
                                  (skeep)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil)
                       ("12" (delete obj) (("12" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skeep*)
      (("2" (typepred "D!1`seq(x1)`body")
        (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
      nil)
     ("3" (expand apply_iterm_match) (("3" (assert) nil nil)) nil)
     ("4" (skeep*)
      (("4" (typepred "D!1`seq(x1)`body")
        (("4" (inst?) (("4" (assert) nil nil)) nil)) nil))
      nil)
     ("5" (expand apply_iterm_match) (("5" (assert) nil nil)) nil))
    nil)
   ((pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (measure_induction formula-decl nil measure_induction nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (apply_iterm_match const-decl "bool" iareduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (refs def-decl "bool" IL nil) (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (Defs type-eq-decl nil iareduction nil)
    (Definition type-eq-decl nil iareduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (reduce const-decl "rstate" rreduction nil)
    (letApply def-decl "IExpression" rreduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (letc adt-constructor-decl "[[IContext, IExpression] -> (letc?)]"
     IL nil)
    (letc? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (compose def-decl "IContext" IL nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (fill def-decl "IExpression" IL nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (not_value_redex_fill formula-decl nil IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (redex? const-decl "bool" IL nil)
    (buildRedex_fill formula-decl nil IL nil)
    (variableReduce const-decl "rstate" rreduction nil)
    (get const-decl "(value?)" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (context_composition formula-decl nil IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (B skolem-const-decl "(pure?)" iareduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (vars_letApply formula-decl nil rreduction nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (injective? const-decl "bool" functions nil)
    (reduce_ndr application-judgement "(noDanglingRefs?)" rreduction
     nil)
    (pure_letApply rec-application-judgement "(pure?)" rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (map_length formula-decl nil more_map_props nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (iapply_nstack_iterm def-decl
     "[{S1: Stack | every(domainValue?(dom))(S1)}, [i: (dom) -> nat], IExpression]"
     iareduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (k skolem-const-decl "nat" iareduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (seq type-eq-decl nil more_finseq nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (O const-decl "T3" function_props nil)
    (some adt-def-decl "boolean" list_adt nil)
    (some_map formula-decl nil finseq_theorems nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (popc adt-constructor-decl "[IContext -> (popc?)]" IL nil)
    (popc? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (push const-decl "Stack" IL nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (L skolem-const-decl "{L |
   x!1 < 2 * length(L) AND
    (FORALL i: in_varlist(L)(i) IMPLIES i < S`length) AND
     FORALL i: i < length(L) IMPLIES vars(A)(i)}" iareduction nil)
    (A skolem-const-decl "(pure?)" iareduction nil)
    (S skolem-const-decl "{S | every(domainValue?(dom))(S)}"
     iareduction nil)
    (dom skolem-const-decl "finite_set[nat]" iareduction nil)
    (L skolem-const-decl "{L |
   x!1 < 2 * length(L) AND
    (FORALL i: in_varlist(L)(i) IMPLIES i < S`length) AND
     FORALL i: i < length(L) IMPLIES vars(A)(i)}" iareduction nil)
    (A skolem-const-decl "(pure?)" iareduction nil)
    (x!1 skolem-const-decl "nat" iareduction nil)
    (S skolem-const-decl "{S | every(domainValue?(dom))(S)}"
     iareduction nil)
    (dom skolem-const-decl "finite_set[nat]" iareduction nil)
    (letReduce const-decl "rstate" rreduction nil)
    (pureLetRedex? const-decl "bool" IL nil))
   nil)
  (applyReduce_match_rec-1 nil 3706461802
   ("" (measure-induct+ "k" ("k"))
    (("1" (name-replace "k" "x!1")
      (("1" (case-replace "k = 0")
        (("1" (hide -2)
          (("1" (skeep* :preds? t)
            (("1" (expand apply_iterm_match)
              (("1" (flatten)
                (("1" (expand iapply_nstack_iterm)
                  (("1" (expand rreduction.letApply -)
                    (("1" (rewrite map_length)
                      (("1"
                        (case-replace "length(cdr(L)) = length(L) - 1")
                        (("1"
                          (name-replace "B"
                           "rreduction.letApply(length(L) - 1,
                                            map(LAMBDA
                                                x:
                                                x WITH [`index := 1 + index(x)])
                                               (cdr(L)),
                                            A)")
                          (("1" (case "vars(B)(0)")
                            (("1" (assert)
                              (("1"
                                (case-replace
                                 "fill(K, letexpr(car(L), B)) = fill(compose(K, letc(hole, B)), car(L))")
                                (("1"
                                  (expand reduce)
                                  (("1"
                                    (case
                                     "value?(to_topstate(rS)`redex)")
                                    (("1"
                                      (hide 2)
                                      (("1"
                                        (expand to_topstate)
                                        (("1"
                                          (replace -17)
                                          (("1"
                                            (use not_value_redex_fill)
                                            (("1"
                                              (split)
                                              (("1" (propax) nil nil)
                                               ("2"
                                                (expand redex?)
                                                (("2"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (assert)
                                      (("2"
                                        (lift-if)
                                        (("2"
                                          (expand make_redex)
                                          (("2"
                                            (expand to_topstate)
                                            (("2"
                                              (replace -16)
                                              (("2"
                                                (rewrite
                                                 buildRedex_fill)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (expand
                                                     variableReduce)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (split)
                                                        (("1"
                                                          (lift-if)
                                                          (("1"
                                                            (assert)
                                                            (("1"
                                                              (split)
                                                              (("1"
                                                                (flatten)
                                                                (("1"
                                                                  (assert)
                                                                  (("1"
                                                                    (expand
                                                                     get)
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (flatten)
                                                                (("2"
                                                                  (expand
                                                                   get)
                                                                  (("2"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (expand get)
                                                          (("2"
                                                            (lift-if)
                                                            (("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("3"
                                                          (rewrite
                                                           context_composition)
                                                          (("3"
                                                            (expand
                                                             fill
                                                             1
                                                             2)
                                                            (("3"
                                                              (expand
                                                               fill
                                                               1
                                                               2)
                                                              (("3"
                                                                (expand
                                                                 get)
                                                                (("3"
                                                                  (replace*)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (expand redex?)
                                                  (("2"
                                                    (propax)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (rewrite context_composition)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (delete 3)
                              (("2"
                                (expand B)
                                (("2"
                                  (rewrite vars_letApply)
                                  (("2"
                                    (flatten)
                                    (("2"
                                      (inst -7 "length(L) - 1")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (rewrite map_length) nil nil))
                          nil)
                         ("2" (expand length 1 2)
                          (("2" (lift-if)
                            (("2" (split 1)
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("3" (grind) nil nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (case-replace "k = 1")
          (("1" (hide -2)
            (("1" (skeep* :preds? t)
              (("1" (expand apply_iterm_match)
                (("1" (expand iapply_nstack_iterm)
                  (("1" (assert)
                    (("1" (expand iapply_nstack_iterm)
                      (("1"
                        (name-replace B "rreduction.letApply
                                          (length(map(LAMBDA
                                                      y:
                                                      y WITH [`index := 1 + index(y)])
                                                     (cdr(L))),
                                           map(LAMBDA y: y WITH [`index := 1 + index(y)])
                                              (cdr(L)),
                                           A)")
                        (("1"
                          (with-labels (flatten)
                           ((err dom stom stam cnt rdx)))
                          (("1" (replace stam :dir RL)
                            (("1" (replace cnt :dir RL)
                              (("1"
                                (expand reduce)
                                (("1"
                                  (lift-if)
                                  (("1"
                                    (case
                                     "value?(to_topstate(rS)`redex)")
                                    (("1"
                                      (hide 3)
                                      (("1"
                                        (expand to_topstate)
                                        (("1"
                                          (replace rdx)
                                          (("1"
                                            (lemma
                                             not_value_redex_fill)
                                            (("1"
                                              (inst? :where -2)
                                              (("1" (grind) nil nil)
                                               ("2"
                                                (inst
                                                 -6
                                                 "index(car(L))")
                                                (("2"
                                                  (split -6)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (expand in_varlist)
                                                    (("2"
                                                      (rewrite
                                                       some_nth)
                                                      (("2"
                                                        (inst 1 0)
                                                        (("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (assert)
                                      (("2"
                                        (expand to_topstate)
                                        (("2"
                                          (expand make_redex)
                                          (("2"
                                            (replace rdx)
                                            (("2"
                                              (rewrite buildRedex_fill)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (case
                                                   "pureLetRedex?(letexpr(S`seq(S`length - 1 - index(car(L))), B))")
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (expand
                                                       letReduce)
                                                      (("1"
                                                        (propax)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (hide 5)
                                                    (("2"
                                                      (expand
                                                       pureLetRedex?)
                                                      (("2"
                                                        (expand
                                                         letRedex?)
                                                        (("2"
                                                          (expand B)
                                                          (("2"
                                                            (rewrite
                                                             pure_letApply)
                                                            (("2"
                                                              (postpone)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("3"
                                                    (hide 5)
                                                    (("3"
                                                      (inst
                                                       -5
                                                       "index(car(L))")
                                                      (("3"
                                                        (split -5)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (expand
                                                           in_varlist)
                                                          (("2"
                                                            (rewrite
                                                             some_nth)
                                                            (("2"
                                                              (inst
                                                               1
                                                               0)
                                                              (("2"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (hide 5)
                                                (("2"
                                                  (expand redex?)
                                                  (("2"
                                                    (expand letRedex?)
                                                    (("2"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("3"
                                                (hide 5)
                                                (("3"
                                                  (inst
                                                   -5
                                                   "index(car(L))")
                                                  (("3"
                                                    (split -5)
                                                    (("1"
                                                      (grind)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (expand
                                                       in_varlist)
                                                      (("2"
                                                        (rewrite
                                                         some_nth)
                                                        (("2"
                                                          (inst 1 0)
                                                          (("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (inst -1 "k-2")
            (("1"
              (with-labels (skeep* :preds? t)
               ((domf sdom varl kbnd vari avar ndr k0 k1 hrec apph
                 obj)))
              (("1" (expand apply_iterm_match)
                (("1" (expand iapply_nstack_iterm +)
                  (("1" (assert)
                    (("1" (inst? hrec)
                      (("1" (inst hrec "compose(K, popc(hole))" "str")
                        (("1" (split)
                          (("1" (flatten)
                            (("1" (assert)
                              (("1"
                                (split)
                                (("1" (propax) nil nil)
                                 ("2" (propax) nil nil)
                                 ("3"
                                  (rewrite context_composition)
                                  (("1"
                                    (expand fill hrec 3)
                                    (("1"
                                      (expand fill hrec 3)
                                      (("1" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (delete obj)
                                    (("2"
                                      (flatten)
                                      (("2"
                                        (expand every sdom)
                                        (("2"
                                          (inst
                                           sdom
                                           "S`length - 1 - index(car(L))")
                                          (("1"
                                            (expand domainValue?)
                                            (("1" (assert) nil nil))
                                            nil)
                                           ("2"
                                            (inst vari "index(car(L))")
                                            (("2"
                                              (split)
                                              (("1" (grind) nil nil)
                                               ("2"
                                                (expand in_varlist)
                                                (("2"
                                                  (rewrite some_nth)
                                                  (("2"
                                                    (inst 1 0)
                                                    (("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("3"
                                    (delete obj)
                                    (("3"
                                      (inst vari "index(car(L))")
                                      (("3"
                                        (split)
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (expand in_varlist)
                                          (("2"
                                            (rewrite some_nth)
                                            (("2"
                                              (inst 1 0)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("4"
                                    (delete obj)
                                    (("4" (grind) nil nil))
                                    nil)
                                   ("5"
                                    (delete obj)
                                    (("5"
                                      (inst vari "index(car(L))")
                                      (("5"
                                        (split)
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (expand in_varlist)
                                          (("2"
                                            (rewrite some_nth)
                                            (("2"
                                              (inst 1 0)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("6"
                                    (delete obj)
                                    (("6"
                                      (inst vari "index(car(L))")
                                      (("6"
                                        (split)
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (expand in_varlist)
                                          (("2"
                                            (rewrite some_nth)
                                            (("2"
                                              (inst 1 0)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (delete obj) (("2" (grind) nil nil))
                            nil)
                           ("3" (delete obj) (("3" (grind) nil nil))
                            nil)
                           ("4" (delete obj) (("4" (grind) nil nil))
                            nil)
                           ("5" (delete obj)
                            (("5" (flatten)
                              (("5"
                                (expand iapply_nstack_iterm apph)
                                (("5" (propax) nil nil))
                                nil))
                              nil))
                            nil)
                           ("6" (delete obj)
                            (("6" (flatten)
                              (("6"
                                (expand iapply_nstack_iterm apph)
                                (("6" (propax) nil nil))
                                nil))
                              nil))
                            nil)
                           ("7" (delete obj)
                            (("7" (flatten)
                              (("7"
                                (expand iapply_nstack_iterm apph)
                                (("7"
                                  (rewrite context_composition)
                                  (("1"
                                    (expand fill hrec 3)
                                    (("1"
                                      (expand fill hrec 3)
                                      (("1" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (delete hrec)
                                    (("2"
                                      (flatten)
                                      (("2"
                                        (expand every sdom)
                                        (("2"
                                          (inst
                                           sdom
                                           "S`length - 1 - index(car(L))")
                                          (("1" (grind) nil nil)
                                           ("2"
                                            (inst vari "index(car(L))")
                                            (("2"
                                              (split)
                                              (("1" (grind) nil nil)
                                               ("2"
                                                (expand in_varlist)
                                                (("2"
                                                  (rewrite some_nth)
                                                  (("2"
                                                    (inst 1 0)
                                                    (("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("3"
                                    (delete hrec)
                                    (("3"
                                      (inst vari "index(car(L))")
                                      (("3"
                                        (split)
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (expand in_varlist)
                                          (("2"
                                            (rewrite some_nth)
                                            (("2"
                                              (inst 1 0)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("4"
                                    (delete hrec)
                                    (("4" (grind) nil nil))
                                    nil)
                                   ("5"
                                    (delete hrec)
                                    (("5"
                                      (inst vari "index(car(L))")
                                      (("5"
                                        (split)
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (expand in_varlist)
                                          (("2"
                                            (rewrite some_nth)
                                            (("2"
                                              (inst 1 0)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("6"
                                    (delete hrec)
                                    (("6"
                                      (inst vari "index(car(L))")
                                      (("6"
                                        (split)
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (expand in_varlist)
                                          (("2"
                                            (rewrite some_nth)
                                            (("2"
                                              (inst 1 0)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (delete obj)
                        (("2" (flatten)
                          (("2" (expand every sdom)
                            (("2"
                              (inst sdom
                               "S`length - 1 - index(car(L))")
                              (("1" (grind) nil nil)
                               ("2"
                                (inst vari "index(car(L))")
                                (("2"
                                  (split)
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (expand in_varlist)
                                    (("2"
                                      (rewrite some_nth)
                                      (("2"
                                        (inst 1 0)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (delete obj)
                        (("3" (inst vari "index(car(L))")
                          (("3" (split)
                            (("1" (grind) nil nil)
                             ("2" (expand in_varlist)
                              (("2"
                                (rewrite some_nth)
                                (("2"
                                  (inst 1 0)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("4" (delete obj) (("4" (grind) nil nil)) nil)
                       ("5" (delete obj)
                        (("5" (split)
                          (("1" (rewrite map_length)
                            (("1" (expand length kbnd)
                              (("1"
                                (lift-if kbnd)
                                (("1"
                                  (split kbnd)
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (expand k)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (skeep* :preds? t)
                            (("2" (expand push)
                              (("2"
                                (expand add)
                                (("2"
                                  (assert)
                                  (("2"
                                    (expand in_varlist)
                                    (("2"
                                      (rewrite some_map)
                                      (("2"
                                        (expand o)
                                        (("2"
                                          (inst vari "i-1")
                                          (("2"
                                            (split vari)
                                            (("1" (grind) nil nil)
                                             ("2"
                                              (expand some vari)
                                              (("2"
                                                (lift-if)
                                                (("2"
                                                  (split)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (rewrite
                                                       some_nth)
                                                      (("2"
                                                        (rewrite
                                                         some_nth)
                                                        (("2"
                                                          (skeep)
                                                          (("2"
                                                            (inst?)
                                                            (("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("3" (skeep* :preds? t)
                            (("3" (rewrite map_length)
                              (("3"
                                (inst avar i)
                                (("3"
                                  (split)
                                  (("1" (propax) nil nil)
                                   ("2"
                                    (expand length avar)
                                    (("2"
                                      (lift-if)
                                      (("2"
                                        (split)
                                        (("1" (grind) nil nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("6" (delete obj)
                        (("6" (expand push)
                          (("6" (expand every +)
                            (("6" (skeep :preds? t)
                              (("6"
                                (expand add)
                                (("6"
                                  (lift-if)
                                  (("6"
                                    (split)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (lift-if)
                                          (("1"
                                            (split)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (expand every)
                                                (("1"
                                                  (inst?)
                                                  (("1"
                                                    (inst
                                                     vari
                                                     "index(car(L))")
                                                    (("1"
                                                      (split)
                                                      (("1"
                                                        (grind)
                                                        nil
                                                        nil)
                                                       ("2"
                                                        (expand
                                                         in_varlist)
                                                        (("2"
                                                          (rewrite
                                                           some_nth)
                                                          (("2"
                                                            (inst 1 0)
                                                            (("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (split)
                                                (("1" (grind) nil nil)
                                                 ("2"
                                                  (flatten)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (lift-if)
                                        (("2"
                                          (split 2)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (expand every sdom)
                                              (("1"
                                                (inst?)
                                                (("1"
                                                  (inst
                                                   vari
                                                   "index(car(L))")
                                                  (("1"
                                                    (split vari)
                                                    (("1"
                                                      (grind)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (expand
                                                       in_varlist)
                                                      (("2"
                                                        (rewrite
                                                         some_nth)
                                                        (("2"
                                                          (inst 1 0)
                                                          (("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("7" (delete obj) (("7" (grind) nil nil)) nil)
                       ("8" (delete obj)
                        (("8" (inst vari "index(car(L))")
                          (("8" (split)
                            (("1" (grind) nil nil)
                             ("2" (expand in_varlist)
                              (("2"
                                (rewrite some_nth)
                                (("2"
                                  (inst 1 0)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("9" (delete obj) (("9" (grind) nil nil)) nil)
                       ("10" (delete obj) (("10" (grind) nil nil)) nil)
                       ("11" (delete obj)
                        (("11" (inst vari "index(car(L))")
                          (("1" (split vari)
                            (("1" (grind) nil nil)
                             ("2" (expand in_varlist)
                              (("2"
                                (rewrite some_nth)
                                (("1"
                                  (inst 1 0)
                                  (("1" (grind) nil nil))
                                  nil)
                                 ("2"
                                  (skeep)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil)
                       ("12" (delete obj) (("12" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skeep*)
      (("2" (typepred "D!1`seq(x1)`body")
        (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
      nil)
     ("3" (expand apply_iterm_match) (("3" (assert) nil nil)) nil)
     ("4" (skeep*)
      (("4" (typepred "D!1`seq(x1)`body")
        (("4" (inst?) (("4" (assert) nil nil)) nil)) nil))
      nil)
     ("5" (expand apply_iterm_match) (("5" (assert) nil nil)) nil))
    nil)
   nil shostak))
 (applyReduce_match_init_TCC1 0
  (applyReduce_match_init_TCC1-1 nil 3706471298
   ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (applyReduce_match_init subtype "grS`redex"
    "(IExpression_adt.application?)")))
 (applyReduce_match_init_TCC2 0
  (applyReduce_match_init_TCC2-1 nil 3706471298
   ("" (skeep* :preds? t)
    (("" (typepred "grS`redex")
      (("" (inst -2 i) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (applyRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (applyReduce_match_init subtype "IExpression_adt.args(grS`redex)"
    "{L | FORALL i: IL.in_varlist(L)(i) IMPLIES i < grS`stack`length}")))
 (applyReduce_match_init_TCC3 0
  (applyReduce_match_init_TCC3-1 nil 3706471298
   ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (applyRedex? const-decl "bool" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (applyReduce_match_init subtype "0"
    "upto(2 * list_props[(IExpression_adt.variable?)].length(IExpression_adt.args(grS`redex)))")))
 (applyReduce_match_init 0
  (applyReduce_match_init-1 nil 3706471298
   ("" (skeep* :preds? t)
    (("" (expand reduce)
      (("" (case "value?(to_topstate(grS)`redex)")
        (("1" (hide 2)
          (("1" (expand to_topstate)
            (("1" (use not_value_redex_fill) (("1" (grind) nil nil))
              nil))
            nil))
          nil)
         ("2" (expand* make_redex to_topstate)
          (("2" (rewrite buildRedex_fill)
            (("1" (assert)
              (("1"
                (case "NOT variable?(grS`redex) AND NOT pureLetRedex?(grS`redex)")
                (("1" (flatten)
                  (("1" (assert)
                    (("1" (expand apply_iterm_match)
                      (("1" (expand applyReduce)
                        (("1" (expand iapply_nstack_iterm)
                          (("1" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide 4) (("2" (grind) nil nil)) nil))
                nil))
              nil)
             ("2" (hide 4) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((reduce const-decl "rstate" rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (apply_iterm_match const-decl "bool" iareduction nil)
    (iapply_nstack_iterm def-decl
     "[{S1: Stack | every(domainValue?(dom))(S1)}, [i: (dom) -> nat], IExpression]"
     iareduction nil)
    (applyReduce const-decl "rstate" rreduction nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (buildRedex_fill formula-decl nil IL nil)
    (not_value_redex_fill formula-decl nil IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (redex? const-decl "bool" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (value? const-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (applyReduce_match_lemma_TCC1 0
  (applyReduce_match_lemma_TCC1-1 nil 3706473719
   ("" (skeep* :preds? t)
    (("" (typepred "D`seq(x1)`body")
      (("" (assert)
        (("" (skeep) (("" (inst?) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((Defs type-eq-decl nil iareduction nil)
    (Definition type-eq-decl nil iareduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (unmark_pure rec-application-judgement "(pure?)" preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (applyReduce_match_lemma subtype "D" "Defs")))
 (applyReduce_match_lemma 0
  (applyReduce_match_lemma-1 nil 3706473720
   ("" (skeep :preds? t)
    (("" (induct k 2)
      (("1" (use applyReduce_match_init)
        (("1" (split)
          (("1" (expand rreduce_n)
            (("1" (expand rreduce_n) (("1" (propax) nil nil)) nil))
            nil)
           ("2" (propax) nil nil) ("3" (propax) nil nil)
           ("4" (propax) nil nil) ("5" (propax) nil nil))
          nil))
        nil)
       ("2" (skeep :preds? t)
        (("2" (use applyReduce_match_rec)
          (("1" (split)
            (("1"
              (case-replace
               "reduce(D)(rreduce_n(D)(jt + 1, grS)) = rreduce_n(D)(jt + 1 + 1, grS)")
              (("1" (lemma rreduce_n_compose)
                (("1" (inst -1 D 1 "jt+1" grS)
                  (("1" (expand rreduce_n -1 1)
                    (("1" (lift-if)
                      (("1" (split)
                        (("1" (flatten)
                          (("1" (expand apply_iterm_match)
                            (("1" (flatten) nil nil)) nil))
                          nil)
                         ("2" (assert)
                          (("2" (flatten)
                            (("2" (expand rreduce_n -1 1)
                              (("2" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (propax) nil nil))
            nil)
           ("2" (use rreduce_n_ndr) nil nil)
           ("3" (split)
            (("1" (propax) nil nil)
             ("2" (skeep)
              (("2" (typepred "grS`redex")
                (("2" (inst -2 i)
                  (("2" (split)
                    (("1" (grind) nil nil)
                     ("2" (expand applyRedex?)
                      (("2" (assert) (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (skeep)
              (("3" (typepred "D`seq(fun(grS`redex))`body")
                (("3" (inst -2 i)
                  (("3" (rewrite vars_mark)
                    (("3" (replace -2)
                      (("3" (replace -11) (("3" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("4" (use pure_mark)
            (("4" (typepred "D`seq(fun(grS`redex))`body")
              (("4" (assert) nil nil)) nil))
            nil))
          nil))
        nil)
       ("3" (skeep :preds? t)
        (("3" (typepred "D`seq(x1)`body")
          (("3" (split)
            (("1" (skeep) (("1" (inst?) (("1" (assert) nil nil)) nil))
              nil)
             ("2" (propax) nil nil))
            nil))
          nil))
        nil)
       ("4" (skeep)
        (("4" (typepred "grS`redex")
          (("4" (inst -2 i)
            (("4" (split)
              (("1" (grind) nil nil)
               ("2" (expand applyRedex?)
                (("2" (assert) (("2" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (grS skolem-const-decl "rreduction.goodrstate" iareduction nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (pure? def-decl "bool" IL nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil iareduction nil)
    (Defs type-eq-decl nil iareduction nil)
    (D skolem-const-decl "Defs" iareduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (apply_iterm_match const-decl "bool" iareduction nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (Definition type-eq-decl nil reduction_props nil)
    (Defs type-eq-decl nil reduction_props nil)
    (rreduce_n def-decl "rstate" reduction_props nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (args adt-accessor-decl "[(application?) -> list[(variable?)]]"
          IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (list type-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (upto_induction formula-decl nil bounded_nat_inductions nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (applyReduce_match_init formula-decl nil iareduction nil)
    (applyReduce_match_rec formula-decl nil iareduction nil)
    (jt skolem-const-decl "upto(2 * length(args(grS`redex)))"
     iareduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce const-decl "rstate" rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (reduce_ndr application-judgement "(noDanglingRefs?)" rreduction
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (rreduce_n_compose formula-decl nil reduction_props nil)
    (rreduce_n_ndr formula-decl nil reduction_props nil)
    (vars_mark formula-decl nil preprocess nil)
    (applyRedex? const-decl "bool" IL nil)
    (unmark_pure rec-application-judgement "(pure?)" preprocess nil)
    (pure_mark formula-decl nil preprocess nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (iapply_nstack_iterm_end_TCC1 0
  (iapply_nstack_iterm_end_TCC1-1 nil 3706471750
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (Stack type-eq-decl nil IL nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (in_varlist const-decl "finite_set[nat]" IL nil))
   nil
   (iapply_nstack_iterm_end subtype "args"
    "{args: list[(IExpression_adt.variable?)] | 2 * arity <= 2 * list_props[(IExpression_adt.variable?)].length(args) AND FORALL i: IL.in_varlist(args)(i) IMPLIES i < S`length}")))
 (iapply_nstack_iterm_end 0
  (iapply_nstack_iterm_end-1 nil 3706471751
   ("" (induct arity)
    (("1" (skeep* :preds? t)
      (("1" (assert)
        (("1" (expand iapply_nstack)
          (("1" (expand iapply_nstack_iterm)
            (("1" (expand npops)
              (("1" (expand letApply) (("1" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skeep* :preds? t)
      (("2" (expand iapply_nstack +)
        (("2" (assert)
          (("2" (expand iapply_nstack_iterm +)
            (("2" (lift-if)
              (("2" (split)
                (("1" (flatten)
                  (("1" (assert)
                    (("1" (inst? -9)
                      (("1" (flatten)
                        (("1" (replace -9)
                          (("1" (replace -10)
                            (("1" (replace -11) (("1" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide 2)
                        (("2" (skeep* :preds? t)
                          (("2" (typepred "cnt(x1)")
                            (("2" (rewrite -1)
                              (("2"
                                (expand refcount)
                                (("2"
                                  (expand push)
                                  (("2"
                                    (expand refcountStack)
                                    (("2"
                                      (rewrite count_add)
                                      (("1"
                                        (rewrite count_update)
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (inst -8 "index(car(args))")
                                          (("2"
                                            (split -8)
                                            (("1" (grind) nil nil)
                                             ("2"
                                              (expand in_varlist)
                                              (("2"
                                                (rewrite some_nth)
                                                (("2"
                                                  (inst 1 0)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("3" (grind) nil nil))
                                        nil)
                                       ("2" (grind) nil nil)
                                       ("3"
                                        (inst -8 "index(car(args))")
                                        (("3"
                                          (split -8)
                                          (("1" (grind) nil nil)
                                           ("2"
                                            (expand in_varlist)
                                            (("2"
                                              (rewrite some_nth)
                                              (("2"
                                                (inst 1 0)
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (hide 2)
                        (("3" (split)
                          (("1" (rewrite map_length)
                            (("1" (expand length -)
                              (("1"
                                (lift-if)
                                (("1"
                                  (split)
                                  (("1" (grind) nil nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (skeep)
                            (("2" (expand in_varlist)
                              (("2"
                                (rewrite some_map)
                                (("2"
                                  (expand o)
                                  (("2"
                                    (rewrite some_nth)
                                    (("2"
                                      (skeep)
                                      (("2"
                                        (inst -8 "i-1")
                                        (("1"
                                          (rewrite some_nth)
                                          (("1"
                                            (split)
                                            (("1" (grind) nil nil)
                                             ("2"
                                              (inst 1 "i_1+1")
                                              (("1" (grind) nil nil)
                                               ("2"
                                                (expand length 1)
                                                (("2"
                                                  (lift-if)
                                                  (("2"
                                                    (split)
                                                    (("1"
                                                      (grind)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("4" (hide 2)
                        (("4" (expand every)
                          (("4" (skeep :preds? t)
                            (("4" (expand* push add)
                              (("4"
                                (lift-if)
                                (("4"
                                  (split)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (inst?)
                                      (("1"
                                        (inst -8 "index(car(args))")
                                        (("1"
                                          (split -8)
                                          (("1" (grind) nil nil)
                                           ("2"
                                            (expand in_varlist)
                                            (("2"
                                              (rewrite some_nth)
                                              (("2"
                                                (inst 1 0)
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (split)
                                      (("1" (grind) nil nil)
                                       ("2"
                                        (flatten)
                                        (("2" (inst?) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("5" (hide 2) (("5" (grind) nil nil)) nil)
                       ("6" (hide 2)
                        (("6" (inst -7 "index(car(args))")
                          (("6" (split)
                            (("1" (grind) nil nil)
                             ("2" (expand in_varlist)
                              (("2"
                                (rewrite some_nth)
                                (("2"
                                  (inst 1 0)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (assert)
                    (("2"
                      (case "ref?(S`seq(S`length - 1 - index(car(args))))")
                      (("1" (assert)
                        (("1" (inst? -8)
                          (("1" (flatten)
                            (("1" (replace -8)
                              (("1"
                                (replace -9)
                                (("1"
                                  (replace -10)
                                  (("1" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide 3)
                            (("2"
                              (typepred
                               "cnt(refindex(S`seq(S`length - 1 - index(car[(variable?)](args)))))")
                              (("2"
                                (rewrite -1)
                                (("2"
                                  (expand refcount)
                                  (("2"
                                    (expand refcountStack)
                                    (("2"
                                      (expand push)
                                      (("2"
                                        (rewrite count_add)
                                        (("2"
                                          (skeep)
                                          (("2"
                                            (inst
                                             -7
                                             "index(car(args))")
                                            (("2"
                                              (split)
                                              (("1" (grind) nil nil)
                                               ("2"
                                                (expand in_varlist)
                                                (("2"
                                                  (rewrite some_nth)
                                                  (("2"
                                                    (inst 1 0)
                                                    (("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("3" (hide 3)
                            (("3" (expand every)
                              (("3"
                                (inst?)
                                (("1" (grind) nil nil)
                                 ("2"
                                  (inst -5 "index(car(args))")
                                  (("2"
                                    (split)
                                    (("1" (grind) nil nil)
                                     ("2"
                                      (expand in_varlist)
                                      (("2"
                                        (rewrite some_nth)
                                        (("2"
                                          (inst 1 0)
                                          (("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("4" (hide 3)
                            (("4" (split)
                              (("1"
                                (rewrite map_length)
                                (("1"
                                  (expand length -5)
                                  (("1"
                                    (lift-if)
                                    (("1"
                                      (split)
                                      (("1" (grind) nil nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (skeep)
                                (("2"
                                  (expand in_varlist)
                                  (("2"
                                    (rewrite some_map)
                                    (("2"
                                      (expand o)
                                      (("2"
                                        (inst -7 "i-1")
                                        (("1"
                                          (rewrite some_nth)
                                          (("1"
                                            (rewrite some_nth)
                                            (("1"
                                              (skeep)
                                              (("1"
                                                (split)
                                                (("1" (grind) nil nil)
                                                 ("2"
                                                  (inst 1 "i_1+1")
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (expand length 1)
                                                    (("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("5" (hide 3)
                            (("5" (expand every)
                              (("5"
                                (skeep* :preds? t)
                                (("5"
                                  (expand push)
                                  (("5"
                                    (expand add)
                                    (("5"
                                      (lift-if)
                                      (("5"
                                        (split)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (inst?)
                                            (("1"
                                              (inst
                                               -7
                                               "index(car(args))")
                                              (("1"
                                                (split -7)
                                                (("1" (grind) nil nil)
                                                 ("2"
                                                  (expand in_varlist)
                                                  (("2"
                                                    (rewrite some_nth)
                                                    (("2"
                                                      (inst 1 0)
                                                      (("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (flatten)
                                          (("2" (inst?) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("6" (hide 3)
                            (("6" (inst -6 "index(car(args))")
                              (("6"
                                (split)
                                (("1" (grind) nil nil)
                                 ("2"
                                  (expand in_varlist)
                                  (("2"
                                    (rewrite some_nth)
                                    (("2"
                                      (inst 1 0)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (assert)
                        (("2" (inst? -7)
                          (("1" (flatten)
                            (("1" (replace -7)
                              (("1"
                                (replace -8)
                                (("1"
                                  (replace -9)
                                  (("1" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide 4)
                            (("2" (skeep :preds? t)
                              (("2"
                                (typepred "cnt(x1)")
                                (("2"
                                  (rewrite -1)
                                  (("2"
                                    (expand refcount)
                                    (("2"
                                      (expand refcountStack)
                                      (("2"
                                        (expand push)
                                        (("2"
                                          (rewrite count_add)
                                          nil
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("3" (hide 4)
                            (("3" (split)
                              (("1"
                                (rewrite map_length)
                                (("1"
                                  (expand length -)
                                  (("1"
                                    (lift-if)
                                    (("1"
                                      (split)
                                      (("1" (grind) nil nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (skeep)
                                (("2"
                                  (expand in_varlist)
                                  (("2"
                                    (rewrite some_map)
                                    (("2"
                                      (expand o)
                                      (("2"
                                        (inst -6 "i-1")
                                        (("1"
                                          (rewrite some_nth)
                                          (("1"
                                            (rewrite some_nth)
                                            (("1"
                                              (skeep)
                                              (("1"
                                                (split)
                                                (("1" (grind) nil nil)
                                                 ("2"
                                                  (inst 1 "i_1+1")
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (expand length +)
                                                    (("2"
                                                      (lift-if)
                                                      (("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("4" (hide 4)
                            (("4" (expand every)
                              (("4"
                                (skeep)
                                (("4"
                                  (expand* push add)
                                  (("4"
                                    (lift-if)
                                    (("4"
                                      (split)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (inst?)
                                          (("1"
                                            (inst
                                             -5
                                             "index(car(args))")
                                            (("1" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("5" (hide 4)
                            (("5" (inst -5 "index(car(args))")
                              (("5"
                                (split -5)
                                (("1" (grind) nil nil)
                                 ("2"
                                  (expand in_varlist)
                                  (("2"
                                    (rewrite some_nth)
                                    (("2"
                                      (inst 1 0)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (hide 3)
                        (("3" (inst -5 "index(car(args))")
                          (("3" (split -5)
                            (("1" (grind) nil nil)
                             ("2" (expand in_varlist)
                              (("2"
                                (rewrite some_nth)
                                (("2"
                                  (inst 1 0)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("4" (hide 3) (("4" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2) (("3" (skeep* :preds? t) nil nil)) nil)
     ("4" (hide 2) (("4" (skeep* :preds? t) nil nil)) nil)
     ("5" (hide 2) (("5" (skeep* :preds? t) nil nil)) nil))
    nil)
   ((even_plus_even_is_even application-judgement "even_int" integers
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (i_1 skolem-const-decl "below(length(cdr[(variable?)](args)))"
     iareduction nil)
    (i skolem-const-decl "nat" iareduction nil)
    (i_1 skolem-const-decl "below(length(cdr[(variable?)](args)))"
     iareduction nil)
    (i skolem-const-decl "nat" iareduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dom skolem-const-decl "finite_set[nat]" iareduction nil)
    (S skolem-const-decl "{S | every(domainValue?(dom))(S)}"
     iareduction nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (j skolem-const-decl "nat" iareduction nil)
    (args skolem-const-decl "{args: list[(variable?)] |
   length(args) = 1 + j AND
    FORALL i: in_varlist(args)(i) IMPLIES i < S`length}" iareduction
          nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (push const-decl "Stack" IL nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (str skolem-const-decl "Store(dom)" iareduction nil)
    (A skolem-const-decl "IExpression" iareduction nil)
    (cnt skolem-const-decl
     "[i: (dom) -> {j | j = refcount(dom, str, S, A)(i)}]" iareduction
     nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (count_add formula-decl nil finseq_theorems nil)
    (nth def-decl "T" list_props nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (count const-decl "nat" finseq_theorems nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (count_update formula-decl nil finseq_theorems nil)
    (below type-eq-decl nil naturalnumbers nil)
    (refcountStack const-decl "nat" rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (map_length formula-decl nil more_map_props nil)
    (TRUE const-decl "bool" booleans nil)
    (O const-decl "T3" function_props nil)
    (i_1 skolem-const-decl "below(length(cdr[(variable?)](args)))"
     iareduction nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (i skolem-const-decl "nat" iareduction nil)
    (some_map formula-decl nil finseq_theorems nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (letApply def-decl "IExpression" rreduction nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (npops def-decl "IExpression" iareduction nil)
    (pred type-eq-decl nil defined_types nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (iapply_nstack_iterm def-decl
     "[{S1: Stack | every(domainValue?(dom))(S1)}, [i: (dom) -> nat], IExpression]"
     iareduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (iapply_nstack def-decl
     "{((S1: Stack | every(domainValue?(dom))(S1))),
 ((ncnt: [i: (dom) -> {j | j = refcount(dom, str, S1, A)(i)}])) |
   S1`length = S`length + arity}" iareduction nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (applyReduce_match_TCC1 0
  (applyReduce_match_TCC1-1 nil 3706456701
   ("" (skeep* :preds? t)
    (("" (typepred "D`seq(x1)`body")
      (("" (assert)
        (("" (skeep) (("" (inst?) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((Defs type-eq-decl nil iareduction nil)
    (Definition type-eq-decl nil iareduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (unmark_pure rec-application-judgement "(pure?)" preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (applyReduce_match subtype "D" "Defs")))
 (applyReduce_match 0
  (applyReduce_match-1 nil 3706534413
   ("" (skeep* :preds? t)
    ((""
      (case "fun(grS`redex) < D`length AND length(args(grS`redex)) = D`seq(fun(grS`redex))`arity")
      (("1" (flatten)
        (("1" (inst 2 "1+2*length(args(grS`redex))")
          (("1" (use applyReduce_match_lemma)
            (("1" (split)
              (("1" (inst -1 "2*length(args(grS`redex))")
                (("1" (lemma iapply_nstack_iterm_end)
                  (("1"
                    (inst -1 "length(args(grS`redex))" "grS`domain"
                     "grS`stack" "args(grS`redex)" "grS`store"
                     "grS`redex"
                     "mark(emptyset)(D`seq(fun(grS`redex))`body)"
                     "grS`count")
                    (("1" (flatten)
                      (("1" (expand apply_iterm_match)
                        (("1" (replace -1)
                          (("1" (replace -2)
                            (("1" (replace -3)
                              (("1"
                                (expand state_matches?)
                                (("1"
                                  (expand iapplyReduce)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (flatten)
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (propax) nil nil) ("3" (propax) nil nil)
               ("4" (propax) nil nil) ("5" (propax) nil nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (inst 3 1)
        (("2" (expand rreduce_n)
          (("2" (expand rreduce_n)
            (("2" (expand reduce)
              (("2" (case "value?(to_topstate(grS)`redex)")
                (("1" (hide 3)
                  (("1" (expand to_topstate)
                    (("1" (use not_value_redex_fill)
                      (("1" (grind) nil nil)) nil))
                    nil))
                  nil)
                 ("2" (assert)
                  (("2"
                    (case-replace "make_redex(to_topstate(grS)) = grS")
                    (("1"
                      (case "NOT variable?(grS`redex) AND NOT pureLetRedex?(grS`redex)")
                      (("1" (assert)
                        (("1" (flatten)
                          (("1" (assert)
                            (("1" (expand applyReduce)
                              (("1"
                                (expand iapplyReduce)
                                (("1"
                                  (assert)
                                  (("1"
                                    (split)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (expand state_matches?)
                                        (("1" (propax) nil nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (assert)
                                      (("2"
                                        (expand state_matches?)
                                        (("2" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide 5) (("2" (grind) nil nil)) nil))
                      nil)
                     ("2" (hide 5)
                      (("2" (decompose-equality)
                        (("1" (expand* make_redex to_topstate)
                          (("1" (use buildRedex_fill)
                            (("1" (grind) nil nil)) nil))
                          nil)
                         ("2" (grind) nil nil) ("3" (grind) nil nil)
                         ("4" (grind) nil nil)
                         ("5" (expand* make_redex to_topstate)
                          (("5" (use buildRedex_fill)
                            (("5" (grind) nil nil)) nil))
                          nil)
                         ("6" (grind) nil nil) ("7" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (grind) nil nil) ("4" (grind) nil nil))
      nil))
    nil)
   ((args adt-accessor-decl "[(application?) -> list[(variable?)]]"
          IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil)
    (Defs type-eq-decl nil iareduction nil)
    (Definition type-eq-decl nil iareduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (pure? def-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (iapply_nstack_iterm_end formula-decl nil iareduction nil)
    (iapplyReduce const-decl "rstate" iareduction nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (state_matches? const-decl "bool" iareduction nil)
    (apply_iterm_match const-decl "bool" iareduction nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (applyReduce_match_lemma formula-decl nil iareduction nil)
    (rreduce_n def-decl "rstate" reduction_props nil)
    (reduce const-decl "rstate" rreduction nil)
    (buildRedex_fill formula-decl nil IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (applyReduce const-decl "rstate" rreduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (pureRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (not_value_redex_fill formula-decl nil IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (redex? const-decl "bool" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (bisimulation_theorem_TCC1 0
  (bisimulation_theorem_TCC1-1 nil 3706456701
   ("" (skeep* :preds? t)
    (("" (typepred "D`seq(x1)`body")
      (("" (assert)
        (("" (skeep) (("" (inst?) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((Defs type-eq-decl nil iareduction nil)
    (Definition type-eq-decl nil iareduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (unmark_pure rec-application-judgement "(pure?)" preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (bisimulation_theorem subtype "D" "Defs")))
 (bisimulation_theorem 0
  (bisimulation_theorem-1 nil 3706456734
   ("" (skeep* :preds? t)
    (("" (expand rreduce_n)
      (("" (expand reduce)
        (("" (expand iareduce)
          (("" (case-replace "to_topstate(grS2) = to_topstate(grS1)")
            (("1"
              (case "applyRedex?
                                            (make_redex
                                             (to_topstate(grS1))`redex)")
              (("1" (case "value?(to_topstate(grS1)`redex)")
                (("1" (inst 3 1)
                  (("1" (assert)
                    (("1" (expand* state_matches? rreduce_n) nil nil))
                    nil))
                  nil)
                 ("2"
                  (name-replace nS1 "make_redex(to_topstate(grS1))")
                  (("2"
                    (case "NOT variable?(nS1`redex) AND NOT pureLetRedex?(nS1`redex)")
                    (("1" (flatten)
                      (("1" (assert)
                        (("1" (use applyReduce_match)
                          (("1" (split)
                            (("1" (expand rreduce_n -1)
                              (("1"
                                (case "nS1`error")
                                (("1"
                                  (expand nS1)
                                  (("1" (grind) nil nil))
                                  nil)
                                 ("2"
                                  (assert)
                                  (("2"
                                    (expand reduce -1)
                                    (("2"
                                      (expand nS1)
                                      (("2"
                                        (rewrite make_redex_idem)
                                        (("2"
                                          (assert)
                                          (("2"
                                            (case
                                             "value?
                                    (to_topstate
                                     (make_redex(to_topstate(grS1)))`redex)")
                                            (("1"
                                              (rewrite
                                               to_topstate_make_redex)
                                              nil
                                              nil)
                                             ("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (propax) nil nil)
                             ("3" (expand nS1)
                              (("3"
                                (lemma make_redex_ndr)
                                (("3"
                                  (inst?)
                                  (("3"
                                    (lemma to_topstate_dangling)
                                    (("3" (inst?) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand nS1) (("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide 5) (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (assert)
                (("2" (inst 4 1)
                  (("2" (assert)
                    (("2" (expand rreduce_n)
                      (("2" (lift-if)
                        (("2" (expand state_matches?)
                          (("2" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (inst 3 1)
                (("3" (assert)
                  (("3" (expand state_matches?)
                    (("3" (expand rreduce_n) (("3" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide 4)
              (("2" (decompose-equality 1)
                (("1" (grind) nil nil) ("2" (grind) nil nil)
                 ("3" (grind) nil nil) ("4" (grind) nil nil)
                 ("5" (grind) nil nil) ("6" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((rreduce_n def-decl "rstate" reduction_props nil)
    (iareduce const-decl "rstate" iareduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (letRedex? const-decl "bool" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (applyReduce_match formula-decl nil iareduction nil)
    (pure? def-decl "bool" IL nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil iareduction nil)
    (Defs type-eq-decl nil iareduction nil)
    (nS1 skolem-const-decl "{rS | pureRedex?(rS`redex)}" iareduction
     nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (grS1 skolem-const-decl "rreduction.goodrstate" iareduction nil)
    (to_topstate_dangling judgement-tcc nil rreduction nil)
    (make_redex_ndr judgement-tcc nil rreduction nil)
    (to_topstate_make_redex formula-decl nil rreduction nil)
    (make_redex_idem formula-decl nil rreduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (state_matches? const-decl "bool" iareduction nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (reduce const-decl "rstate" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak)))

